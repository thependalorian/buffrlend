-- =====================================================
-- BuffrLend KYC Verification Tables Migration
-- =====================================================
-- Description: Creates KYC and verification related tables
-- Dependencies: 02_core_tables.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Create employee_verifications table
CREATE TABLE IF NOT EXISTS public.employee_verifications (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    company_id UUID REFERENCES public.partner_companies(id) ON DELETE CASCADE NOT NULL,
    employee_id TEXT NOT NULL,
    department TEXT,
    job_title TEXT,
    employment_type TEXT DEFAULT 'permanent' CHECK (employment_type IN ('permanent', 'contract', 'temporary', 'probation')),
    employment_start_date DATE NOT NULL,
    employment_end_date DATE,
    gross_monthly_salary NUMERIC,
    net_monthly_salary NUMERIC,
    salary_currency TEXT DEFAULT 'NAD',
    verification_status TEXT DEFAULT 'pending' CHECK (verification_status IN ('pending', 'verified', 'rejected', 'expired')),
    verification_method TEXT CHECK (verification_method IN ('hr_system', 'manual_upload', 'payroll_api', 'third_party')),
    verified_by UUID REFERENCES public.profiles(id),
    verified_at TIMESTAMPTZ,
    employment_letter_path TEXT,
    payslip_paths JSONB DEFAULT '[]',
    is_eligible_for_loans BOOLEAN DEFAULT TRUE,
    eligibility_reason TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create kyc_verifications table
CREATE TABLE IF NOT EXISTS public.kyc_verifications (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    application_id TEXT NOT NULL,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    company_id UUID REFERENCES public.partner_companies(id) ON DELETE CASCADE,
    employee_verification_id UUID REFERENCES public.employee_verifications(id),
    personal_info JSONB,
    verification_results JSONB DEFAULT '{}',
    risk_score NUMERIC DEFAULT 0.00,
    risk_level TEXT DEFAULT 'medium' CHECK (risk_level IN ('low', 'medium', 'high')),
    decision TEXT DEFAULT 'pending' CHECK (decision IN ('pending', 'approved', 'rejected', 'manual_review')),
    audit_log JSONB DEFAULT '[]',
    document_metadata JSONB DEFAULT '{}',
    manual_review_assigned_to UUID REFERENCES auth.users(id),
    manual_review_notes TEXT,
    manual_review_completed_at TIMESTAMPTZ,
    estimated_processing_time TEXT DEFAULT 'Processing',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    llava_analysis JSONB DEFAULT '{}',
    llava_confidence_score INTEGER CHECK (llava_confidence_score >= 0 AND llava_confidence_score <= 100),
    llava_provider_used TEXT,
    llava_processing_time INTEGER,
    document_complexity_level TEXT CHECK (document_complexity_level IN ('low', 'medium', 'high')),
    vision_processing_status TEXT DEFAULT 'pending' CHECK (vision_processing_status IN ('pending', 'processing', 'completed', 'failed')),
    document_number TEXT
);



-- Create verification_requests table
CREATE TABLE IF NOT EXISTS public.verification_requests (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    verification_type verification_type_enum NOT NULL,
    status verification_status_enum DEFAULT 'pending',
    priority INTEGER DEFAULT 3 CHECK (priority >= 1 AND priority <= 5),
    submitted_at TIMESTAMPTZ DEFAULT NOW(),
    assigned_to UUID REFERENCES public.profiles(id),
    assigned_at TIMESTAMPTZ,
    reviewed_by UUID REFERENCES public.profiles(id),
    reviewed_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    rejection_reason TEXT,
    notes TEXT,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create document_submissions table
CREATE TABLE IF NOT EXISTS public.document_submissions (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    verification_request_id UUID REFERENCES public.verification_requests(id) ON DELETE CASCADE NOT NULL,
    document_type document_type_enum NOT NULL,
    document_data JSONB,
    status VARCHAR DEFAULT 'pending',
    verification_notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);



-- Create admin_verification_decisions table
CREATE TABLE IF NOT EXISTS public.admin_verification_decisions (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    verification_request_id UUID REFERENCES public.verification_requests(id) ON DELETE CASCADE NOT NULL,
    admin_id UUID REFERENCES public.profiles(id) NOT NULL,
    decision verification_status_enum NOT NULL,
    decision_reason TEXT,
    confidence_score NUMERIC CHECK (confidence_score >= 0 AND confidence_score <= 1),
    evidence JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ
);

-- Create verification_audit_log table
CREATE TABLE IF NOT EXISTS public.verification_audit_log (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    verification_request_id UUID REFERENCES public.verification_requests(id),
    admin_id UUID REFERENCES public.profiles(id),
    action VARCHAR NOT NULL,
    old_values JSONB,
    new_values JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_employee_verifications_user_id ON public.employee_verifications(user_id);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_company_id ON public.employee_verifications(company_id);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_status ON public.employee_verifications(verification_status);

CREATE INDEX IF NOT EXISTS idx_kyc_verifications_user_id ON public.kyc_verifications(user_id);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_application_id ON public.kyc_verifications(application_id);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_decision ON public.kyc_verifications(decision);



CREATE INDEX IF NOT EXISTS idx_verification_requests_user_id ON public.verification_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_verification_requests_status ON public.verification_requests(status);
CREATE INDEX IF NOT EXISTS idx_verification_requests_type ON public.verification_requests(verification_type);

CREATE INDEX IF NOT EXISTS idx_document_submissions_request_id ON public.document_submissions(verification_request_id);
CREATE INDEX IF NOT EXISTS idx_document_submissions_type ON public.document_submissions(document_type);



-- Add table comments
COMMENT ON TABLE public.employee_verifications IS 'Links employees to their verified employers';
COMMENT ON TABLE public.kyc_verifications IS 'Stores KYC verification results and audit trails';
COMMENT ON TABLE public.verification_requests IS 'Tracks verification requests and their status';
COMMENT ON TABLE public.document_submissions IS 'Document submissions for verification requests';
COMMENT ON TABLE public.admin_verification_decisions IS 'Admin decisions on verification requests';
COMMENT ON TABLE public.verification_audit_log IS 'Audit log for verification request changes';

-- Apply updated_at triggers
CREATE TRIGGER update_employee_verifications_updated_at
    BEFORE UPDATE ON public.employee_verifications
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_kyc_verifications_updated_at
    BEFORE UPDATE ON public.kyc_verifications
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_verification_requests_updated_at
    BEFORE UPDATE ON public.verification_requests
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_document_submissions_updated_at
    BEFORE UPDATE ON public.document_submissions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/03_kyc_verification_tables.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/supabase/migrations/06_unified_monitoring.sql --\n
-- =====================================================
-- BuffrLend Database Extensions Migration
-- =====================================================
-- Description: Creates required PostgreSQL extensions
-- Dependencies: None
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- Create custom types and enums


CREATE TYPE verification_type_enum AS ENUM ('identity', 'address', 'income', 'employment', 'banking', 'credit_check', 'kyc_aml');
CREATE TYPE verification_status_enum AS ENUM ('pending', 'in_progress', 'verified', 'rejected', 'requires_review');
CREATE TYPE document_type_enum AS ENUM ('passport', 'drivers_license', 'national_id', 'utility_bill', 'bank_statement', 'pay_stub', 'tax_return', 'employment_letter', 'other');
CREATE TYPE task_status AS ENUM ('todo', 'doing', 'review', 'done');

-- Create indexes for extensions
CREATE INDEX IF NOT EXISTS idx_uuid_extension ON pg_extension(extname) WHERE extname = 'uuid-ossp';
CREATE INDEX IF NOT EXISTS idx_pgcrypto_extension ON pg_extension(extname) WHERE extname = 'pgcrypto';
CREATE INDEX IF NOT EXISTS idx_vector_extension ON pg_extension(extname) WHERE extname = 'vector';

-- Add comments for documentation
COMMENT ON EXTENSION "uuid-ossp" IS 'Provides functions to generate universally unique identifiers (UUIDs)';
COMMENT ON EXTENSION "pgcrypto" IS 'Provides cryptographic functions for PostgreSQL';
COMMENT ON EXTENSION "vector" IS 'Provides vector similarity search capabilities for AI/ML applications';

-- Create a function to check if extensions are properly installed
CREATE OR REPLACE FUNCTION check_required_extensions()
RETURNS TABLE(extension_name text, installed boolean) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ext.extname::text,
        true as installed
    FROM pg_extension ext
    WHERE ext.extname IN ('uuid-ossp', 'pgcrypto', 'vector')
    UNION ALL
    SELECT 
        unnest(ARRAY['uuid-ossp', 'pgcrypto', 'vector'])::text,
        false as installed
    WHERE NOT EXISTS (
        SELECT 1 FROM pg_extension 
        WHERE extname IN ('uuid-ossp', 'pgcrypto', 'vector')
    );
END;
$$ LANGUAGE plpgsql;

-- Grant execute permission to authenticated users
GRANT EXECUTE ON FUNCTION check_required_extensions() TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/01_extensions.sql --\n
-- =====================================================
-- BuffrLend Sample Data Migration
-- =====================================================
-- Description: Inserts sample data for development and testing
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Insert sample fee categories
INSERT INTO public.fee_categories (category_name, description, is_active) VALUES
('BUFFR Fees', 'Fees charged by BuffrLend for loan processing and management', true),
('User Fees', 'Fees charged directly to the borrower', true),
('RealPay Fees', 'Fees charged by RealPay for payment processing', true),
('Regulatory Fees', 'Fees required by Namibian financial regulations', true)
ON CONFLICT (category_name) DO NOTHING;

-- Insert sample fee configurations
INSERT INTO public.fee_configurations (config_name, config_value, description, is_active, category_id) VALUES
('base_interest_rate', 15.00, 'Base interest rate percentage', true, (SELECT id FROM public.fee_categories WHERE category_name = 'BUFFR Fees')),
('processing_fee', 100.00, 'Loan processing fee in NAD', true, (SELECT id FROM public.fee_categories WHERE category_name = 'User Fees')),
('realpay_transaction_fee', 2.50, 'RealPay transaction processing fee', true, (SELECT id FROM public.fee_categories WHERE category_name = 'RealPay Fees')),
('namfisa_levy', 0.50, 'NAMFISA regulatory levy percentage', true, (SELECT id FROM public.fee_categories WHERE category_name = 'Regulatory Fees')),
('late_payment_fee', 5.00, 'Late payment penalty fee', true, (SELECT id FROM public.fee_categories WHERE category_name = 'User Fees')),
('early_repayment_fee', 2.00, 'Early repayment processing fee', true, (SELECT id FROM public.fee_categories WHERE category_name = 'User Fees'))
ON CONFLICT (config_name) DO NOTHING;

-- Insert sample loan terms
INSERT INTO public.loan_terms (term_category, term_name, term_value, loan_product, company_tier, employment_type, description, namfisa_reference) VALUES
('eligibility', 'minimum_employment_tenure', '{"value": 3, "unit": "months"}', 'all', 'all', 'all', 'Minimum employment tenure required for loan eligibility', 'MLS4 Section 3.2'),
('amounts', 'maximum_loan_amount', '{"value": 10000, "currency": "NAD"}', 'all', 'all', 'all', 'Maximum loan amount per application', 'MLS4 Section 4.1'),
('duration', 'maximum_loan_term', '{"value": 5, "unit": "months"}', 'all', 'all', 'all', 'Maximum loan term in months', 'MLS4 Section 4.2'),
('affordability', 'maximum_dti_ratio', '{"value": 33.33, "unit": "percentage"}', 'all', 'all', 'all', 'Maximum debt-to-income ratio allowed', 'MLS4 Section 5.1'),
('documentation', 'required_documents', '{"documents": ["national_id", "payslip", "employment_letter"]}', 'all', 'all', 'all', 'Required documentation for loan application', 'MLS4 Section 6.1')
ON CONFLICT DO NOTHING;

-- Insert sample responsible lending policies
INSERT INTO public.responsible_lending_policies (policy_name, policy_type, policy_value, policy_description, namfisa_guideline, is_active) VALUES
('DTI Limit', 'dti_limit', 33.33, 'Maximum debt-to-income ratio of 33.33%', 'MLS4 Section 5.1', true),
('Income Requirement', 'income_requirement', 3000.00, 'Minimum monthly income of N$3,000', 'MLS4 Section 3.1', true),
('Loan Limit', 'loan_limit', 10000.00, 'Maximum loan amount of N$10,000', 'MLS4 Section 4.1', true),
('Term Limit', 'term_limit', 5, 'Maximum loan term of 5 months', 'MLS4 Section 4.2', true),
('Fee Cap', 'fee_cap', 15.00, 'Maximum interest rate of 15% per annum', 'MLS4 Section 7.1', true)
ON CONFLICT DO NOTHING;

-- Insert sample system configuration
INSERT INTO public.system_configuration (config_key, config_value, config_type, description, category, is_sensitive) VALUES
('app_name', '"BuffrLend"', 'string', 'Application name', 'general', false),
('app_version', '"1.0.0"', 'string', 'Application version', 'general', false),
('max_loan_amount', '10000', 'number', 'Maximum loan amount in NAD', 'loans', false),
('min_loan_amount', '500', 'number', 'Minimum loan amount in NAD', 'loans', false),
('max_loan_term_months', '5', 'number', 'Maximum loan term in months', 'loans', false),
('base_interest_rate', '15.00', 'number', 'Base interest rate percentage', 'loans', false),
('namfisa_levy_percentage', '0.50', 'number', 'NAMFISA levy percentage', 'compliance', false),
('realpay_api_timeout', '30', 'number', 'RealPay API timeout in seconds', 'payments', false),
('kyc_verification_timeout', '24', 'number', 'KYC verification timeout in hours', 'kyc', false),
('email_notifications_enabled', 'true', 'boolean', 'Enable email notifications', 'notifications', false),
('sms_notifications_enabled', 'false', 'boolean', 'Enable SMS notifications', 'notifications', false),
('whatsapp_notifications_enabled', 'true', 'boolean', 'Enable WhatsApp notifications', 'notifications', false)
ON CONFLICT (config_key) DO NOTHING;

-- Insert sample NAMFISA compliance record
INSERT INTO public.namfisa_compliance (
    license_number,
    license_type,
    license_status,
    application_date,
    sandbox_phase,
    capital_requirement,
    current_capital,
    max_customers,
    max_transaction_amount,
    max_monthly_volume,
    compliance_officer_name,
    compliance_officer_email,
    compliance_officer_phone
) VALUES (
    'MLS4-2024-001',
    'fintech_sandbox',
    'approved',
    '2024-01-15',
    'phase_1',
    1000000.00,
    1000000.00,
    1000,
    50000.00,
    1000000.00,
    'John Compliance',
    'compliance@lend.buffr.ai',
    '+264 81 123 4567'
) ON CONFLICT (license_number) DO NOTHING;

-- Insert sample loan rates
INSERT INTO public.loan_rates (
    base_interest_rate,
    namfisa_levy,
    realpay_processing_fee,
    realpay_transaction_fee,
    realpay_monthly_fee,
    admin_fee,
    late_payment_fee,
    early_repayment_fee,
    insurance_fee,
    compliance_fee,
    bank_processing_fee,
    bank_monthly_fee,
    bank_transaction_fee,
    bank_setup_fee,
    max_dti_ratio,
    max_loan_amount,
    max_loan_term,
    min_monthly_income,
    namfisa_mls4_compliant,
    responsible_lending_enabled,
    transparency_requirements
) VALUES (
    5.90,
    0.50,
    50.00,
    2.50,
    25.00,
    100.00,
    5.00,
    2.00,
    75.00,
    50.00,
    150.00,
    30.00,
    1.50,
    200.00,
    33.33,
    150000.00,
    36,
    5000.00,
    true,
    true,
    true
) ON CONFLICT DO NOTHING;

-- Insert sample rates
INSERT INTO public.rates (rate_type, rate_name, rate_value, rate_unit, loan_product, min_amount, max_amount, min_term_months, max_term_months, risk_category, effective_date, is_active, description) VALUES
('base_interest', 'Standard Interest Rate', 15.00, 'percentage', 'all', 500, 10000, 1, 5, 'all', CURRENT_DATE, true, 'Standard interest rate for all loan products'),
('processing_fee', 'Loan Processing Fee', 100.00, 'fixed_amount', 'all', 500, 10000, 1, 5, 'all', CURRENT_DATE, true, 'Fixed processing fee for loan applications'),
('late_penalty', 'Late Payment Penalty', 5.00, 'fixed_amount', 'all', 500, 10000, 1, 5, 'all', CURRENT_DATE, true, 'Penalty fee for late payments'),
('promotional', 'New Customer Rate', 12.00, 'percentage', 'all', 500, 5000, 1, 3, 'low', CURRENT_DATE, true, 'Promotional rate for new customers'),
('risk_adjustment', 'High Risk Adjustment', 18.00, 'percentage', 'all', 500, 10000, 1, 5, 'high', CURRENT_DATE, true, 'Interest rate adjustment for high-risk borrowers')
ON CONFLICT DO NOTHING;

-- Insert sample RealPay configuration
INSERT INTO public.realpay_config (
    realpay_api_key,
    realpay_api_url,
    realpay_merchant_id,
    realpay_webhook_secret,
    realpay_timeout_seconds
) VALUES (
    'rp_test_key_123456789',
    'https://api.realpay.com/v1',
    'merchant_buffrlend_001',
    'webhook_secret_987654321',
    30
) ON CONFLICT DO NOTHING;

-- Create a function to generate sample partner companies
CREATE OR REPLACE FUNCTION create_sample_partner_companies()
RETURNS VOID AS $$
BEGIN
    INSERT INTO public.partner_companies (
        company_name,
        company_registration_number,
        industry_sector,
        company_size,
        primary_contact_name,
        primary_contact_email,
        primary_contact_phone,
        street_address,
        city,
        state_province,
        postal_code,
        partnership_status,
        partnership_tier,
        max_loan_amount,
        minimum_monthly_salary,
        total_employees,
        status,
        category,
        description,
        featured
    ) VALUES
    (
        'Namibia Breweries Limited',
        'REG-001-2024',
        'Manufacturing',
        'large',
        'Sarah Johnson',
        'sarah.johnson@nbl.com.na',
        '+264 61 123 4567',
        '123 Industrial Area',
        'Windhoek',
        'Khomas',
        '10001',
        'active',
        'enterprise',
        15000.00,
        5000.00,
        500,
        'active',
        'employer',
        'Leading beverage manufacturer in Namibia',
        true
    ),
    (
        'Bank of Namibia',
        'REG-002-2024',
        'Financial Services',
        'large',
        'Michael Brown',
        'michael.brown@bon.com.na',
        '+264 61 234 5678',
        '456 Independence Avenue',
        'Windhoek',
        'Khomas',
        '10002',
        'active',
        'enterprise',
        20000.00,
        8000.00,
        200,
        'active',
        'employer',
        'Central bank of Namibia',
        true
    ),
    (
        'Namibian Government',
        'REG-003-2024',
        'Public Sector',
        'large',
        'Anna Smith',
        'anna.smith@gov.na',
        '+264 61 345 6789',
        '789 Government Avenue',
        'Windhoek',
        'Khomas',
        '10003',
        'active',
        'enterprise',
        12000.00,
        4000.00,
        1000,
        'active',
        'employer',
        'Namibian government employees',
        true
    )
    ON CONFLICT (company_name) DO NOTHING;
END;
$$ LANGUAGE plpgsql;

-- Execute the function to create sample partner companies
SELECT create_sample_partner_companies();

-- Drop the temporary function
DROP FUNCTION create_sample_partner_companies();

-- Add comments for documentation
COMMENT ON TABLE public.fee_categories IS 'Sample fee categories for BuffrLend loan products';
COMMENT ON TABLE public.fee_configurations IS 'Sample fee configurations with default values';
COMMENT ON TABLE public.loan_terms IS 'Sample loan terms and conditions';
COMMENT ON TABLE public.responsible_lending_policies IS 'Sample responsible lending policies';
COMMENT ON TABLE public.system_configuration IS 'Sample system configuration values';
COMMENT ON TABLE public.namfisa_compliance IS 'Sample NAMFISA compliance record';
COMMENT ON TABLE public.loan_rates IS 'Sample loan rates and fees';
COMMENT ON TABLE public.rates IS 'Sample rate structures';
COMMENT ON TABLE public.realpay_config IS 'Sample RealPay configuration';
COMMENT ON TABLE public.partner_companies IS 'Sample partner companies for testing';
\n-- End of buffrlend-starter/supabase/migrations/09_sample_data.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/006_create_unified_ml_models.sql --\n
-- SendGrid Webhook Event Tracking
-- This migration creates tables for tracking SendGrid webhook events and email delivery status

-- SendGrid Webhook Events
CREATE TABLE IF NOT EXISTS sendgrid_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id TEXT NOT NULL UNIQUE, -- SendGrid event ID
    event_type TEXT NOT NULL,
    email TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    sg_message_id TEXT,
    sg_event_id TEXT,
    sg_template_id TEXT,
    sg_template_name TEXT,
    response TEXT,
    attempt INTEGER,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    reason TEXT,
    status TEXT,
    category TEXT[],
    unique_args JSONB,
    marketing_campaign_id TEXT,
    marketing_campaign_name TEXT,
    raw_data JSONB NOT NULL,
    processed_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Delivery Status Tracking
CREATE TABLE IF NOT EXISTS email_delivery_status (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_queue_id UUID REFERENCES email_queue(id),
    sendgrid_message_id TEXT,
    recipient_email TEXT NOT NULL,
    status TEXT NOT NULL CHECK (status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'dropped', 'spam', 'unsubscribed', 'processed', 'deferred', 'blocked')),
    event_type TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    reason TEXT,
    response TEXT,
    user_agent TEXT,
    ip_address INET,
    url TEXT,
    category TEXT[],
    unique_args JSONB,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Bounce Management
CREATE TABLE IF NOT EXISTS email_bounces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    bounce_type TEXT NOT NULL CHECK (bounce_type IN ('hard', 'soft', 'block', 'spam', 'invalid')),
    bounce_reason TEXT,
    bounce_code TEXT,
    bounce_description TEXT,
    first_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    last_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    bounce_count INTEGER DEFAULT 1,
    is_suppressed BOOLEAN DEFAULT false,
    suppression_reason TEXT,
    suppressed_at TIMESTAMP WITH TIME ZONE,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Suppression Lists
CREATE TABLE IF NOT EXISTS email_suppressions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    suppression_type TEXT NOT NULL CHECK (suppression_type IN ('bounce', 'block', 'spam', 'unsubscribe', 'group_unsubscribe', 'manual')),
    reason TEXT,
    source TEXT DEFAULT 'sendgrid',
    is_active BOOLEAN DEFAULT true,
    suppressed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    unsuppressed_at TIMESTAMP WITH TIME ZONE,
    unsuppressed_by UUID REFERENCES auth.users(id),
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Unsubscribe Tracking
CREATE TABLE IF NOT EXISTS email_unsubscribes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    unsubscribe_type TEXT NOT NULL CHECK (unsubscribe_type IN ('one_click', 'group', 'manual')),
    unsubscribe_source TEXT,
    user_id UUID REFERENCES auth.users(id),
    campaign_id TEXT,
    template_id TEXT,
    unsubscribed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_email ON sendgrid_webhook_events(email);
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_type ON sendgrid_webhook_events(event_type);
CREATE INDEX IF NOT EXISTS idx_sendgrid_webhook_events_timestamp ON sendgrid_webhook_events(timestamp);
CREATE INDEX IF NOT EXISTS idx_email_delivery_status_email ON email_delivery_status(recipient_email);
CREATE INDEX IF NOT EXISTS idx_email_delivery_status_status ON email_delivery_status(status);
CREATE INDEX IF NOT EXISTS idx_email_bounces_email ON email_bounces(email);
CREATE INDEX IF NOT EXISTS idx_email_bounces_type ON email_bounces(bounce_type);
CREATE INDEX IF NOT EXISTS idx_email_suppressions_email ON email_suppressions(email);
CREATE INDEX IF NOT EXISTS idx_email_suppressions_type ON email_suppressions(suppression_type);
CREATE INDEX IF NOT EXISTS idx_email_unsubscribes_email ON email_unsubscribes(email);

-- Triggers for updated_at
CREATE TRIGGER update_email_bounces_updated_at BEFORE UPDATE ON email_bounces FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_suppressions_updated_at BEFORE UPDATE ON email_suppressions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/19_sendgrid_webhooks.sql --\n
-- Email Analytics and Delivery Tracking
-- This migration creates tables for comprehensive email analytics and performance tracking

-- Email Analytics Summary
CREATE TABLE IF NOT EXISTS email_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    date DATE NOT NULL,
    metric_name TEXT NOT NULL,
    metric_value NUMERIC NOT NULL,
    metric_type TEXT NOT NULL CHECK (metric_type IN ('count', 'rate', 'percentage', 'duration', 'amount')),
    category TEXT NOT NULL,
    subcategory TEXT,
    dimensions JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Campaign Analytics
CREATE TABLE IF NOT EXISTS email_campaign_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id TEXT NOT NULL,
    campaign_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    emails_spam_reported INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Template Performance
CREATE TABLE IF NOT EXISTS email_template_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    template_name TEXT,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Domain Performance
CREATE TABLE IF NOT EXISTS email_domain_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email IP Performance
CREATE TABLE IF NOT EXISTS email_ip_analytics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL,
    date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_dropped INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Link Tracking
CREATE TABLE IF NOT EXISTS email_link_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    link_url TEXT NOT NULL,
    link_id TEXT NOT NULL,
    email_id TEXT,
    campaign_id TEXT,
    template_id TEXT,
    click_count INTEGER DEFAULT 0,
    unique_click_count INTEGER DEFAULT 0,
    first_clicked_at TIMESTAMP WITH TIME ZONE,
    last_clicked_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Open Tracking
CREATE TABLE IF NOT EXISTS email_open_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    opened_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Click Tracking
CREATE TABLE IF NOT EXISTS email_click_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email_id TEXT NOT NULL,
    recipient_email TEXT NOT NULL,
    link_url TEXT NOT NULL,
    clicked_at TIMESTAMP WITH TIME ZONE NOT NULL,
    user_agent TEXT,
    ip_address INET,
    location_data JSONB,
    device_type TEXT,
    browser_type TEXT,
    os_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_analytics_date ON email_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_analytics_metric ON email_analytics(metric_name);
CREATE INDEX IF NOT EXISTS idx_email_campaign_analytics_campaign ON email_campaign_analytics(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_campaign_analytics_date ON email_campaign_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_template_analytics_template ON email_template_analytics(template_id);
CREATE INDEX IF NOT EXISTS idx_email_template_analytics_date ON email_template_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_domain_analytics_domain ON email_domain_analytics(domain);
CREATE INDEX IF NOT EXISTS idx_email_domain_analytics_date ON email_domain_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_ip_analytics_ip ON email_ip_analytics(ip_address);
CREATE INDEX IF NOT EXISTS idx_email_ip_analytics_date ON email_ip_analytics(date);
CREATE INDEX IF NOT EXISTS idx_email_link_tracking_url ON email_link_tracking(link_url);
CREATE INDEX IF NOT EXISTS idx_email_open_tracking_email ON email_open_tracking(email_id);
CREATE INDEX IF NOT EXISTS idx_email_click_tracking_email ON email_click_tracking(email_id);

-- Triggers for updated_at
CREATE TRIGGER update_email_analytics_updated_at BEFORE UPDATE ON email_analytics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_campaign_analytics_updated_at BEFORE UPDATE ON email_campaign_analytics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_template_analytics_updated_at BEFORE UPDATE ON email_template_analytics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_domain_analytics_updated_at BEFORE UPDATE ON email_domain_analytics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_ip_analytics_updated_at BEFORE UPDATE ON email_ip_analytics FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_link_tracking_updated_at BEFORE UPDATE ON email_link_tracking FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/20_email_analytics.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/supabase/migrations/05_unified_ml_models.sql --\n
-- Adumo Integration Migration
-- Creates tables for Adumo credit scoring and risk assessment integration

-- Adumo Configuration Table
CREATE TABLE IF NOT EXISTS adumo_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_name VARCHAR(100) NOT NULL UNIQUE,
    api_endpoint VARCHAR(255) NOT NULL,
    api_key VARCHAR(255) NOT NULL,
    api_secret VARCHAR(255) NOT NULL,
    environment VARCHAR(20) NOT NULL DEFAULT 'sandbox' CHECK (environment IN ('sandbox', 'production')),
    webhook_url VARCHAR(255),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Adumo Credit Scores Table
CREATE TABLE IF NOT EXISTS adumo_credit_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID REFERENCES profiles(id) NOT NULL,
    loan_application_id UUID REFERENCES loan_applications(id),
    adumo_reference VARCHAR(100) NOT NULL UNIQUE,
    credit_score INTEGER NOT NULL CHECK (credit_score >= 0 AND credit_score <= 1000),
    risk_category VARCHAR(20) NOT NULL CHECK (risk_category IN ('low', 'medium', 'high', 'very_high')),
    score_breakdown JSONB,
    factors JSONB,
    recommendations JSONB,
    valid_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Adumo Risk Assessments Table
CREATE TABLE IF NOT EXISTS adumo_risk_assessments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID REFERENCES profiles(id) NOT NULL,
    loan_application_id UUID REFERENCES loan_applications(id),
    assessment_type VARCHAR(50) NOT NULL,
    risk_score DECIMAL(5,2) NOT NULL CHECK (risk_score >= 0 AND risk_score <= 100),
    risk_level VARCHAR(20) NOT NULL CHECK (risk_level IN ('low', 'medium', 'high', 'very_high')),
    assessment_data JSONB,
    risk_factors JSONB,
    mitigation_recommendations JSONB,
    assessment_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Adumo API Logs Table
CREATE TABLE IF NOT EXISTS adumo_api_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    request_id VARCHAR(100) NOT NULL,
    endpoint VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    request_data JSONB,
    response_data JSONB,
    status_code INTEGER,
    response_time_ms INTEGER,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Adumo Webhook Events Table
CREATE TABLE IF NOT EXISTS adumo_webhook_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(50) NOT NULL,
    event_id VARCHAR(100) NOT NULL UNIQUE,
    customer_id UUID REFERENCES profiles(id),
    loan_application_id UUID REFERENCES loan_applications(id),
    event_data JSONB,
    processed BOOLEAN DEFAULT false,
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for Adumo tables
CREATE INDEX IF NOT EXISTS idx_adumo_config_active ON adumo_config(is_active);
CREATE INDEX IF NOT EXISTS idx_adumo_credit_scores_customer ON adumo_credit_scores(customer_id);
CREATE INDEX IF NOT EXISTS idx_adumo_credit_scores_loan ON adumo_credit_scores(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_adumo_credit_scores_valid ON adumo_credit_scores(valid_until);
CREATE INDEX IF NOT EXISTS idx_adumo_risk_customer ON adumo_risk_assessments(customer_id);
CREATE INDEX IF NOT EXISTS idx_adumo_risk_loan ON adumo_risk_assessments(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_adumo_risk_expires ON adumo_risk_assessments(expires_at);
CREATE INDEX IF NOT EXISTS idx_adumo_logs_request ON adumo_api_logs(request_id);
CREATE INDEX IF NOT EXISTS idx_adumo_logs_created ON adumo_api_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_adumo_webhook_processed ON adumo_webhook_events(processed);
CREATE INDEX IF NOT EXISTS idx_adumo_webhook_customer ON adumo_webhook_events(customer_id);

-- Adumo Functions
CREATE OR REPLACE FUNCTION request_adumo_credit_score(
    p_customer_id UUID,
    p_loan_application_id UUID DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
    v_score_id UUID;
    v_adumo_reference VARCHAR;
    v_customer_data JSONB;
BEGIN
    -- Generate Adumo reference
    v_adumo_reference := 'ADU' || EXTRACT(EPOCH FROM NOW())::BIGINT;
    
    -- Get customer data for scoring
    SELECT jsonb_build_object(
        'customer_id', p_customer_id,
        'loan_amount', CASE WHEN p_loan_application_id IS NOT NULL THEN 
            (SELECT amount FROM loan_applications WHERE id = p_loan_application_id) 
        ELSE NULL END,
        'request_timestamp', NOW()
    ) INTO v_customer_data;
    
    -- Insert credit score request
    INSERT INTO adumo_credit_scores (
        customer_id,
        loan_application_id,
        adumo_reference,
        credit_score,
        risk_category,
        score_breakdown,
        valid_until
    ) VALUES (
        p_customer_id,
        p_loan_application_id,
        v_adumo_reference,
        0, -- Will be updated when response received
        'high', -- Default high risk until score received
        v_customer_data,
        NOW() + INTERVAL '90 days'
    ) RETURNING id INTO v_score_id;
    
    -- Log API request
    INSERT INTO adumo_api_logs (
        request_id,
        endpoint,
        method,
        request_data,
        created_by
    ) VALUES (
        v_adumo_reference,
        '/api/v1/credit-score',
        'POST',
        v_customer_data,
        auth.uid()
    );
    
    RETURN v_score_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Adumo Risk Assessment Function
CREATE OR REPLACE FUNCTION perform_adumo_risk_assessment(
    p_customer_id UUID,
    p_loan_application_id UUID,
    p_assessment_type VARCHAR DEFAULT 'loan_approval'
) RETURNS UUID AS $$
DECLARE
    v_assessment_id UUID;
    v_risk_score DECIMAL;
    v_risk_level VARCHAR;
    v_assessment_data JSONB;
BEGIN
    -- Get customer and loan data for assessment
    SELECT jsonb_build_object(
        'customer_id', p_customer_id,
        'loan_application_id', p_loan_application_id,
        'assessment_type', p_assessment_type,
        'loan_amount', (SELECT amount FROM loan_applications WHERE id = p_loan_application_id),
        'customer_income', (SELECT monthly_income FROM profiles WHERE id = p_customer_id),
        'assessment_timestamp', NOW()
    ) INTO v_assessment_data;
    
    -- Calculate risk score (simplified logic)
    SELECT 
        CASE 
            WHEN (SELECT monthly_income FROM profiles WHERE id = p_customer_id) > 10000 THEN 20
            WHEN (SELECT monthly_income FROM profiles WHERE id = p_customer_id) > 5000 THEN 40
            ELSE 70
        END INTO v_risk_score;
    
    -- Determine risk level
    v_risk_level := CASE 
        WHEN v_risk_score <= 30 THEN 'low'
        WHEN v_risk_score <= 60 THEN 'medium'
        WHEN v_risk_score <= 80 THEN 'high'
        ELSE 'very_high'
    END;
    
    -- Insert risk assessment
    INSERT INTO adumo_risk_assessments (
        customer_id,
        loan_application_id,
        assessment_type,
        risk_score,
        risk_level,
        assessment_data,
        expires_at
    ) VALUES (
        p_customer_id,
        p_loan_application_id,
        p_assessment_type,
        v_risk_score,
        v_risk_level,
        v_assessment_data,
        NOW() + INTERVAL '30 days'
    ) RETURNING id INTO v_assessment_id;
    
    RETURN v_assessment_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Adumo Webhook Processing Function
CREATE OR REPLACE FUNCTION process_adumo_webhook(
    p_event_type VARCHAR,
    p_event_id VARCHAR,
    p_customer_id UUID DEFAULT NULL,
    p_loan_application_id UUID DEFAULT NULL,
    p_event_data JSONB DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
    v_webhook_id UUID;
BEGIN
    -- Insert webhook event
    INSERT INTO adumo_webhook_events (
        event_type,
        event_id,
        customer_id,
        loan_application_id,
        event_data
    ) VALUES (
        p_event_type,
        p_event_id,
        p_customer_id,
        p_loan_application_id,
        p_event_data
    ) RETURNING id INTO v_webhook_id;
    
    -- Process based on event type
    CASE p_event_type
        WHEN 'credit_score_updated' THEN
            UPDATE adumo_credit_scores 
            SET 
                credit_score = (p_event_data->>'credit_score')::INTEGER,
                risk_category = p_event_data->>'risk_category',
                score_breakdown = p_event_data->'score_breakdown',
                factors = p_event_data->'factors',
                recommendations = p_event_data->'recommendations',
                updated_at = NOW()
            WHERE adumo_reference = p_event_data->>'adumo_reference';
            
        WHEN 'risk_assessment_completed' THEN
            UPDATE adumo_risk_assessments 
            SET 
                risk_score = (p_event_data->>'risk_score')::DECIMAL,
                risk_level = p_event_data->>'risk_level',
                risk_factors = p_event_data->'risk_factors',
                mitigation_recommendations = p_event_data->'mitigation_recommendations',
                updated_at = NOW()
            WHERE id = (p_event_data->>'assessment_id')::UUID;
    END CASE;
    
    -- Mark webhook as processed
    UPDATE adumo_webhook_events 
    SET processed = true, processed_at = NOW()
    WHERE id = v_webhook_id;
    
    RETURN true;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Adumo Analytics Function
CREATE OR REPLACE FUNCTION get_adumo_analytics(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
) RETURNS TABLE (
    total_scores BIGINT,
    average_score DECIMAL,
    low_risk_count BIGINT,
    medium_risk_count BIGINT,
    high_risk_count BIGINT,
    very_high_risk_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_scores,
        ROUND(AVG(credit_score), 2) as average_score,
        COUNT(CASE WHEN risk_category = 'low' THEN 1 END) as low_risk_count,
        COUNT(CASE WHEN risk_category = 'medium' THEN 1 END) as medium_risk_count,
        COUNT(CASE WHEN risk_category = 'high' THEN 1 END) as high_risk_count,
        COUNT(CASE WHEN risk_category = 'very_high' THEN 1 END) as very_high_risk_count
    FROM adumo_credit_scores
    WHERE 
        (p_start_date IS NULL OR created_at >= p_start_date)
        AND (p_end_date IS NULL OR created_at <= p_end_date);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Triggers for Adumo tables
CREATE TRIGGER update_adumo_config_updated_at
    BEFORE UPDATE ON adumo_config
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_credit_scores_updated_at
    BEFORE UPDATE ON adumo_credit_scores
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_risk_assessments_updated_at
    BEFORE UPDATE ON adumo_risk_assessments
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Sample Adumo configuration
INSERT INTO adumo_config (
    config_name,
    api_endpoint,
    api_key,
    api_secret,
    environment,
    webhook_url,
    is_active
) VALUES (
    'BuffrLend Adumo Integration',
    'https://api.adumo.com/v1',
    'your-api-key-here',
    'your-api-secret-here',
    'sandbox',
    'https://lend.buffr.ai/api/webhooks/adumo',
    true
) ON CONFLICT (config_name) DO NOTHING;
\n-- End of buffrlend-starter/supabase/migrations/28_adumo_integration.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/supabase/migrations/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/supabase/migrations/04_unified_rate_limiting.sql --\n
-- =====================================================
-- BuffrLend Core RLS Policies Migration
-- =====================================================
-- Description: Creates Row Level Security policies for core tables
-- Dependencies: 02_core_tables.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Enable RLS on core tables

ALTER TABLE public.partner_companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.loan_applications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.system_configuration ENABLE ROW LEVEL SECURITY;



-- =====================================================
-- PARTNER_COMPANIES TABLE RLS POLICIES
-- =====================================================

-- Public can view active partner companies (for company lookup)
CREATE POLICY "Public can view active partner companies" ON public.partner_companies
    FOR SELECT USING (partnership_status = 'active');

-- Admins can view all partner companies
CREATE POLICY "Admins can view all partner companies" ON public.partner_companies
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- Admins can insert partner companies
CREATE POLICY "Admins can insert partner companies" ON public.partner_companies
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- Admins can update partner companies
CREATE POLICY "Admins can update partner companies" ON public.partner_companies
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- =====================================================
-- LOAN_APPLICATIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own loan applications
CREATE POLICY "Users can view own loan applications" ON public.loan_applications
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own loan applications
CREATE POLICY "Users can insert own loan applications" ON public.loan_applications
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own loan applications (limited fields)
CREATE POLICY "Users can update own loan applications" ON public.loan_applications
    FOR UPDATE USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Admins can view all loan applications
CREATE POLICY "Admins can view all loan applications" ON public.loan_applications
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- Admins can update all loan applications
CREATE POLICY "Admins can update all loan applications" ON public.loan_applications
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- Company managers can view applications for their company
CREATE POLICY "Company managers can view company applications" ON public.loan_applications
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            JOIN public.partner_companies pc ON pc.id = company_id
            WHERE up.id = auth.uid()
            AND up.user_role = 'enterprise_user'::user_role_enum -- Assuming company manager is an enterprise user
        )
    );



-- =====================================================
-- SYSTEM_CONFIGURATION TABLE RLS POLICIES
-- =====================================================

-- Admins can view system configuration
CREATE POLICY "Admins can view system configuration" ON public.system_configuration
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum
        )
    );

-- Super admins can insert system configuration
CREATE POLICY "Super admins can insert system configuration" ON public.system_configuration
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum -- Assuming 'super_admin' is part of 'admin' role or a separate check
        )
    );

-- Super admins can update system configuration
CREATE POLICY "Super admins can update system configuration" ON public.system_configuration
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role = 'admin'::user_role_enum -- Assuming 'super_admin' is part of 'admin' role or a separate check
        )
    );


\n-- End of buffrlend-starter/supabase/migrations/05_core_rls_policies.sql --\n
-- =====================================================
-- BuffrLend Validation Constraints and Business Rules
-- =====================================================
-- Description: Database-level validation constraints and business rules
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- VALIDATION FUNCTIONS
-- =====================================================

-- Function to validate Namibian phone numbers
CREATE OR REPLACE FUNCTION public.validate_namibian_phone(phone_number TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- Namibian phone numbers: +264 followed by 9 digits
    RETURN phone_number ~ '^\+264[0-9]{9}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate Namibian ID numbers
CREATE OR REPLACE FUNCTION public.validate_namibian_id(id_number TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    -- Namibian ID numbers: 11 digits
    RETURN id_number ~ '^[0-9]{11}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate email addresses
CREATE OR REPLACE FUNCTION public.validate_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate loan amounts
CREATE OR REPLACE FUNCTION public.validate_loan_amount(amount DECIMAL)
RETURNS BOOLEAN AS $$
BEGIN
    -- Loan amount must be between N$500 and N$10,000
    RETURN amount >= 500 AND amount <= 10000;
END;
$$ LANGUAGE plpgsql;

-- Function to validate loan terms
CREATE OR REPLACE FUNCTION public.validate_loan_term(term_months INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    -- Loan term must be between 1 and 5 months
    RETURN term_months >= 1 AND term_months <= 5;
END;
$$ LANGUAGE plpgsql;

-- Function to validate DTI ratio
CREATE OR REPLACE FUNCTION public.validate_dti_ratio(income DECIMAL, expenses DECIMAL, loan_payment DECIMAL)
RETURNS BOOLEAN AS $$
DECLARE
    dti_ratio DECIMAL;
BEGIN
    IF income <= 0 THEN
        RETURN FALSE;
    END IF;
    
    dti_ratio := (expenses + loan_payment) / income * 100;
    RETURN dti_ratio <= 33.33;
END;
$$ LANGUAGE plpgsql;

-- Function to validate age (must be 18+)
CREATE OR REPLACE FUNCTION public.validate_age(birth_date DATE)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXTRACT(YEAR FROM AGE(birth_date)) >= 18;
END;
$$ LANGUAGE plpgsql;

-- Function to validate employment tenure
CREATE OR REPLACE FUNCTION public.validate_employment_tenure(employment_start_date DATE)
RETURNS BOOLEAN AS $$
BEGIN
    -- Must be employed for at least 3 months
    RETURN employment_start_date <= CURRENT_DATE - INTERVAL '3 months';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- CHECK CONSTRAINTS
-- =====================================================

-- Profiles table constraints
ALTER TABLE public.profiles ADD CONSTRAINT check_phone_number_format 
    CHECK (phone_number IS NULL OR public.validate_namibian_phone(phone_number));

ALTER TABLE public.profiles ADD CONSTRAINT check_id_number_format 
    CHECK (id_number IS NULL OR public.validate_namibian_id(id_number));

ALTER TABLE public.profiles ADD CONSTRAINT check_email_format 
    CHECK (email IS NULL OR public.validate_email(email));

ALTER TABLE public.profiles ADD CONSTRAINT check_age_requirement 
    CHECK (date_of_birth IS NULL OR public.validate_age(date_of_birth));

ALTER TABLE public.profiles ADD CONSTRAINT check_monthly_income_positive 
    CHECK (monthly_income IS NULL OR monthly_income >= 0);

ALTER TABLE public.profiles ADD CONSTRAINT check_monthly_expenses_positive 
    CHECK (monthly_expenses IS NULL OR monthly_expenses >= 0);

-- Loan applications constraints
ALTER TABLE public.loan_applications ADD CONSTRAINT check_loan_amount_range 
    CHECK (public.validate_loan_amount(loan_amount));

ALTER TABLE public.loan_applications ADD CONSTRAINT check_loan_term_range 
    CHECK (public.validate_loan_term(loan_term_months));

ALTER TABLE public.loan_applications ADD CONSTRAINT check_loan_amount_positive 
    CHECK (loan_amount > 0);

ALTER TABLE public.loan_applications ADD CONSTRAINT check_loan_term_positive 
    CHECK (loan_term_months > 0);

-- KYC verifications constraints
ALTER TABLE public.kyc_verifications ADD CONSTRAINT check_verification_dates 
    CHECK (verified_at IS NULL OR verified_at >= created_at);

ALTER TABLE public.kyc_verifications ADD CONSTRAINT check_expiry_dates 
    CHECK (expires_at IS NULL OR expires_at > created_at);

-- Employee verifications constraints
ALTER TABLE public.employee_verifications ADD CONSTRAINT check_employment_start_date 
    CHECK (employment_start_date IS NULL OR public.validate_employment_tenure(employment_start_date));

ALTER TABLE public.employee_verifications ADD CONSTRAINT check_salary_positive 
    CHECK (monthly_salary IS NULL OR monthly_salary > 0);

-- RealPay transactions constraints
ALTER TABLE public.realpay_transactions ADD CONSTRAINT check_transaction_amount_positive 
    CHECK (amount > 0);

ALTER TABLE public.realpay_transactions ADD CONSTRAINT check_transaction_dates 
    CHECK (created_at <= updated_at);

-- Rates constraints
ALTER TABLE public.rates ADD CONSTRAINT check_rate_value_positive 
    CHECK (rate_value > 0);

ALTER TABLE public.rates ADD CONSTRAINT check_effective_date_future 
    CHECK (effective_date >= CURRENT_DATE);

-- Loan terms constraints
ALTER TABLE public.loan_terms ADD CONSTRAINT check_term_value_positive 
    CHECK (term_value IS NULL OR (term_value->>'value')::DECIMAL > 0);

-- Collection schedules constraints
ALTER TABLE public.collection_schedules ADD CONSTRAINT check_due_amount_positive 
    CHECK (due_amount > 0);

ALTER TABLE public.collection_schedules ADD CONSTRAINT check_due_date_future 
    CHECK (due_date >= CURRENT_DATE);

-- Financial reports constraints
ALTER TABLE public.financial_reports ADD CONSTRAINT check_period_dates 
    CHECK (period_start <= period_end);

ALTER TABLE public.financial_reports ADD CONSTRAINT check_report_amounts_positive 
    CHECK (total_loans >= 0 AND total_collections >= 0 AND total_interest >= 0);

-- Collection transactions constraints
ALTER TABLE public.collection_transactions ADD CONSTRAINT check_transaction_amount_positive 
    CHECK (amount > 0);

-- Employer reconciliations constraints
ALTER TABLE public.employer_reconciliations ADD CONSTRAINT check_reconciliation_amounts_positive 
    CHECK (total_employees >= 0 AND total_amount >= 0);

-- NAMFISA reports constraints
ALTER TABLE public.namfisa_reports ADD CONSTRAINT check_submission_date_future 
    CHECK (submission_date >= CURRENT_DATE);

-- Loan rates constraints
ALTER TABLE public.loan_rates ADD CONSTRAINT check_rates_positive 
    CHECK (base_interest_rate >= 0 AND namfisa_levy >= 0 AND realpay_processing_fee >= 0);

ALTER TABLE public.loan_rates ADD CONSTRAINT check_loan_limits_positive 
    CHECK (max_loan_amount > 0 AND max_loan_term > 0 AND min_monthly_income > 0);

-- Responsible lending policies constraints
ALTER TABLE public.responsible_lending_policies ADD CONSTRAINT check_policy_value_positive 
    CHECK (policy_value > 0);

-- Affordability calculations constraints
ALTER TABLE public.affordability_calculations ADD CONSTRAINT check_affordability_amounts_positive 
    CHECK (monthly_income >= 0 AND monthly_expenses >= 0 AND loan_payment >= 0);

-- Fee configurations constraints
ALTER TABLE public.fee_configurations ADD CONSTRAINT check_config_value_positive 
    CHECK (config_value > 0);

-- User fee breakdown constraints
ALTER TABLE public.user_fee_breakdown ADD CONSTRAINT check_fee_amounts_positive 
    CHECK (amount >= 0);

-- Loan agreements constraints
ALTER TABLE public.loan_agreements ADD CONSTRAINT check_agreement_dates 
    CHECK (created_at <= updated_at);

-- =====================================================
-- BUSINESS RULE CONSTRAINTS
-- =====================================================

-- Constraint: Users must have completed KYC before applying for loans
CREATE OR REPLACE FUNCTION public.check_kyc_completion()
RETURNS TRIGGER AS $$
DECLARE
    kyc_status TEXT;
BEGIN
    SELECT status INTO kyc_status 
    FROM public.kyc_verifications 
    WHERE user_id = NEW.user_id 
    ORDER BY created_at DESC 
    LIMIT 1;
    
    IF kyc_status IS NULL OR kyc_status != 'verified' THEN
        RAISE EXCEPTION 'KYC verification must be completed before applying for loans';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_kyc_completion
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.check_kyc_completion();

-- Constraint: Users must have employment verification for loans
CREATE OR REPLACE FUNCTION public.check_employment_verification()
RETURNS TRIGGER AS $$
DECLARE
    employment_status TEXT;
BEGIN
    SELECT status INTO employment_status 
    FROM public.employee_verifications 
    WHERE user_id = NEW.user_id 
    ORDER BY created_at DESC 
    LIMIT 1;
    
    IF employment_status IS NULL OR employment_status != 'verified' THEN
        RAISE EXCEPTION 'Employment verification must be completed before applying for loans';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_employment_verification
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.check_employment_verification();

-- Constraint: Users cannot have multiple active loans
CREATE OR REPLACE FUNCTION public.check_active_loans()
RETURNS TRIGGER AS $$
DECLARE
    active_loans_count INTEGER;
BEGIN
    SELECT COUNT(*) INTO active_loans_count
    FROM public.loan_applications 
    WHERE user_id = NEW.user_id 
    AND status IN ('active', 'approved');
    
    IF active_loans_count > 0 THEN
        RAISE EXCEPTION 'User cannot have multiple active loans';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_active_loans
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.check_active_loans();

-- Constraint: Loan amount must not exceed user's affordability
CREATE OR REPLACE FUNCTION public.check_loan_affordability()
RETURNS TRIGGER AS $$
DECLARE
    affordability_result JSONB;
BEGIN
    affordability_result := public.calculate_loan_affordability(
        NEW.user_id, 
        NEW.loan_amount, 
        NEW.loan_term_months
    );
    
    IF NOT (affordability_result->>'affordable')::BOOLEAN THEN
        RAISE EXCEPTION 'Loan amount exceeds affordability limit: %', 
            affordability_result->>'max_affordable_loan';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_loan_affordability
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.check_loan_affordability();

-- Constraint: Users must meet minimum income requirement
CREATE OR REPLACE FUNCTION public.check_minimum_income()
RETURNS TRIGGER AS $$
DECLARE
    user_income DECIMAL;
BEGIN
    SELECT monthly_income INTO user_income 
    FROM public.profiles 
    WHERE user_id = NEW.user_id;
    
    IF user_income IS NULL OR user_income < 3000 THEN
        RAISE EXCEPTION 'Minimum monthly income requirement not met (N$3,000)';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_check_minimum_income
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.check_minimum_income();

-- =====================================================
-- DATA INTEGRITY CONSTRAINTS
-- =====================================================

-- Constraint: Ensure unique phone numbers
ALTER TABLE public.profiles ADD CONSTRAINT unique_phone_number 
    UNIQUE (phone_number) WHERE phone_number IS NOT NULL;

-- Constraint: Ensure unique ID numbers
ALTER TABLE public.profiles ADD CONSTRAINT unique_id_number 
    UNIQUE (id_number) WHERE id_number IS NOT NULL;

-- Constraint: Ensure unique email addresses
ALTER TABLE public.profiles ADD CONSTRAINT unique_email 
    UNIQUE (email) WHERE email IS NOT NULL;

-- Constraint: Ensure unique company registration numbers
ALTER TABLE public.companies ADD CONSTRAINT unique_registration_number 
    UNIQUE (registration_number);

-- Constraint: Ensure unique partner company registration numbers
ALTER TABLE public.partner_companies ADD CONSTRAINT unique_partner_registration_number 
    UNIQUE (company_registration_number);

-- Constraint: Ensure unique RealPay transaction IDs
ALTER TABLE public.realpay_transactions ADD CONSTRAINT unique_transaction_id 
    UNIQUE (transaction_id);

-- Constraint: Ensure unique loan agreement numbers
ALTER TABLE public.loan_agreements ADD CONSTRAINT unique_agreement_number 
    UNIQUE (agreement_number);

-- =====================================================
-- REFERENTIAL INTEGRITY CONSTRAINTS
-- =====================================================

-- Constraint: Ensure user exists before creating profile
ALTER TABLE public.profiles ADD CONSTRAINT fk_profiles_user_id 
    FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Constraint: Ensure user exists before creating loan application
ALTER TABLE public.loan_applications ADD CONSTRAINT fk_loan_applications_user_id 
    FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Constraint: Ensure user exists before creating KYC verification
ALTER TABLE public.kyc_verifications ADD CONSTRAINT fk_kyc_verifications_user_id 
    FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Constraint: Ensure company exists before creating employee verification
ALTER TABLE public.employee_verifications ADD CONSTRAINT fk_employee_verifications_company_id 
    FOREIGN KEY (company_id) REFERENCES public.companies(id) ON DELETE CASCADE;

-- Constraint: Ensure loan application exists before creating loan agreement
ALTER TABLE public.loan_agreements ADD CONSTRAINT fk_loan_agreements_loan_application_id 
    FOREIGN KEY (loan_application_id) REFERENCES public.loan_applications(id) ON DELETE CASCADE;

-- =====================================================
-- AUDIT CONSTRAINTS
-- =====================================================

-- Constraint: Ensure audit logs have valid timestamps
ALTER TABLE public.audit_logs ADD CONSTRAINT check_audit_timestamps 
    CHECK (created_at <= CURRENT_TIMESTAMP);

-- Constraint: Ensure audit logs have valid actions
ALTER TABLE public.audit_logs ADD CONSTRAINT check_audit_actions 
    CHECK (action IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT', 'LOGIN', 'LOGOUT', 'APPROVE', 'REJECT', 'EXPORT', 'IMPORT'));

-- Constraint: Ensure audit logs have valid table names
ALTER TABLE public.audit_logs ADD CONSTRAINT check_audit_table_names 
    CHECK (table_name IN ('profiles', 'loan_applications', 'kyc_verifications', 'employee_verifications', 'realpay_transactions', 'rates', 'loan_terms', 'collection_schedules', 'financial_reports', 'collection_transactions', 'employer_reconciliations', 'namfisa_reports', 'loan_rates', 'responsible_lending_policies', 'affordability_calculations', 'realpay_config', 'fee_configurations', 'fee_categories', 'user_fee_breakdown', 'loan_agreements'));

-- =====================================================
-- PERFORMANCE CONSTRAINTS
-- =====================================================

-- Constraint: Limit audit log retention (keep only last 2 years)
CREATE OR REPLACE FUNCTION public.cleanup_old_audit_logs()
RETURNS VOID AS $$
BEGIN
    DELETE FROM public.audit_logs 
    WHERE created_at < CURRENT_DATE - INTERVAL '2 years';
END;
$$ LANGUAGE plpgsql;

-- Constraint: Limit user activity log retention (keep only last 1 year)
CREATE OR REPLACE FUNCTION public.cleanup_old_user_activity_logs()
RETURNS VOID AS $$
BEGIN
    DELETE FROM public.user_activity_logs 
    WHERE created_at < CURRENT_DATE - INTERVAL '1 year';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON FUNCTION public.validate_namibian_phone(TEXT) IS 'Validates Namibian phone number format (+264XXXXXXXXX)';
COMMENT ON FUNCTION public.validate_namibian_id(TEXT) IS 'Validates Namibian ID number format (11 digits)';
COMMENT ON FUNCTION public.validate_email(TEXT) IS 'Validates email address format';
COMMENT ON FUNCTION public.validate_loan_amount(DECIMAL) IS 'Validates loan amount is within allowed range (N$500-N$10,000)';
COMMENT ON FUNCTION public.validate_loan_term(INTEGER) IS 'Validates loan term is within allowed range (1-5 months)';
COMMENT ON FUNCTION public.validate_dti_ratio(DECIMAL, DECIMAL, DECIMAL) IS 'Validates debt-to-income ratio is within allowed limit (33.33%)';
COMMENT ON FUNCTION public.validate_age(DATE) IS 'Validates user age is 18 or older';
COMMENT ON FUNCTION public.validate_employment_tenure(DATE) IS 'Validates employment tenure is at least 3 months';
COMMENT ON FUNCTION public.check_kyc_completion() IS 'Ensures KYC verification is completed before loan applications';
COMMENT ON FUNCTION public.check_employment_verification() IS 'Ensures employment verification is completed before loan applications';
COMMENT ON FUNCTION public.check_active_loans() IS 'Prevents users from having multiple active loans';
COMMENT ON FUNCTION public.check_loan_affordability() IS 'Ensures loan amount is within user affordability limits';
COMMENT ON FUNCTION public.check_minimum_income() IS 'Ensures user meets minimum income requirement (N$3,000)';
COMMENT ON FUNCTION public.cleanup_old_audit_logs() IS 'Cleans up audit logs older than 2 years';
COMMENT ON FUNCTION public.cleanup_old_user_activity_logs() IS 'Cleans up user activity logs older than 1 year';
\n-- End of buffrlend-starter/supabase/migrations/14_validation_constraints.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/supabase/migrations/12_unified_functions_and_triggers.sql --\n
-- =====================================================
-- BuffrLend Database Functions and Triggers
-- =====================================================
-- Description: Database functions, triggers, and stored procedures
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- UTILITY FUNCTIONS
-- =====================================================

-- Function to update updated_at column
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function to generate audit log entry
CREATE OR REPLACE FUNCTION public.create_audit_log(
    p_user_id TEXT,
    p_admin_user_id TEXT,
    p_action TEXT,
    p_table_name TEXT,
    p_record_id TEXT,
    p_old_values JSONB,
    p_new_values JSONB,
    p_ip_address INET,
    p_user_agent TEXT
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO public.audit_logs (
        user_id,
        admin_user_id,
        action,
        table_name,
        record_id,
        old_values,
        new_values,
        ip_address,
        user_agent,
        created_at
    ) VALUES (
        p_user_id,
        p_admin_user_id,
        p_action,
        p_table_name,
        p_record_id,
        p_old_values,
        p_new_values,
        p_ip_address,
        p_user_agent,
        CURRENT_TIMESTAMP
    );
END;
$$ LANGUAGE plpgsql;

-- Function to check user permissions
CREATE OR REPLACE FUNCTION public.check_user_permission(
    p_user_id TEXT,
    p_permission_name TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    has_permission BOOLEAN := FALSE;
BEGIN
    SELECT EXISTS (
        SELECT 1
        FROM public.user_role_assignments ura
        JOIN public.role_permissions rp ON ura.role_id = rp.role_id
        JOIN public.permissions p ON rp.permission_id = p.id
        WHERE ura.user_id = p_user_id
        AND p.permission_name = p_permission_name
        AND ura.is_active = TRUE
        AND rp.is_active = TRUE
        AND p.is_active = TRUE
    ) INTO has_permission;
    
    RETURN has_permission;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate loan affordability
CREATE OR REPLACE FUNCTION public.calculate_loan_affordability(
    p_user_id TEXT,
    p_loan_amount DECIMAL,
    p_loan_term_months INTEGER
)
RETURNS JSONB AS $$
DECLARE
    user_profile RECORD;
    monthly_income DECIMAL;
    monthly_expenses DECIMAL;
    monthly_loan_payment DECIMAL;
    dti_ratio DECIMAL;
    affordability_score INTEGER;
    is_affordable BOOLEAN;
    result JSONB;
BEGIN
    -- Get user profile
    SELECT * INTO user_profile FROM public.profiles WHERE user_id = p_user_id;
    
    IF user_profile IS NULL THEN
        RETURN jsonb_build_object(
            'error', 'User not found',
            'affordable', FALSE
        );
    END IF;
    
    -- Calculate monthly income and expenses
    monthly_income := COALESCE(user_profile.monthly_income, 0);
    monthly_expenses := COALESCE(user_profile.monthly_expenses, 0);
    
    -- Calculate monthly loan payment (simple interest)
    monthly_loan_payment := p_loan_amount / p_loan_term_months;
    
    -- Calculate DTI ratio
    dti_ratio := (monthly_expenses + monthly_loan_payment) / monthly_income * 100;
    
    -- Determine affordability
    is_affordable := dti_ratio <= 33.33 AND monthly_income >= 3000;
    
    -- Calculate affordability score (0-100)
    affordability_score := CASE
        WHEN dti_ratio <= 20 THEN 100
        WHEN dti_ratio <= 30 THEN 80
        WHEN dti_ratio <= 40 THEN 60
        WHEN dti_ratio <= 50 THEN 40
        ELSE 20
    END;
    
    -- Build result
    result := jsonb_build_object(
        'affordable', is_affordable,
        'affordability_score', affordability_score,
        'dti_ratio', dti_ratio,
        'monthly_income', monthly_income,
        'monthly_expenses', monthly_expenses,
        'monthly_loan_payment', monthly_loan_payment,
        'max_affordable_loan', CASE
            WHEN monthly_income > 0 THEN (monthly_income * 0.33 - monthly_expenses) * p_loan_term_months
            ELSE 0
        END
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to validate KYC status
CREATE OR REPLACE FUNCTION public.validate_kyc_status(p_user_id TEXT)
RETURNS JSONB AS $$
DECLARE
    kyc_record RECORD;
    result JSONB;
BEGIN
    SELECT * INTO kyc_record FROM public.kyc_verifications 
    WHERE user_id = p_user_id 
    ORDER BY created_at DESC 
    LIMIT 1;
    
    IF kyc_record IS NULL THEN
        RETURN jsonb_build_object(
            'kyc_status', 'not_started',
            'is_verified', FALSE,
            'verification_level', 0
        );
    END IF;
    
    result := jsonb_build_object(
        'kyc_status', kyc_record.status,
        'is_verified', kyc_record.status = 'verified',
        'verification_level', CASE kyc_record.status
            WHEN 'verified' THEN 3
            WHEN 'pending' THEN 2
            WHEN 'in_progress' THEN 1
            ELSE 0
        END,
        'verified_at', kyc_record.verified_at,
        'expires_at', kyc_record.expires_at
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to calculate loan interest
CREATE OR REPLACE FUNCTION public.calculate_loan_interest(
    p_loan_amount DECIMAL,
    p_interest_rate DECIMAL,
    p_loan_term_months INTEGER
)
RETURNS JSONB AS $$
DECLARE
    monthly_rate DECIMAL;
    total_interest DECIMAL;
    monthly_payment DECIMAL;
    total_payment DECIMAL;
    result JSONB;
BEGIN
    -- Convert annual rate to monthly rate
    monthly_rate := p_interest_rate / 100 / 12;
    
    -- Calculate monthly payment using PMT formula
    monthly_payment := p_loan_amount * (monthly_rate * POWER(1 + monthly_rate, p_loan_term_months)) / 
                      (POWER(1 + monthly_rate, p_loan_term_months) - 1);
    
    -- Calculate total payment and interest
    total_payment := monthly_payment * p_loan_term_months;
    total_interest := total_payment - p_loan_amount;
    
    result := jsonb_build_object(
        'monthly_payment', monthly_payment,
        'total_interest', total_interest,
        'total_payment', total_payment,
        'monthly_rate', monthly_rate,
        'annual_rate', p_interest_rate
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to generate loan agreement number
CREATE OR REPLACE FUNCTION public.generate_loan_agreement_number()
RETURNS TEXT AS $$
DECLARE
    agreement_number TEXT;
    year_part TEXT;
    month_part TEXT;
    sequence_part TEXT;
    current_sequence INTEGER;
BEGIN
    -- Get current year and month
    year_part := EXTRACT(YEAR FROM CURRENT_DATE)::TEXT;
    month_part := LPAD(EXTRACT(MONTH FROM CURRENT_DATE)::TEXT, 2, '0');
    
    -- Get next sequence number for this month
    SELECT COALESCE(MAX(CAST(SUBSTRING(agreement_number FROM 9) AS INTEGER)), 0) + 1
    INTO current_sequence
    FROM public.loan_agreements
    WHERE agreement_number LIKE 'LA' || year_part || month_part || '%';
    
    -- Format sequence part
    sequence_part := LPAD(current_sequence::TEXT, 4, '0');
    
    -- Build agreement number
    agreement_number := 'LA' || year_part || month_part || sequence_part;
    
    RETURN agreement_number;
END;
$$ LANGUAGE plpgsql;

-- Function to check loan eligibility
CREATE OR REPLACE FUNCTION public.check_loan_eligibility(
    p_user_id TEXT,
    p_loan_amount DECIMAL,
    p_loan_term_months INTEGER
)
RETURNS JSONB AS $$
DECLARE
    user_profile RECORD;
    kyc_status JSONB;
    affordability JSONB;
    eligibility_result JSONB;
    is_eligible BOOLEAN := TRUE;
    eligibility_reasons TEXT[] := ARRAY[]::TEXT[];
BEGIN
    -- Get user profile
    SELECT * INTO user_profile FROM public.profiles WHERE user_id = p_user_id;
    
    IF user_profile IS NULL THEN
        RETURN jsonb_build_object(
            'eligible', FALSE,
            'reasons', ARRAY['User profile not found']
        );
    END IF;
    
    -- Check KYC status
    kyc_status := public.validate_kyc_status(p_user_id);
    IF NOT (kyc_status->>'is_verified')::BOOLEAN THEN
        is_eligible := FALSE;
        eligibility_reasons := array_append(eligibility_reasons, 'KYC verification required');
    END IF;
    
    -- Check affordability
    affordability := public.calculate_loan_affordability(p_user_id, p_loan_amount, p_loan_term_months);
    IF NOT (affordability->>'affordable')::BOOLEAN THEN
        is_eligible := FALSE;
        eligibility_reasons := array_append(eligibility_reasons, 'Loan amount exceeds affordability limit');
    END IF;
    
    -- Check minimum income requirement
    IF COALESCE(user_profile.monthly_income, 0) < 3000 THEN
        is_eligible := FALSE;
        eligibility_reasons := array_append(eligibility_reasons, 'Minimum monthly income requirement not met');
    END IF;
    
    -- Check loan amount limits
    IF p_loan_amount < 500 OR p_loan_amount > 10000 THEN
        is_eligible := FALSE;
        eligibility_reasons := array_append(eligibility_reasons, 'Loan amount outside allowed range (N$500 - N$10,000)');
    END IF;
    
    -- Check loan term limits
    IF p_loan_term_months < 1 OR p_loan_term_months > 5 THEN
        is_eligible := FALSE;
        eligibility_reasons := array_append(eligibility_reasons, 'Loan term outside allowed range (1-5 months)');
    END IF;
    
    eligibility_result := jsonb_build_object(
        'eligible', is_eligible,
        'reasons', eligibility_reasons,
        'kyc_status', kyc_status,
        'affordability', affordability
    );
    
    RETURN eligibility_result;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- TRIGGER FUNCTIONS
-- =====================================================

-- Trigger function for profiles table
CREATE OR REPLACE FUNCTION public.profiles_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'INSERT',
            'profiles',
            NEW.user_id,
            NULL,
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'UPDATE',
            'profiles',
            NEW.user_id,
            to_jsonb(OLD),
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM public.create_audit_log(
            OLD.user_id,
            NULL,
            'DELETE',
            'profiles',
            OLD.user_id,
            to_jsonb(OLD),
            NULL,
            NULL,
            NULL
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger function for loan applications table
CREATE OR REPLACE FUNCTION public.loan_applications_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'INSERT',
            'loan_applications',
            NEW.id::TEXT,
            NULL,
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'UPDATE',
            'loan_applications',
            NEW.id::TEXT,
            to_jsonb(OLD),
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM public.create_audit_log(
            OLD.user_id,
            NULL,
            'DELETE',
            'loan_applications',
            OLD.id::TEXT,
            to_jsonb(OLD),
            NULL,
            NULL,
            NULL
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Trigger function for KYC verifications table
CREATE OR REPLACE FUNCTION public.kyc_verifications_audit_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'INSERT',
            'kyc_verifications',
            NEW.id::TEXT,
            NULL,
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'UPDATE' THEN
        PERFORM public.create_audit_log(
            NEW.user_id,
            NULL,
            'UPDATE',
            'kyc_verifications',
            NEW.id::TEXT,
            to_jsonb(OLD),
            to_jsonb(NEW),
            NULL,
            NULL
        );
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        PERFORM public.create_audit_log(
            OLD.user_id,
            NULL,
            'DELETE',
            'kyc_verifications',
            OLD.id::TEXT,
            to_jsonb(OLD),
            NULL,
            NULL,
            NULL
        );
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- TRIGGERS
-- =====================================================

-- Updated_at triggers for all tables
CREATE TRIGGER trigger_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_admin_users_updated_at
    BEFORE UPDATE ON public.admin_users
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_companies_updated_at
    BEFORE UPDATE ON public.companies
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_loan_applications_updated_at
    BEFORE UPDATE ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_kyc_verifications_updated_at
    BEFORE UPDATE ON public.kyc_verifications
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_employee_verifications_updated_at
    BEFORE UPDATE ON public.employee_verifications
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_partner_companies_updated_at
    BEFORE UPDATE ON public.partner_companies
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_realpay_transactions_updated_at
    BEFORE UPDATE ON public.realpay_transactions
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Audit triggers for critical tables
CREATE TRIGGER trigger_profiles_audit
    AFTER INSERT OR UPDATE OR DELETE ON public.profiles
    FOR EACH ROW EXECUTE FUNCTION public.profiles_audit_trigger();

CREATE TRIGGER trigger_loan_applications_audit
    AFTER INSERT OR UPDATE OR DELETE ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.loan_applications_audit_trigger();

CREATE TRIGGER trigger_kyc_verifications_audit
    AFTER INSERT OR UPDATE OR DELETE ON public.kyc_verifications
    FOR EACH ROW EXECUTE FUNCTION public.kyc_verifications_audit_trigger();

-- =====================================================
-- STORED PROCEDURES
-- =====================================================

-- Procedure to process loan application
CREATE OR REPLACE FUNCTION public.process_loan_application(
    p_user_id TEXT,
    p_loan_amount DECIMAL,
    p_loan_term_months INTEGER,
    p_purpose TEXT
)
RETURNS JSONB AS $$
DECLARE
    eligibility_result JSONB;
    loan_application_id UUID;
    result JSONB;
BEGIN
    -- Check eligibility
    eligibility_result := public.check_loan_eligibility(p_user_id, p_loan_amount, p_loan_term_months);
    
    IF NOT (eligibility_result->>'eligible')::BOOLEAN THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', 'Loan application not eligible',
            'eligibility', eligibility_result
        );
    END IF;
    
    -- Create loan application
    INSERT INTO public.loan_applications (
        user_id,
        loan_amount,
        loan_term_months,
        purpose,
        status,
        created_at,
        updated_at
    ) VALUES (
        p_user_id,
        p_loan_amount,
        p_loan_term_months,
        p_purpose,
        'pending',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    ) RETURNING id INTO loan_application_id;
    
    result := jsonb_build_object(
        'success', TRUE,
        'message', 'Loan application submitted successfully',
        'application_id', loan_application_id,
        'eligibility', eligibility_result
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Procedure to approve loan application
CREATE OR REPLACE FUNCTION public.approve_loan_application(
    p_application_id UUID,
    p_admin_user_id TEXT,
    p_approval_notes TEXT
)
RETURNS JSONB AS $$
DECLARE
    application_record RECORD;
    agreement_number TEXT;
    result JSONB;
BEGIN
    -- Get application record
    SELECT * INTO application_record FROM public.loan_applications WHERE id = p_application_id;
    
    IF application_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', 'Loan application not found'
        );
    END IF;
    
    IF application_record.status != 'pending' THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', 'Loan application is not in pending status'
        );
    END IF;
    
    -- Update application status
    UPDATE public.loan_applications
    SET status = 'approved',
        approved_at = CURRENT_TIMESTAMP,
        approved_by = p_admin_user_id,
        approval_notes = p_approval_notes,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_application_id;
    
    -- Generate agreement number
    agreement_number := public.generate_loan_agreement_number();
    
    -- Create loan agreement
    INSERT INTO public.loan_agreements (
        user_id,
        loan_application_id,
        agreement_number,
        status,
        created_at,
        updated_at
    ) VALUES (
        application_record.user_id,
        p_application_id,
        agreement_number,
        'active',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    );
    
    result := jsonb_build_object(
        'success', TRUE,
        'message', 'Loan application approved successfully',
        'agreement_number', agreement_number
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Procedure to reject loan application
CREATE OR REPLACE FUNCTION public.reject_loan_application(
    p_application_id UUID,
    p_admin_user_id TEXT,
    p_rejection_reason TEXT
)
RETURNS JSONB AS $$
DECLARE
    application_record RECORD;
    result JSONB;
BEGIN
    -- Get application record
    SELECT * INTO application_record FROM public.loan_applications WHERE id = p_application_id;
    
    IF application_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', 'Loan application not found'
        );
    END IF;
    
    IF application_record.status != 'pending' THEN
        RETURN jsonb_build_object(
            'success', FALSE,
            'message', 'Loan application is not in pending status'
        );
    END IF;
    
    -- Update application status
    UPDATE public.loan_applications
    SET status = 'rejected',
        rejected_at = CURRENT_TIMESTAMP,
        rejected_by = p_admin_user_id,
        rejection_reason = p_rejection_reason,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = p_application_id;
    
    result := jsonb_build_object(
        'success', TRUE,
        'message', 'Loan application rejected successfully'
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- VIEWS
-- =====================================================

-- View for active loan applications
CREATE OR REPLACE VIEW public.active_loan_applications AS
SELECT 
    la.id,
    la.user_id,
    p.first_name,
    p.last_name,
    p.phone_number,
    la.loan_amount,
    la.loan_term_months,
    la.purpose,
    la.status,
    la.created_at,
    la.updated_at
FROM public.loan_applications la
JOIN public.profiles p ON la.user_id = p.user_id
WHERE la.status IN ('pending', 'approved', 'active');

-- View for loan statistics
CREATE OR REPLACE VIEW public.loan_statistics AS
SELECT 
    COUNT(*) as total_applications,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_applications,
    COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_applications,
    COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_applications,
    COUNT(CASE WHEN status = 'active' THEN 1 END) as active_loans,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_loans,
    SUM(CASE WHEN status = 'approved' THEN loan_amount ELSE 0 END) as total_approved_amount,
    AVG(CASE WHEN status = 'approved' THEN loan_amount ELSE NULL END) as average_approved_amount
FROM public.loan_applications;

-- View for user dashboard data
CREATE OR REPLACE VIEW public.user_dashboard_data AS
SELECT 
    p.user_id,
    p.first_name,
    p.last_name,
    p.phone_number,
    p.monthly_income,
    p.monthly_expenses,
    kyc.status as kyc_status,
    kyc.verified_at as kyc_verified_at,
    COUNT(la.id) as total_applications,
    COUNT(CASE WHEN la.status = 'pending' THEN 1 END) as pending_applications,
    COUNT(CASE WHEN la.status = 'approved' THEN 1 END) as approved_applications,
    COUNT(CASE WHEN la.status = 'active' THEN 1 END) as active_loans,
    SUM(CASE WHEN la.status = 'approved' THEN la.loan_amount ELSE 0 END) as total_approved_amount
FROM public.profiles p
LEFT JOIN public.kyc_verifications kyc ON p.user_id = kyc.user_id
LEFT JOIN public.loan_applications la ON p.user_id = la.user_id
GROUP BY p.user_id, p.first_name, p.last_name, p.phone_number, p.monthly_income, p.monthly_expenses, kyc.status, kyc.verified_at;

-- Add comments for documentation
COMMENT ON FUNCTION public.update_updated_at_column() IS 'Trigger function to automatically update the updated_at column';
COMMENT ON FUNCTION public.create_audit_log(TEXT, TEXT, TEXT, TEXT, TEXT, JSONB, JSONB, INET, TEXT) IS 'Function to create audit log entries';
COMMENT ON FUNCTION public.check_user_permission(TEXT, TEXT) IS 'Function to check if a user has a specific permission';
COMMENT ON FUNCTION public.calculate_loan_affordability(TEXT, DECIMAL, INTEGER) IS 'Function to calculate loan affordability for a user';
COMMENT ON FUNCTION public.validate_kyc_status(TEXT) IS 'Function to validate KYC verification status for a user';
COMMENT ON FUNCTION public.calculate_loan_interest(DECIMAL, DECIMAL, INTEGER) IS 'Function to calculate loan interest and payments';
COMMENT ON FUNCTION public.generate_loan_agreement_number() IS 'Function to generate unique loan agreement numbers';
COMMENT ON FUNCTION public.check_loan_eligibility(TEXT, DECIMAL, INTEGER) IS 'Function to check comprehensive loan eligibility';
COMMENT ON FUNCTION public.process_loan_application(TEXT, DECIMAL, INTEGER, TEXT) IS 'Procedure to process new loan applications';
COMMENT ON FUNCTION public.approve_loan_application(UUID, TEXT, TEXT) IS 'Procedure to approve loan applications';
COMMENT ON FUNCTION public.reject_loan_application(UUID, TEXT, TEXT) IS 'Procedure to reject loan applications';
COMMENT ON VIEW public.active_loan_applications IS 'View showing all active loan applications with user details';
COMMENT ON VIEW public.loan_statistics IS 'View showing loan application statistics';
COMMENT ON VIEW public.user_dashboard_data IS 'View showing user dashboard data with loan and KYC information';
\n-- End of buffrlend-starter/supabase/migrations/12_database_functions.sql --\n
-- =====================================================
-- BuffrLend KYC Verification RLS Policies Migration
-- =====================================================
-- Description: Creates Row Level Security policies for KYC and verification tables
-- Dependencies: 03_kyc_verification_tables.sql, 05_core_rls_policies.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Enable RLS on KYC tables
ALTER TABLE public.employee_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.kyc_verifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.verification_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.document_submissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.admin_verification_decisions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.verification_audit_log ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- EMPLOYEE_VERIFICATIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own employee verifications
CREATE POLICY "Users can view own employee verifications" ON public.employee_verifications
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all employee verifications
CREATE POLICY "Admins can view all employee verifications" ON public.employee_verifications
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can insert employee verifications
CREATE POLICY "Admins can insert employee verifications" ON public.employee_verifications
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update employee verifications
CREATE POLICY "Admins can update employee verifications" ON public.employee_verifications
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Company managers can view verifications for their company
CREATE POLICY "Company managers can view verifications for their company" ON public.employee_verifications
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            JOIN public.partner_companies pc ON pc.id = company_id
            WHERE up.id = auth.uid()
            AND up.user_role = 'enterprise_user'::user_role_enum -- Assuming company manager is an enterprise user
        )
    );

-- =====================================================
-- KYC_VERIFICATIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own KYC verifications
CREATE POLICY "Users can view own KYC verifications" ON public.kyc_verifications
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all KYC verifications
CREATE POLICY "Admins can view all KYC verifications" ON public.kyc_verifications
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can insert KYC verifications
CREATE POLICY "Admins can insert KYC verifications" ON public.kyc_verifications
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update KYC verifications
CREATE POLICY "Admins can update KYC verifications" ON public.kyc_verifications
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- KYC reviewers can manage KYC verifications
CREATE POLICY "KYC reviewers can manage KYC verifications" ON public.kyc_verifications
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role IN ('admin'::user_role_enum, 'super_admin'::user_role_enum)
        )
    );



-- =====================================================
-- VERIFICATION_REQUESTS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own verification requests
CREATE POLICY "Users can view own verification requests" ON public.verification_requests
    FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own verification requests
CREATE POLICY "Users can insert own verification requests" ON public.verification_requests
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update their own verification requests (limited fields)
CREATE POLICY "Users can update own verification requests" ON public.verification_requests
    FOR UPDATE USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Admins can view all verification requests
CREATE POLICY "Admins can view all verification requests" ON public.verification_requests
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update all verification requests
CREATE POLICY "Admins can update all verification requests" ON public.verification_requests
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Assigned admins can view and update assigned requests
CREATE POLICY "Assigned admins can manage assigned requests" ON public.verification_requests
    FOR ALL USING (
        assigned_to = auth.uid() OR
        EXISTS (
            SELECT 1 FROM public.profiles up
            WHERE up.id = auth.uid()
            AND up.user_role IN ('admin'::user_role_enum, 'super_admin'::user_role_enum)
        )
    );

-- =====================================================
-- DOCUMENT_SUBMISSIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view submissions for their verification requests
CREATE POLICY "Users can view own document submissions" ON public.document_submissions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.verification_requests vr
            WHERE vr.id = verification_request_id
            AND vr.user_id = auth.uid()
        )
    );

-- Users can insert submissions for their verification requests
CREATE POLICY "Users can insert own document submissions" ON public.document_submissions
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.verification_requests vr
            WHERE vr.id = verification_request_id
            AND vr.user_id = auth.uid()
        )
    );

-- Admins can view all document submissions
CREATE POLICY "Admins can view all document submissions" ON public.document_submissions
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update all document submissions
CREATE POLICY "Admins can update all document submissions" ON public.document_submissions
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));



-- =====================================================
-- ADMIN_VERIFICATION_DECISIONS TABLE RLS POLICIES
-- =====================================================

-- Admins can view all verification decisions
CREATE POLICY "Admins can view all verification decisions" ON public.admin_verification_decisions
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can insert verification decisions
CREATE POLICY "Admins can insert verification decisions" ON public.admin_verification_decisions
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update verification decisions
CREATE POLICY "Admins can update verification decisions" ON public.admin_verification_decisions
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Decision makers can view their own decisions
CREATE POLICY "Decision makers can view own decisions" ON public.admin_verification_decisions
    FOR SELECT USING (auth.uid() = admin_id);

-- =====================================================
-- VERIFICATION_AUDIT_LOG TABLE RLS POLICIES
-- =====================================================

-- Admins can view all audit logs
CREATE POLICY "Admins can view all verification audit logs" ON public.verification_audit_log
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- System can insert audit logs (handled by triggers)
CREATE POLICY "System can insert verification audit logs" ON public.verification_audit_log
    FOR INSERT WITH CHECK (true);


\n-- End of buffrlend-starter/supabase/migrations/06_kyc_rls_policies.sql --\n
-- SendGrid Configuration and Settings
-- This migration creates tables for SendGrid API configuration, settings, and management

-- SendGrid API Configuration
CREATE TABLE IF NOT EXISTS sendgrid_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    api_key_encrypted TEXT NOT NULL,
    api_key_hash TEXT NOT NULL, -- For verification without decryption
    from_email TEXT NOT NULL,
    from_name TEXT NOT NULL,
    reply_to_email TEXT,
    reply_to_name TEXT,
    webhook_public_key TEXT, -- For webhook signature verification
    webhook_url TEXT,
    is_active BOOLEAN DEFAULT true,
    environment TEXT DEFAULT 'production' CHECK (environment IN ('sandbox', 'production')),
    rate_limit_per_minute INTEGER DEFAULT 100,
    rate_limit_per_hour INTEGER DEFAULT 1000,
    rate_limit_per_day INTEGER DEFAULT 10000,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Template Management
CREATE TABLE IF NOT EXISTS sendgrid_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL UNIQUE, -- SendGrid template ID
    template_name TEXT NOT NULL,
    template_type TEXT NOT NULL CHECK (template_type IN ('transactional', 'marketing', 'automated')),
    category TEXT,
    subject TEXT,
    content_html TEXT,
    content_text TEXT,
    variables JSONB DEFAULT '[]'::jsonb,
    is_active BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    last_used_at TIMESTAMP WITH TIME ZONE,
    usage_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Sender Authentication
CREATE TABLE IF NOT EXISTS sendgrid_senders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    address TEXT,
    city TEXT,
    state TEXT,
    zip TEXT,
    country TEXT,
    is_verified BOOLEAN DEFAULT false,
    verification_status TEXT DEFAULT 'pending',
    verification_date TIMESTAMP WITH TIME ZONE,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Domain Authentication
CREATE TABLE IF NOT EXISTS sendgrid_domains (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL UNIQUE,
    is_verified BOOLEAN DEFAULT false,
    verification_status TEXT DEFAULT 'pending',
    verification_date TIMESTAMP WITH TIME ZONE,
    dns_records JSONB DEFAULT '[]'::jsonb,
    is_default BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid IP Pools
CREATE TABLE IF NOT EXISTS sendgrid_ip_pools (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pool_name TEXT NOT NULL UNIQUE,
    pool_id TEXT NOT NULL UNIQUE, -- SendGrid pool ID
    is_active BOOLEAN DEFAULT true,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid IP Addresses
CREATE TABLE IF NOT EXISTS sendgrid_ips (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    pool_id UUID REFERENCES sendgrid_ip_pools(id),
    is_active BOOLEAN DEFAULT true,
    is_warmup BOOLEAN DEFAULT false,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    last_used_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Settings and Preferences
CREATE TABLE IF NOT EXISTS sendgrid_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    setting_key TEXT NOT NULL UNIQUE,
    setting_value JSONB NOT NULL,
    setting_type TEXT NOT NULL CHECK (setting_type IN ('string', 'number', 'boolean', 'object', 'array')),
    category TEXT NOT NULL,
    description TEXT,
    is_encrypted BOOLEAN DEFAULT false,
    is_sensitive BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_sendgrid_config_active ON sendgrid_config(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_templates_active ON sendgrid_templates(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_templates_type ON sendgrid_templates(template_type);
CREATE INDEX IF NOT EXISTS idx_sendgrid_senders_verified ON sendgrid_senders(is_verified);
CREATE INDEX IF NOT EXISTS idx_sendgrid_domains_verified ON sendgrid_domains(is_verified);
CREATE INDEX IF NOT EXISTS idx_sendgrid_ips_active ON sendgrid_ips(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_settings_category ON sendgrid_settings(category);

-- Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_sendgrid_config_updated_at BEFORE UPDATE ON sendgrid_config FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_templates_updated_at BEFORE UPDATE ON sendgrid_templates FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_senders_updated_at BEFORE UPDATE ON sendgrid_senders FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_domains_updated_at BEFORE UPDATE ON sendgrid_domains FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_ip_pools_updated_at BEFORE UPDATE ON sendgrid_ip_pools FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_ips_updated_at BEFORE UPDATE ON sendgrid_ips FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_settings_updated_at BEFORE UPDATE ON sendgrid_settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert default SendGrid settings
INSERT INTO sendgrid_settings (setting_key, setting_value, setting_type, category, description) VALUES
('sendgrid_api_key', '{"encrypted": true, "value": ""}', 'object', 'api', 'SendGrid API Key for authentication'),
('sendgrid_webhook_public_key', '{"encrypted": true, "value": ""}', 'object', 'webhook', 'SendGrid webhook public key for signature verification'),
('sendgrid_from_email', '{"value": "noreply@lend.buffr.ai"}', 'object', 'sender', 'Default from email address'),
('sendgrid_from_name', '{"value": "BuffrLend"}', 'object', 'sender', 'Default from name'),
('sendgrid_reply_to', '{"value": "support@lend.buffr.ai"}', 'object', 'sender', 'Default reply-to email address'),
('sendgrid_rate_limit_per_minute', '{"value": 100}', 'object', 'rate_limits', 'Rate limit per minute'),
('sendgrid_rate_limit_per_hour', '{"value": 1000}', 'object', 'rate_limits', 'Rate limit per hour'),
('sendgrid_rate_limit_per_day', '{"value": 10000}', 'object', 'rate_limits', 'Rate limit per day'),
('sendgrid_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable email tracking'),
('sendgrid_click_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable click tracking'),
('sendgrid_open_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable open tracking'),
('sendgrid_subscription_tracking_enabled', '{"value": true}', 'object', 'tracking', 'Enable subscription tracking'),
('sendgrid_sandbox_mode', '{"value": false}', 'object', 'environment', 'Enable sandbox mode for testing')
ON CONFLICT (setting_key) DO NOTHING;
\n-- End of buffrlend-starter/supabase/migrations/18_sendgrid_configuration.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/010_create_unified_compliance_framework.sql --\n
-- Create loan_agreements table
CREATE TABLE IF NOT EXISTS loan_agreements (
    id TEXT PRIMARY KEY,
    agreement_number TEXT UNIQUE NOT NULL,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    loan_application_id TEXT,
    agreement_data JSONB NOT NULL,
    status TEXT NOT NULL DEFAULT 'generated' CHECK (status IN ('generated', 'signed', 'cancelled')),
    signature_data JSONB,
    signed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_loan_agreements_user_id ON loan_agreements(user_id);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_agreement_number ON loan_agreements(agreement_number);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_status ON loan_agreements(status);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_created_at ON loan_agreements(created_at);

-- Create audit_logs table for tracking agreement events
CREATE TABLE IF NOT EXISTS audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    action TEXT NOT NULL,
    resource_type TEXT NOT NULL,
    resource_id TEXT NOT NULL,
    details JSONB,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for audit_logs
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_resource_type ON audit_logs(resource_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON audit_logs(created_at);

-- Enable Row Level Security (RLS)
ALTER TABLE loan_agreements ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for loan_agreements
CREATE POLICY "Users can view their own loan agreements" ON loan_agreements
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own loan agreements" ON loan_agreements
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own loan agreements" ON loan_agreements
    FOR UPDATE USING (auth.uid() = user_id);

-- Create RLS policies for audit_logs
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert audit logs" ON audit_logs
    FOR INSERT WITH CHECK (true);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to automatically update updated_at
CREATE TRIGGER update_loan_agreements_updated_at 
    BEFORE UPDATE ON loan_agreements 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Create function to validate agreement data
CREATE OR REPLACE FUNCTION validate_agreement_data()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if required fields are present
    IF NOT (NEW.agreement_data ? 'borrower_name' AND 
            NEW.agreement_data ? 'loan_amount' AND 
            NEW.agreement_data ? 'interest_rate') THEN
        RAISE EXCEPTION 'Invalid agreement data: missing required fields';
    END IF;
    
    -- Check if agreement number is properly formatted
    IF NEW.agreement_number !~ '^BUFFR-\d{8}-\d{4}$' THEN
        RAISE EXCEPTION 'Invalid agreement number format';
    END IF;
    
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to validate agreement data
CREATE TRIGGER validate_loan_agreement_data 
    BEFORE INSERT OR UPDATE ON loan_agreements 
    FOR EACH ROW 
    EXECUTE FUNCTION validate_agreement_data();

-- Create function to log agreement events
CREATE OR REPLACE FUNCTION log_agreement_event()
RETURNS TRIGGER AS $$
BEGIN
    -- Log the event
    INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (
        NEW.user_id,
        CASE 
            WHEN TG_OP = 'INSERT' THEN 'loan_agreement_created'
            WHEN TG_OP = 'UPDATE' THEN 'loan_agreement_updated'
            WHEN TG_OP = 'DELETE' THEN 'loan_agreement_deleted'
        END,
        'loan_agreement',
        NEW.id,
        jsonb_build_object(
            'agreement_number', NEW.agreement_number,
            'status', NEW.status,
            'operation', TG_OP
        )
    );
    
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to log agreement events
CREATE TRIGGER log_loan_agreement_events 
    AFTER INSERT OR UPDATE OR DELETE ON loan_agreements 
    FOR EACH ROW 
    EXECUTE FUNCTION log_agreement_event();

-- Create view for agreement summary
CREATE OR REPLACE VIEW loan_agreement_summary AS
SELECT 
    la.id,
    la.agreement_number,
    la.user_id,
    la.status,
    la.created_at,
    la.signed_at,
    la.agreement_data->>'borrower_name' as borrower_name,
    la.agreement_data->>'loan_amount' as loan_amount,
    la.agreement_data->>'interest_rate' as interest_rate,
    la.agreement_data->>'term_months' as term_months,
    la.agreement_data->>'monthly_payment' as monthly_payment
FROM loan_agreements la;

-- Grant permissions
GRANT SELECT ON loan_agreement_summary TO authenticated;
GRANT ALL ON loan_agreements TO authenticated;
GRANT ALL ON audit_logs TO authenticated;

-- Create comments for documentation
COMMENT ON TABLE loan_agreements IS 'Stores loan agreement data and signature information';
COMMENT ON TABLE audit_logs IS 'Audit trail for loan agreement events and user actions';
COMMENT ON VIEW loan_agreement_summary IS 'Summary view of loan agreements for reporting';
\n-- End of buffrlend-starter/supabase/migrations/20241201000000_create_loan_agreements.sql --\n
-- =====================================================
-- BuffrLend Financial Tables Migration
-- =====================================================
-- Description: Creates financial and payment related tables
-- Dependencies: 02_core_tables.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Create realpay_transactions table
CREATE TABLE IF NOT EXISTS public.realpay_transactions (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    realpay_transaction_id TEXT UNIQUE,
    buffr_reference TEXT UNIQUE NOT NULL,
    loan_application_id UUID REFERENCES public.loan_applications(id),
    user_id UUID REFERENCES public.unified_profiles(id),
    transaction_type TEXT NOT NULL CHECK (transaction_type IN ('disbursement', 'collection', 'refund', 'reversal')),
    amount NUMERIC NOT NULL,
    currency TEXT DEFAULT 'NAD',
    description TEXT,
    recipient_bank_code TEXT,
    recipient_account_number TEXT,
    recipient_account_holder TEXT,
    recipient_branch_code TEXT,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled', 'reversed')),
    realpay_status TEXT,
    failure_reason TEXT,
    api_request_payload JSONB,
    api_response_payload JSONB,
    webhook_payload JSONB,
    realpay_fee NUMERIC DEFAULT 0.00,
    buffr_fee NUMERIC DEFAULT 0.00,
    total_fees NUMERIC DEFAULT 0.00,
    initiated_at TIMESTAMPTZ DEFAULT NOW(),
    processed_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    next_retry_at TIMESTAMPTZ,
    compliance_checked BOOLEAN DEFAULT FALSE,
    aml_status TEXT CHECK (aml_status IN ('pending', 'cleared', 'flagged', 'blocked')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create collection_schedules table
CREATE TABLE IF NOT EXISTS public.collection_schedules (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    loan_application_id UUID REFERENCES public.loan_applications(id),
    company_id UUID REFERENCES public.partner_companies(id),
    scheduled_date DATE NOT NULL,
    collection_amount NUMERIC NOT NULL,
    collection_type TEXT NOT NULL CHECK (collection_type IN ('principal', 'interest', 'penalty', 'fee')),
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'collected', 'failed', 'cancelled')),
    attempt_count INTEGER DEFAULT 0,
    collected_amount NUMERIC DEFAULT 0,
    collection_method TEXT CHECK (collection_method IN ('payroll_deduction', 'bank_transfer', 'manual')),
    failure_reason TEXT,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create collection_transactions table
CREATE TABLE IF NOT EXISTS public.collection_transactions (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    schedule_id TEXT NOT NULL,
    loan_application_id UUID REFERENCES public.loan_applications(id),
    employee_id UUID REFERENCES public.unified_profiles(id),
    employer_id UUID REFERENCES public.partner_companies(id),
    deduction_amount NUMERIC DEFAULT 0,
    gross_salary NUMERIC DEFAULT 0,
    net_salary NUMERIC DEFAULT 0,
    deduction_percentage NUMERIC DEFAULT 0,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'collected', 'failed', 'cancelled')),
    collection_date TIMESTAMPTZ,
    processed_date TIMESTAMPTZ,
    reference_number TEXT,
    failure_reason TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create employer_reconciliations table
CREATE TABLE IF NOT EXISTS public.employer_reconciliations (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    employer_id UUID REFERENCES public.partner_companies(id),
    collection_period TEXT NOT NULL,
    expected_amount NUMERIC DEFAULT 0,
    received_amount NUMERIC DEFAULT 0,
    variance NUMERIC DEFAULT 0,
    variance_percentage NUMERIC DEFAULT 0,
    transactions_expected INTEGER DEFAULT 0,
    transactions_received INTEGER DEFAULT 0,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'matched', 'variance', 'reconciled')),
    reconciliation_notes TEXT,
    reconciled_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create loan_rates table
CREATE TABLE IF NOT EXISTS public.loan_rates (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    base_interest_rate NUMERIC DEFAULT 5.90,
    namfisa_levy NUMERIC DEFAULT 0.50,
    realpay_processing_fee NUMERIC DEFAULT 50.00,
    realpay_transaction_fee NUMERIC DEFAULT 2.50,
    realpay_monthly_fee NUMERIC DEFAULT 25.00,
    admin_fee NUMERIC DEFAULT 100.00,
    late_payment_fee NUMERIC DEFAULT 5.00,
    early_repayment_fee NUMERIC DEFAULT 2.00,
    insurance_fee NUMERIC DEFAULT 75.00,
    compliance_fee NUMERIC DEFAULT 50.00,
    bank_processing_fee NUMERIC DEFAULT 150.00,
    bank_monthly_fee NUMERIC DEFAULT 30.00,
    bank_transaction_fee NUMERIC DEFAULT 1.50,
    bank_setup_fee NUMERIC DEFAULT 200.00,
    max_dti_ratio NUMERIC DEFAULT 33.33,
    max_loan_amount NUMERIC DEFAULT 150000.00,
    max_loan_term INTEGER DEFAULT 36,
    min_monthly_income NUMERIC DEFAULT 5000.00,
    namfisa_mls4_compliant BOOLEAN DEFAULT TRUE,
    responsible_lending_enabled BOOLEAN DEFAULT TRUE,
    transparency_requirements BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create rates table
CREATE TABLE IF NOT EXISTS public.rates (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    rate_type TEXT NOT NULL CHECK (rate_type IN ('base_interest', 'processing_fee', 'late_penalty', 'promotional', 'risk_adjustment')),
    rate_name TEXT NOT NULL,
    rate_value NUMERIC NOT NULL,
    rate_unit TEXT DEFAULT 'percentage' CHECK (rate_unit IN ('percentage', 'fixed_amount')),
    loan_product TEXT CHECK (loan_product IN ('payday', 'term', 'emergency', 'all')),
    min_amount NUMERIC,
    max_amount NUMERIC,
    min_term_months INTEGER,
    max_term_months INTEGER,
    risk_category TEXT CHECK (risk_category IN ('low', 'medium', 'high', 'all')),
    effective_date DATE DEFAULT CURRENT_DATE,
    expiry_date DATE,
    is_active BOOLEAN DEFAULT TRUE,
    applies_to_new_loans BOOLEAN DEFAULT TRUE,
    applies_to_existing_loans BOOLEAN DEFAULT FALSE,
    description TEXT,
    calculation_formula TEXT,
    created_by UUID REFERENCES public.admin_users(id),
    approved_by UUID REFERENCES public.unified_profiles(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create loan_terms table
CREATE TABLE IF NOT EXISTS public.loan_terms (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    term_category TEXT NOT NULL CHECK (term_category IN ('eligibility', 'amounts', 'duration', 'affordability', 'documentation')),
    term_name TEXT NOT NULL,
    term_value JSONB NOT NULL,
    loan_product TEXT CHECK (loan_product IN ('payday', 'term', 'emergency', 'all')),
    company_tier TEXT CHECK (company_tier IN ('basic', 'premium', 'enterprise', 'all')),
    employment_type TEXT CHECK (employment_type IN ('permanent', 'contract', 'temporary', 'all')),
    effective_date DATE DEFAULT CURRENT_DATE,
    expiry_date DATE,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    namfisa_reference TEXT,
    created_by UUID REFERENCES public.admin_users(id),
    approved_by UUID REFERENCES public.unified_profiles(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create fee_categories table
CREATE TABLE IF NOT EXISTS public.fee_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    category_name TEXT UNIQUE NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create fee_configurations table
CREATE TABLE IF NOT EXISTS public.fee_configurations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    config_name TEXT UNIQUE NOT NULL,
    config_value NUMERIC NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    category_id UUID REFERENCES public.fee_categories(id)
);

-- Create user_fee_breakdown table
CREATE TABLE IF NOT EXISTS public.user_fee_breakdown (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    loan_application_id UUID REFERENCES public.loan_applications(id),
    fee_type TEXT NOT NULL,
    fee_category TEXT NOT NULL,
    fee_amount NUMERIC NOT NULL,
    fee_description TEXT,
    is_charged_to_user BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create affordability_calculations table
CREATE TABLE IF NOT EXISTS public.affordability_calculations (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES public.unified_profiles(id),
    loan_application_id UUID REFERENCES public.loan_applications(id),
    monthly_income NUMERIC NOT NULL,
    monthly_expenses NUMERIC NOT NULL,
    existing_debt_obligations NUMERIC DEFAULT 0.00,
    discretionary_income NUMERIC NOT NULL,
    dti_ratio NUMERIC NOT NULL,
    affordability_score INTEGER NOT NULL,
    risk_category VARCHAR NOT NULL CHECK (risk_category IN ('low', 'medium', 'high')),
    recommendation TEXT,
    namfisa_compliant BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create responsible_lending_policies table
CREATE TABLE IF NOT EXISTS public.responsible_lending_policies (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    policy_name VARCHAR NOT NULL,
    policy_type VARCHAR NOT NULL CHECK (policy_type IN ('dti_limit', 'income_requirement', 'loan_limit', 'term_limit', 'fee_cap')),
    policy_value NUMERIC NOT NULL,
    policy_description TEXT,
    namfisa_guideline VARCHAR,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create realpay_config table
CREATE TABLE IF NOT EXISTS public.realpay_config (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    realpay_api_key VARCHAR,
    realpay_api_url VARCHAR DEFAULT 'https://api.realpay.com/v1',
    realpay_merchant_id VARCHAR,
    realpay_webhook_secret VARCHAR,
    realpay_timeout_seconds INTEGER DEFAULT 30,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_loan_id ON public.realpay_transactions(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_user_id ON public.realpay_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_status ON public.realpay_transactions(status);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_type ON public.realpay_transactions(transaction_type);

CREATE INDEX IF NOT EXISTS idx_collection_schedules_loan_id ON public.collection_schedules(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_company_id ON public.collection_schedules(company_id);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_date ON public.collection_schedules(scheduled_date);

CREATE INDEX IF NOT EXISTS idx_collection_transactions_loan_id ON public.collection_transactions(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_collection_transactions_employee_id ON public.collection_transactions(employee_id);
CREATE INDEX IF NOT EXISTS idx_collection_transactions_employer_id ON public.collection_transactions(employer_id);

CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_employer_id ON public.employer_reconciliations(employer_id);
CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_period ON public.employer_reconciliations(collection_period);

CREATE INDEX IF NOT EXISTS idx_rates_type ON public.rates(rate_type);
CREATE INDEX IF NOT EXISTS idx_rates_effective_date ON public.rates(effective_date);
CREATE INDEX IF NOT EXISTS idx_rates_is_active ON public.rates(is_active);

CREATE INDEX IF NOT EXISTS idx_loan_terms_category ON public.loan_terms(term_category);
CREATE INDEX IF NOT EXISTS idx_loan_terms_effective_date ON public.loan_terms(effective_date);
CREATE INDEX IF NOT EXISTS idx_loan_terms_is_active ON public.loan_terms(is_active);

CREATE INDEX IF NOT EXISTS idx_fee_configurations_name ON public.fee_configurations(config_name);
CREATE INDEX IF NOT EXISTS idx_fee_configurations_category_id ON public.fee_configurations(category_id);

CREATE INDEX IF NOT EXISTS idx_user_fee_breakdown_loan_id ON public.user_fee_breakdown(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_user_fee_breakdown_type ON public.user_fee_breakdown(fee_type);

CREATE INDEX IF NOT EXISTS idx_affordability_calculations_user_id ON public.affordability_calculations(user_id);
CREATE INDEX IF NOT EXISTS idx_affordability_calculations_loan_id ON public.affordability_calculations(loan_application_id);

-- Add table comments
COMMENT ON TABLE public.realpay_transactions IS 'RealPay transaction records for disbursements and collections';
COMMENT ON TABLE public.collection_schedules IS 'Scheduled loan collection payments';
COMMENT ON TABLE public.collection_transactions IS 'Actual collection transactions from employers';
COMMENT ON TABLE public.employer_reconciliations IS 'Reconciliation records between expected and received collections';
COMMENT ON TABLE public.loan_rates IS 'Current loan interest rates and fees';
COMMENT ON TABLE public.rates IS 'Configurable rate structures for different loan products';
COMMENT ON TABLE public.loan_terms IS 'Loan terms and conditions by category';
COMMENT ON TABLE public.fee_categories IS 'Categorizes fees into BUFFR fees, user fees, RealPay fees, and regulatory fees';
COMMENT ON TABLE public.fee_configurations IS 'Configurable fee values that can be modified through admin dashboard';
COMMENT ON TABLE public.user_fee_breakdown IS 'Detailed breakdown of fees for each loan application';
COMMENT ON TABLE public.affordability_calculations IS 'Affordability calculations for loan applications';
COMMENT ON TABLE public.responsible_lending_policies IS 'Responsible lending policies and limits';
COMMENT ON TABLE public.realpay_config IS 'RealPay API configuration settings';

-- Apply updated_at triggers
CREATE TRIGGER update_realpay_transactions_updated_at
    BEFORE UPDATE ON public.realpay_transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_collection_schedules_updated_at
    BEFORE UPDATE ON public.collection_schedules
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_collection_transactions_updated_at
    BEFORE UPDATE ON public.collection_transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_employer_reconciliations_updated_at
    BEFORE UPDATE ON public.employer_reconciliations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rates_updated_at
    BEFORE UPDATE ON public.rates
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_loan_terms_updated_at
    BEFORE UPDATE ON public.loan_terms
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_fee_categories_updated_at
    BEFORE UPDATE ON public.fee_categories
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_fee_configurations_updated_at
    BEFORE UPDATE ON public.fee_configurations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_affordability_calculations_updated_at
    BEFORE UPDATE ON public.affordability_calculations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_responsible_lending_policies_updated_at
    BEFORE UPDATE ON public.responsible_lending_policies
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_config_updated_at
    BEFORE UPDATE ON public.realpay_config
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/04_financial_tables.sql --\n
-- =====================================================
-- BuffrLend Audit Logging RLS Policies
-- =====================================================
-- Description: Row Level Security policies for audit logging tables
-- Dependencies: 08_audit_logging_tables.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Enable RLS on audit logging tables


-- =====================================================
-- AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own audit logs
CREATE POLICY "Users can view own audit logs" ON public.audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id OR
        auth.uid()::text = admin_user_id
    );

-- Policy: Admin users can view all audit logs
CREATE POLICY "Admin users can view all audit logs" ON public.audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert audit logs
CREATE POLICY "System can insert audit logs" ON public.audit_logs
    FOR INSERT WITH CHECK (true);

-- Policy: Only system can update audit logs (for corrections)
CREATE POLICY "System can update audit logs" ON public.audit_logs
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role = 'system_admin'
        )
    );

-- Policy: Only system can delete audit logs
CREATE POLICY "System can delete audit logs" ON public.audit_logs
    FOR DELETE USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role = 'system_admin'
        )
    );

-- =====================================================
-- USER ACTIVITY LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own activity logs
CREATE POLICY "Users can view own activity logs" ON public.user_activity_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all user activity logs
CREATE POLICY "Admin users can view all user activity logs" ON public.user_activity_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert user activity logs
CREATE POLICY "System can insert user activity logs" ON public.user_activity_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- SYSTEM AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view system audit logs
CREATE POLICY "Admin users can view system audit logs" ON public.system_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert system audit logs
CREATE POLICY "System can insert system audit logs" ON public.system_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- SECURITY AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only security admin users can view security audit logs
CREATE POLICY "Security admin users can view security audit logs" ON public.security_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('security_admin', 'system_admin')
        )
    );

-- Policy: System can insert security audit logs
CREATE POLICY "System can insert security audit logs" ON public.security_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- FINANCIAL AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own financial audit logs
CREATE POLICY "Users can view own financial audit logs" ON public.financial_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all financial audit logs
CREATE POLICY "Admin users can view all financial audit logs" ON public.financial_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert financial audit logs
CREATE POLICY "System can insert financial audit logs" ON public.financial_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- KYC AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own KYC audit logs
CREATE POLICY "Users can view own KYC audit logs" ON public.kyc_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all KYC audit logs
CREATE POLICY "Admin users can view all KYC audit logs" ON public.kyc_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert KYC audit logs
CREATE POLICY "System can insert KYC audit logs" ON public.kyc_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- LOAN AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own loan audit logs
CREATE POLICY "Users can view own loan audit logs" ON public.loan_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all loan audit logs
CREATE POLICY "Admin users can view all loan audit logs" ON public.loan_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert loan audit logs
CREATE POLICY "System can insert loan audit logs" ON public.loan_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- PAYMENT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own payment audit logs
CREATE POLICY "Users can view own payment audit logs" ON public.payment_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all payment audit logs
CREATE POLICY "Admin users can view all payment audit logs" ON public.payment_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert payment audit logs
CREATE POLICY "System can insert payment audit logs" ON public.payment_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- ADMIN AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view admin audit logs
CREATE POLICY "Admin users can view admin audit logs" ON public.admin_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert admin audit logs
CREATE POLICY "System can insert admin audit logs" ON public.admin_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- COMPLIANCE AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only compliance admin users can view compliance audit logs
CREATE POLICY "Compliance admin users can view compliance audit logs" ON public.compliance_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('compliance_admin', 'system_admin')
        )
    );

-- Policy: System can insert compliance audit logs
CREATE POLICY "System can insert compliance audit logs" ON public.compliance_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- API AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view API audit logs
CREATE POLICY "Admin users can view API audit logs" ON public.api_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert API audit logs
CREATE POLICY "System can insert API audit logs" ON public.api_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- EMAIL AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own email audit logs
CREATE POLICY "Users can view own email audit logs" ON public.email_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all email audit logs
CREATE POLICY "Admin users can view all email audit logs" ON public.email_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert email audit logs
CREATE POLICY "System can insert email audit logs" ON public.email_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- SMS AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own SMS audit logs
CREATE POLICY "Users can view own SMS audit logs" ON public.sms_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all SMS audit logs
CREATE POLICY "Admin users can view all SMS audit logs" ON public.sms_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert SMS audit logs
CREATE POLICY "System can insert SMS audit logs" ON public.sms_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- WHATSAPP AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own WhatsApp audit logs
CREATE POLICY "Users can view own WhatsApp audit logs" ON public.whatsapp_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all WhatsApp audit logs
CREATE POLICY "Admin users can view all WhatsApp audit logs" ON public.whatsapp_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert WhatsApp audit logs
CREATE POLICY "System can insert WhatsApp audit logs" ON public.whatsapp_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- DOCUMENT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own document audit logs
CREATE POLICY "Users can view own document audit logs" ON public.document_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all document audit logs
CREATE POLICY "Admin users can view all document audit logs" ON public.document_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert document audit logs
CREATE POLICY "System can insert document audit logs" ON public.document_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- VERIFICATION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own verification audit logs
CREATE POLICY "Users can view own verification audit logs" ON public.verification_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all verification audit logs
CREATE POLICY "Admin users can view all verification audit logs" ON public.verification_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert verification audit logs
CREATE POLICY "System can insert verification audit logs" ON public.verification_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- RATE AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view rate audit logs
CREATE POLICY "Admin users can view rate audit logs" ON public.rate_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert rate audit logs
CREATE POLICY "System can insert rate audit logs" ON public.rate_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- CONFIG AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view config audit logs
CREATE POLICY "Admin users can view config audit logs" ON public.config_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert config audit logs
CREATE POLICY "System can insert config audit logs" ON public.config_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- SESSION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own session audit logs
CREATE POLICY "Users can view own session audit logs" ON public.session_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all session audit logs
CREATE POLICY "Admin users can view all session audit logs" ON public.session_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert session audit logs
CREATE POLICY "System can insert session audit logs" ON public.session_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- LOGIN AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own login audit logs
CREATE POLICY "Users can view own login audit logs" ON public.login_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all login audit logs
CREATE POLICY "Admin users can view all login audit logs" ON public.login_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert login audit logs
CREATE POLICY "System can insert login audit logs" ON public.login_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- PERMISSION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view permission audit logs
CREATE POLICY "Admin users can view permission audit logs" ON public.permission_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert permission audit logs
CREATE POLICY "System can insert permission audit logs" ON public.permission_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- ROLE AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view role audit logs
CREATE POLICY "Admin users can view role audit logs" ON public.role_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert role audit logs
CREATE POLICY "System can insert role audit logs" ON public.role_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- COMPANY AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view company audit logs
CREATE POLICY "Admin users can view company audit logs" ON public.company_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert company audit logs
CREATE POLICY "System can insert company audit logs" ON public.company_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- PARTNER AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view partner audit logs
CREATE POLICY "Admin users can view partner audit logs" ON public.partner_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert partner audit logs
CREATE POLICY "System can insert partner audit logs" ON public.partner_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- REALPAY AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view RealPay audit logs
CREATE POLICY "Admin users can view RealPay audit logs" ON public.realpay_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert RealPay audit logs
CREATE POLICY "System can insert RealPay audit logs" ON public.realpay_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- NAMFISA AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only compliance admin users can view NAMFISA audit logs
CREATE POLICY "Compliance admin users can view NAMFISA audit logs" ON public.namfisa_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('compliance_admin', 'system_admin')
        )
    );

-- Policy: System can insert NAMFISA audit logs
CREATE POLICY "System can insert NAMFISA audit logs" ON public.namfisa_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- AML AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only compliance admin users can view AML audit logs
CREATE POLICY "Compliance admin users can view AML audit logs" ON public.aml_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('compliance_admin', 'system_admin')
        )
    );

-- Policy: System can insert AML audit logs
CREATE POLICY "System can insert AML audit logs" ON public.aml_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- KYC AML AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only compliance admin users can view KYC AML audit logs
CREATE POLICY "Compliance admin users can view KYC AML audit logs" ON public.kyc_aml_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('compliance_admin', 'system_admin')
        )
    );

-- Policy: System can insert KYC AML audit logs
CREATE POLICY "System can insert KYC AML audit logs" ON public.kyc_aml_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- RISK ASSESSMENT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view risk assessment audit logs
CREATE POLICY "Admin users can view risk assessment audit logs" ON public.risk_assessment_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert risk assessment audit logs
CREATE POLICY "System can insert risk assessment audit logs" ON public.risk_assessment_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- CREDIT CHECK AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own credit check audit logs
CREATE POLICY "Users can view own credit check audit logs" ON public.credit_check_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all credit check audit logs
CREATE POLICY "Admin users can view all credit check audit logs" ON public.credit_check_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert credit check audit logs
CREATE POLICY "System can insert credit check audit logs" ON public.credit_check_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- AFFORDABILITY AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Users can view their own affordability audit logs
CREATE POLICY "Users can view own affordability audit logs" ON public.affordability_audit_logs
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

-- Policy: Admin users can view all affordability audit logs
CREATE POLICY "Admin users can view all affordability audit logs" ON public.affordability_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert affordability audit logs
CREATE POLICY "System can insert affordability audit logs" ON public.affordability_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- COLLECTION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view collection audit logs
CREATE POLICY "Admin users can view collection audit logs" ON public.collection_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert collection audit logs
CREATE POLICY "System can insert collection audit logs" ON public.collection_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- RECONCILIATION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view reconciliation audit logs
CREATE POLICY "Admin users can view reconciliation audit logs" ON public.reconciliation_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert reconciliation audit logs
CREATE POLICY "System can insert reconciliation audit logs" ON public.reconciliation_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- REPORT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view report audit logs
CREATE POLICY "Admin users can view report audit logs" ON public.report_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert report audit logs
CREATE POLICY "System can insert report audit logs" ON public.report_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- ANALYTICS AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view analytics audit logs
CREATE POLICY "Admin users can view analytics audit logs" ON public.analytics_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert analytics audit logs
CREATE POLICY "System can insert analytics audit logs" ON public.analytics_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- METRICS AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view metrics audit logs
CREATE POLICY "Admin users can view metrics audit logs" ON public.metrics_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert metrics audit logs
CREATE POLICY "System can insert metrics audit logs" ON public.metrics_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- PERFORMANCE AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view performance audit logs
CREATE POLICY "Admin users can view performance audit logs" ON public.performance_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert performance audit logs
CREATE POLICY "System can insert performance audit logs" ON public.performance_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- ERROR AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view error audit logs
CREATE POLICY "Admin users can view error audit logs" ON public.error_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert error audit logs
CREATE POLICY "System can insert error audit logs" ON public.error_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- EXCEPTION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view exception audit logs
CREATE POLICY "Admin users can view exception audit logs" ON public.exception_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert exception audit logs
CREATE POLICY "System can insert exception audit logs" ON public.exception_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- INCIDENT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view incident audit logs
CREATE POLICY "Admin users can view incident audit logs" ON public.incident_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert incident audit logs
CREATE POLICY "System can insert incident audit logs" ON public.incident_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- BREACH AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only security admin users can view breach audit logs
CREATE POLICY "Security admin users can view breach audit logs" ON public.breach_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('security_admin', 'system_admin')
        )
    );

-- Policy: System can insert breach audit logs
CREATE POLICY "System can insert breach audit logs" ON public.breach_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- VULNERABILITY AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only security admin users can view vulnerability audit logs
CREATE POLICY "Security admin users can view vulnerability audit logs" ON public.vulnerability_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('security_admin', 'system_admin')
        )
    );

-- Policy: System can insert vulnerability audit logs
CREATE POLICY "System can insert vulnerability audit logs" ON public.vulnerability_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- THREAT AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only security admin users can view threat audit logs
CREATE POLICY "Security admin users can view threat audit logs" ON public.threat_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role IN ('security_admin', 'system_admin')
        )
    );

-- Policy: System can insert threat audit logs
CREATE POLICY "System can insert threat audit logs" ON public.threat_audit_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- AUDIT RETENTION POLICIES RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view audit retention policies
CREATE POLICY "Admin users can view audit retention policies" ON public.audit_retention_policies
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: Only system admin users can modify audit retention policies
CREATE POLICY "System admin users can modify audit retention policies" ON public.audit_retention_policies
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text AND role = 'system_admin'
        )
    );

-- =====================================================
-- AUDIT ARCHIVAL LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view audit archival logs
CREATE POLICY "Admin users can view audit archival logs" ON public.audit_archival_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert audit archival logs
CREATE POLICY "System can insert audit archival logs" ON public.audit_archival_logs
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- AUDIT RETENTION AUDIT LOGS RLS POLICIES
-- =====================================================

-- Policy: Only admin users can view audit retention audit logs
CREATE POLICY "Admin users can view audit retention audit logs" ON public.audit_retention_audit_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Policy: System can insert audit retention audit logs
CREATE POLICY "System can insert audit retention audit logs" ON public.audit_retention_audit_logs
    FOR INSERT WITH CHECK (true);

-- Add comments for documentation
COMMENT ON TABLE public.audit_logs IS 'General audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.user_activity_logs IS 'User activity logs with RLS policies for user and admin access';
COMMENT ON TABLE public.system_audit_logs IS 'System audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.security_audit_logs IS 'Security audit logs with RLS policies for security admin access only';
COMMENT ON TABLE public.financial_audit_logs IS 'Financial audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.kyc_audit_logs IS 'KYC audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.loan_audit_logs IS 'Loan audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.payment_audit_logs IS 'Payment audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.admin_audit_logs IS 'Admin audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.compliance_audit_logs IS 'Compliance audit logs with RLS policies for compliance admin access only';
COMMENT ON TABLE public.api_audit_logs IS 'API audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.email_audit_logs IS 'Email audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.sms_audit_logs IS 'SMS audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.whatsapp_audit_logs IS 'WhatsApp audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.document_audit_logs IS 'Document audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.verification_audit_logs IS 'Verification audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.rate_audit_logs IS 'Rate audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.config_audit_logs IS 'Config audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.session_audit_logs IS 'Session audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.login_audit_logs IS 'Login audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.permission_audit_logs IS 'Permission audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.role_audit_logs IS 'Role audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.company_audit_logs IS 'Company audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.partner_audit_logs IS 'Partner audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.realpay_audit_logs IS 'RealPay audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.namfisa_audit_logs IS 'NAMFISA audit logs with RLS policies for compliance admin access only';
COMMENT ON TABLE public.aml_audit_logs IS 'AML audit logs with RLS policies for compliance admin access only';
COMMENT ON TABLE public.kyc_aml_audit_logs IS 'KYC AML audit logs with RLS policies for compliance admin access only';
COMMENT ON TABLE public.risk_assessment_audit_logs IS 'Risk assessment audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.credit_check_audit_logs IS 'Credit check audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.affordability_audit_logs IS 'Affordability audit logs with RLS policies for user and admin access';
COMMENT ON TABLE public.collection_audit_logs IS 'Collection audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.reconciliation_audit_logs IS 'Reconciliation audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.report_audit_logs IS 'Report audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.analytics_audit_logs IS 'Analytics audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.metrics_audit_logs IS 'Metrics audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.performance_audit_logs IS 'Performance audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.error_audit_logs IS 'Error audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.exception_audit_logs IS 'Exception audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.incident_audit_logs IS 'Incident audit logs with RLS policies for admin access only';
COMMENT ON TABLE public.breach_audit_logs IS 'Breach audit logs with RLS policies for security admin access only';
COMMENT ON TABLE public.vulnerability_audit_logs IS 'Vulnerability audit logs with RLS policies for security admin access only';
COMMENT ON TABLE public.threat_audit_logs IS 'Threat audit logs with RLS policies for security admin access only';
COMMENT ON TABLE public.audit_retention_policies IS 'Audit retention policies with RLS policies for admin access only';
COMMENT ON TABLE public.audit_archival_logs IS 'Audit archival logs with RLS policies for admin access only';
COMMENT ON TABLE public.audit_retention_audit_logs IS 'Audit retention audit logs with RLS policies for admin access only';
\n-- End of buffrlend-starter/supabase/migrations/10_audit_logging_rls_policies.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/005_create_unified_payment_gateways.sql --\n
-- =====================================================
-- BuffrLend Database Indexes Migration
-- =====================================================
-- Description: Performance optimization indexes for all tables
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- CORE TABLES INDEXES
-- =====================================================

-- Profiles table indexes
CREATE INDEX IF NOT EXISTS idx_profiles_user_id ON public.profiles(user_id);
CREATE INDEX IF NOT EXISTS idx_profiles_phone_number ON public.profiles(phone_number);
CREATE INDEX IF NOT EXISTS idx_profiles_id_number ON public.profiles(id_number);
CREATE INDEX IF NOT EXISTS idx_profiles_created_at ON public.profiles(created_at);
CREATE INDEX IF NOT EXISTS idx_profiles_updated_at ON public.profiles(updated_at);

-- Admin users table indexes
CREATE INDEX IF NOT EXISTS idx_admin_users_email ON public.admin_users(email);
CREATE INDEX IF NOT EXISTS idx_admin_users_role ON public.admin_users(role);
CREATE INDEX IF NOT EXISTS idx_admin_users_status ON public.admin_users(status);
CREATE INDEX IF NOT EXISTS idx_admin_users_created_at ON public.admin_users(created_at);

-- Companies table indexes
CREATE INDEX IF NOT EXISTS idx_companies_registration_number ON public.companies(registration_number);
CREATE INDEX IF NOT EXISTS idx_companies_status ON public.companies(status);
CREATE INDEX IF NOT EXISTS idx_companies_created_at ON public.companies(created_at);

-- User roles table indexes
CREATE INDEX IF NOT EXISTS idx_user_roles_role_name ON public.user_roles(role_name);
CREATE INDEX IF NOT EXISTS idx_user_roles_is_active ON public.user_roles(is_active);

-- Permissions table indexes
CREATE INDEX IF NOT EXISTS idx_permissions_permission_name ON public.permissions(permission_name);
CREATE INDEX IF NOT EXISTS idx_permissions_resource ON public.permissions(resource);

-- Role permissions table indexes
CREATE INDEX IF NOT EXISTS idx_role_permissions_role_id ON public.role_permissions(role_id);
CREATE INDEX IF NOT EXISTS idx_role_permissions_permission_id ON public.role_permissions(permission_id);

-- User role assignments table indexes
CREATE INDEX IF NOT EXISTS idx_user_role_assignments_user_id ON public.user_role_assignments(user_id);
CREATE INDEX IF NOT EXISTS idx_user_role_assignments_role_id ON public.user_role_assignments(role_id);
CREATE INDEX IF NOT EXISTS idx_user_role_assignments_assigned_at ON public.user_role_assignments(assigned_at);

-- =====================================================
-- KYC VERIFICATION TABLES INDEXES
-- =====================================================

-- KYC verifications table indexes
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_user_id ON public.kyc_verifications(user_id);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_status ON public.kyc_verifications(status);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_created_at ON public.kyc_verifications(created_at);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_updated_at ON public.kyc_verifications(updated_at);

-- Employee verifications table indexes
CREATE INDEX IF NOT EXISTS idx_employee_verifications_user_id ON public.employee_verifications(user_id);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_company_id ON public.employee_verifications(company_id);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_status ON public.employee_verifications(status);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_created_at ON public.employee_verifications(created_at);

-- Verification requests table indexes
CREATE INDEX IF NOT EXISTS idx_verification_requests_user_id ON public.verification_requests(user_id);
CREATE INDEX IF NOT EXISTS idx_verification_requests_status ON public.verification_requests(status);
CREATE INDEX IF NOT EXISTS idx_verification_requests_created_at ON public.verification_requests(created_at);

-- Document submissions table indexes
CREATE INDEX IF NOT EXISTS idx_document_submissions_user_id ON public.document_submissions(user_id);
CREATE INDEX IF NOT EXISTS idx_document_submissions_document_type ON public.document_submissions(document_type);
CREATE INDEX IF NOT EXISTS idx_document_submissions_status ON public.document_submissions(status);
CREATE INDEX IF NOT EXISTS idx_document_submissions_created_at ON public.document_submissions(created_at);

-- =====================================================
-- FINANCIAL TABLES INDEXES
-- =====================================================

-- Loan applications table indexes
CREATE INDEX IF NOT EXISTS idx_loan_applications_user_id ON public.loan_applications(user_id);
CREATE INDEX IF NOT EXISTS idx_loan_applications_status ON public.loan_applications(status);
CREATE INDEX IF NOT EXISTS idx_loan_applications_created_at ON public.loan_applications(created_at);
CREATE INDEX IF NOT EXISTS idx_loan_applications_updated_at ON public.loan_applications(updated_at);
CREATE INDEX IF NOT EXISTS idx_loan_applications_loan_amount ON public.loan_applications(loan_amount);

-- Partner companies table indexes
CREATE INDEX IF NOT EXISTS idx_partner_companies_company_name ON public.partner_companies(company_name);
CREATE INDEX IF NOT EXISTS idx_partner_companies_registration_number ON public.partner_companies(company_registration_number);
CREATE INDEX IF NOT EXISTS idx_partner_companies_status ON public.partner_companies(status);
CREATE INDEX IF NOT EXISTS idx_partner_companies_partnership_status ON public.partner_companies(partnership_status);

-- RealPay transactions table indexes
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_user_id ON public.realpay_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_transaction_id ON public.realpay_transactions(transaction_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_status ON public.realpay_transactions(status);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_created_at ON public.realpay_transactions(created_at);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_amount ON public.realpay_transactions(amount);

-- Rates table indexes
CREATE INDEX IF NOT EXISTS idx_rates_rate_type ON public.rates(rate_type);
CREATE INDEX IF NOT EXISTS idx_rates_loan_product ON public.rates(loan_product);
CREATE INDEX IF NOT EXISTS idx_rates_effective_date ON public.rates(effective_date);
CREATE INDEX IF NOT EXISTS idx_rates_is_active ON public.rates(is_active);

-- Loan terms table indexes
CREATE INDEX IF NOT EXISTS idx_loan_terms_term_category ON public.loan_terms(term_category);
CREATE INDEX IF NOT EXISTS idx_loan_terms_loan_product ON public.loan_terms(loan_product);
CREATE INDEX IF NOT EXISTS idx_loan_terms_company_tier ON public.loan_terms(company_tier);

-- Collection schedules table indexes
CREATE INDEX IF NOT EXISTS idx_collection_schedules_user_id ON public.collection_schedules(user_id);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_status ON public.collection_schedules(status);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_due_date ON public.collection_schedules(due_date);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_created_at ON public.collection_schedules(created_at);

-- Financial reports table indexes
CREATE INDEX IF NOT EXISTS idx_financial_reports_report_type ON public.financial_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_financial_reports_generated_at ON public.financial_reports(generated_at);
CREATE INDEX IF NOT EXISTS idx_financial_reports_period_start ON public.financial_reports(period_start);
CREATE INDEX IF NOT EXISTS idx_financial_reports_period_end ON public.financial_reports(period_end);

-- Collection transactions table indexes
CREATE INDEX IF NOT EXISTS idx_collection_transactions_user_id ON public.collection_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_collection_transactions_schedule_id ON public.collection_transactions(schedule_id);
CREATE INDEX IF NOT EXISTS idx_collection_transactions_status ON public.collection_transactions(status);
CREATE INDEX IF NOT EXISTS idx_collection_transactions_created_at ON public.collection_transactions(created_at);

-- Employer reconciliations table indexes
CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_company_id ON public.employer_reconciliations(company_id);
CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_status ON public.employer_reconciliations(status);
CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_reconciliation_date ON public.employer_reconciliations(reconciliation_date);
CREATE INDEX IF NOT EXISTS idx_employer_reconciliations_created_at ON public.employer_reconciliations(created_at);

-- NAMFISA reports table indexes
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_report_type ON public.namfisa_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_submission_date ON public.namfisa_reports(submission_date);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_status ON public.namfisa_reports(status);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_created_at ON public.namfisa_reports(created_at);

-- Loan rates table indexes
CREATE INDEX IF NOT EXISTS idx_loan_rates_max_loan_amount ON public.loan_rates(max_loan_amount);
CREATE INDEX IF NOT EXISTS idx_loan_rates_max_loan_term ON public.loan_rates(max_loan_term);
CREATE INDEX IF NOT EXISTS idx_loan_rates_min_monthly_income ON public.loan_rates(min_monthly_income);
CREATE INDEX IF NOT EXISTS idx_loan_rates_namfisa_mls4_compliant ON public.loan_rates(namfisa_mls4_compliant);

-- Responsible lending policies table indexes
CREATE INDEX IF NOT EXISTS idx_responsible_lending_policies_policy_type ON public.responsible_lending_policies(policy_type);
CREATE INDEX IF NOT EXISTS idx_responsible_lending_policies_is_active ON public.responsible_lending_policies(is_active);

-- Affordability calculations table indexes
CREATE INDEX IF NOT EXISTS idx_affordability_calculations_user_id ON public.affordability_calculations(user_id);
CREATE INDEX IF NOT EXISTS idx_affordability_calculations_created_at ON public.affordability_calculations(created_at);

-- RealPay config table indexes
CREATE INDEX IF NOT EXISTS idx_realpay_config_merchant_id ON public.realpay_config(realpay_merchant_id);

-- Fee configurations table indexes
CREATE INDEX IF NOT EXISTS idx_fee_configurations_config_name ON public.fee_configurations(config_name);
CREATE INDEX IF NOT EXISTS idx_fee_configurations_is_active ON public.fee_configurations(is_active);
CREATE INDEX IF NOT EXISTS idx_fee_configurations_category_id ON public.fee_configurations(category_id);

-- Fee categories table indexes
CREATE INDEX IF NOT EXISTS idx_fee_categories_category_name ON public.fee_categories(category_name);
CREATE INDEX IF NOT EXISTS idx_fee_categories_is_active ON public.fee_categories(is_active);

-- User fee breakdown table indexes
CREATE INDEX IF NOT EXISTS idx_user_fee_breakdown_user_id ON public.user_fee_breakdown(user_id);
CREATE INDEX IF NOT EXISTS idx_user_fee_breakdown_loan_application_id ON public.user_fee_breakdown(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_user_fee_breakdown_created_at ON public.user_fee_breakdown(created_at);

-- Loan agreements table indexes
CREATE INDEX IF NOT EXISTS idx_loan_agreements_user_id ON public.loan_agreements(user_id);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_loan_application_id ON public.loan_agreements(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_status ON public.loan_agreements(status);
CREATE INDEX IF NOT EXISTS idx_loan_agreements_created_at ON public.loan_agreements(created_at);

-- =====================================================
-- AUDIT LOGGING TABLES INDEXES
-- =====================================================

-- Audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON public.audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_admin_user_id ON public.audit_logs(admin_user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON public.audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_table_name ON public.audit_logs(table_name);

-- User activity logs table indexes
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_user_id ON public.user_activity_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_activity_type ON public.user_activity_logs(activity_type);
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_created_at ON public.user_activity_logs(created_at);

-- System audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_system_audit_logs_system_component ON public.system_audit_logs(system_component);
CREATE INDEX IF NOT EXISTS idx_system_audit_logs_log_level ON public.system_audit_logs(log_level);
CREATE INDEX IF NOT EXISTS idx_system_audit_logs_created_at ON public.system_audit_logs(created_at);

-- Security audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_security_audit_logs_security_event ON public.security_audit_logs(security_event);
CREATE INDEX IF NOT EXISTS idx_security_audit_logs_severity ON public.security_audit_logs(severity);
CREATE INDEX IF NOT EXISTS idx_security_audit_logs_created_at ON public.security_audit_logs(created_at);

-- Financial audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_financial_audit_logs_user_id ON public.financial_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_financial_audit_logs_transaction_type ON public.financial_audit_logs(transaction_type);
CREATE INDEX IF NOT EXISTS idx_financial_audit_logs_created_at ON public.financial_audit_logs(created_at);

-- KYC audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_kyc_audit_logs_user_id ON public.kyc_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_kyc_audit_logs_verification_type ON public.kyc_audit_logs(verification_type);
CREATE INDEX IF NOT EXISTS idx_kyc_audit_logs_created_at ON public.kyc_audit_logs(created_at);

-- Loan audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_loan_audit_logs_user_id ON public.loan_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_loan_audit_logs_loan_application_id ON public.loan_audit_logs(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_loan_audit_logs_created_at ON public.loan_audit_logs(created_at);

-- Payment audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_payment_audit_logs_user_id ON public.payment_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_payment_audit_logs_transaction_id ON public.payment_audit_logs(transaction_id);
CREATE INDEX IF NOT EXISTS idx_payment_audit_logs_created_at ON public.payment_audit_logs(created_at);

-- Admin audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_admin_audit_logs_admin_user_id ON public.admin_audit_logs(admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_audit_logs_action ON public.admin_audit_logs(action);
CREATE INDEX IF NOT EXISTS idx_admin_audit_logs_created_at ON public.admin_audit_logs(created_at);

-- Compliance audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_compliance_audit_logs_compliance_type ON public.compliance_audit_logs(compliance_type);
CREATE INDEX IF NOT EXISTS idx_compliance_audit_logs_created_at ON public.compliance_audit_logs(created_at);

-- API audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_api_audit_logs_endpoint ON public.api_audit_logs(endpoint);
CREATE INDEX IF NOT EXISTS idx_api_audit_logs_method ON public.api_audit_logs(method);
CREATE INDEX IF NOT EXISTS idx_api_audit_logs_status_code ON public.api_audit_logs(status_code);
CREATE INDEX IF NOT EXISTS idx_api_audit_logs_created_at ON public.api_audit_logs(created_at);

-- Email audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_email_audit_logs_user_id ON public.email_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_email_audit_logs_email_type ON public.email_audit_logs(email_type);
CREATE INDEX IF NOT EXISTS idx_email_audit_logs_status ON public.email_audit_logs(status);
CREATE INDEX IF NOT EXISTS idx_email_audit_logs_created_at ON public.email_audit_logs(created_at);

-- SMS audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_sms_audit_logs_user_id ON public.sms_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_sms_audit_logs_sms_type ON public.sms_audit_logs(sms_type);
CREATE INDEX IF NOT EXISTS idx_sms_audit_logs_status ON public.sms_audit_logs(status);
CREATE INDEX IF NOT EXISTS idx_sms_audit_logs_created_at ON public.sms_audit_logs(created_at);

-- WhatsApp audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_whatsapp_audit_logs_user_id ON public.whatsapp_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_whatsapp_audit_logs_message_type ON public.whatsapp_audit_logs(message_type);
CREATE INDEX IF NOT EXISTS idx_whatsapp_audit_logs_status ON public.whatsapp_audit_logs(status);
CREATE INDEX IF NOT EXISTS idx_whatsapp_audit_logs_created_at ON public.whatsapp_audit_logs(created_at);

-- Document audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_document_audit_logs_user_id ON public.document_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_document_audit_logs_document_type ON public.document_audit_logs(document_type);
CREATE INDEX IF NOT EXISTS idx_document_audit_logs_created_at ON public.document_audit_logs(created_at);

-- Verification audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_verification_audit_logs_user_id ON public.verification_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_verification_audit_logs_verification_type ON public.verification_audit_logs(verification_type);
CREATE INDEX IF NOT EXISTS idx_verification_audit_logs_created_at ON public.verification_audit_logs(created_at);

-- Rate audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_rate_audit_logs_rate_type ON public.rate_audit_logs(rate_type);
CREATE INDEX IF NOT EXISTS idx_rate_audit_logs_created_at ON public.rate_audit_logs(created_at);

-- Config audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_config_audit_logs_config_key ON public.config_audit_logs(config_key);
CREATE INDEX IF NOT EXISTS idx_config_audit_logs_created_at ON public.config_audit_logs(created_at);

-- Session audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_session_audit_logs_user_id ON public.session_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_session_audit_logs_session_id ON public.session_audit_logs(session_id);
CREATE INDEX IF NOT EXISTS idx_session_audit_logs_created_at ON public.session_audit_logs(created_at);

-- Login audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_login_audit_logs_user_id ON public.login_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_login_audit_logs_login_method ON public.login_audit_logs(login_method);
CREATE INDEX IF NOT EXISTS idx_login_audit_logs_created_at ON public.login_audit_logs(created_at);

-- Permission audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_permission_audit_logs_user_id ON public.permission_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_permission_audit_logs_permission_id ON public.permission_audit_logs(permission_id);
CREATE INDEX IF NOT EXISTS idx_permission_audit_logs_created_at ON public.permission_audit_logs(created_at);

-- Role audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_role_audit_logs_user_id ON public.role_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_role_audit_logs_role_id ON public.role_audit_logs(role_id);
CREATE INDEX IF NOT EXISTS idx_role_audit_logs_created_at ON public.role_audit_logs(created_at);

-- Company audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_company_audit_logs_company_id ON public.company_audit_logs(company_id);
CREATE INDEX IF NOT EXISTS idx_company_audit_logs_created_at ON public.company_audit_logs(created_at);

-- Partner audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_partner_audit_logs_partner_id ON public.partner_audit_logs(partner_id);
CREATE INDEX IF NOT EXISTS idx_partner_audit_logs_created_at ON public.partner_audit_logs(created_at);

-- RealPay audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_realpay_audit_logs_transaction_id ON public.realpay_audit_logs(transaction_id);
CREATE INDEX IF NOT EXISTS idx_realpay_audit_logs_created_at ON public.realpay_audit_logs(created_at);

-- NAMFISA audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_namfisa_audit_logs_report_type ON public.namfisa_audit_logs(report_type);
CREATE INDEX IF NOT EXISTS idx_namfisa_audit_logs_created_at ON public.namfisa_audit_logs(created_at);

-- AML audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_aml_audit_logs_aml_type ON public.aml_audit_logs(aml_type);
CREATE INDEX IF NOT EXISTS idx_aml_audit_logs_created_at ON public.aml_audit_logs(created_at);

-- KYC AML audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_kyc_aml_audit_logs_user_id ON public.kyc_aml_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_kyc_aml_audit_logs_created_at ON public.kyc_aml_audit_logs(created_at);

-- Risk assessment audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_risk_assessment_audit_logs_user_id ON public.risk_assessment_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_risk_assessment_audit_logs_created_at ON public.risk_assessment_audit_logs(created_at);

-- Credit check audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_credit_check_audit_logs_user_id ON public.credit_check_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_credit_check_audit_logs_created_at ON public.credit_check_audit_logs(created_at);

-- Affordability audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_affordability_audit_logs_user_id ON public.affordability_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_affordability_audit_logs_created_at ON public.affordability_audit_logs(created_at);

-- Collection audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_collection_audit_logs_user_id ON public.collection_audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_collection_audit_logs_created_at ON public.collection_audit_logs(created_at);

-- Reconciliation audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_reconciliation_audit_logs_company_id ON public.reconciliation_audit_logs(company_id);
CREATE INDEX IF NOT EXISTS idx_reconciliation_audit_logs_created_at ON public.reconciliation_audit_logs(created_at);

-- Report audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_report_audit_logs_report_type ON public.report_audit_logs(report_type);
CREATE INDEX IF NOT EXISTS idx_report_audit_logs_created_at ON public.report_audit_logs(created_at);

-- Analytics audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_analytics_audit_logs_analytics_type ON public.analytics_audit_logs(analytics_type);
CREATE INDEX IF NOT EXISTS idx_analytics_audit_logs_created_at ON public.analytics_audit_logs(created_at);

-- Metrics audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_metrics_audit_logs_metric_type ON public.metrics_audit_logs(metric_type);
CREATE INDEX IF NOT EXISTS idx_metrics_audit_logs_created_at ON public.metrics_audit_logs(created_at);

-- Performance audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_performance_audit_logs_performance_type ON public.performance_audit_logs(performance_type);
CREATE INDEX IF NOT EXISTS idx_performance_audit_logs_created_at ON public.performance_audit_logs(created_at);

-- Error audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_error_audit_logs_error_type ON public.error_audit_logs(error_type);
CREATE INDEX IF NOT EXISTS idx_error_audit_logs_created_at ON public.error_audit_logs(created_at);

-- Exception audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_exception_audit_logs_exception_type ON public.exception_audit_logs(exception_type);
CREATE INDEX IF NOT EXISTS idx_exception_audit_logs_created_at ON public.exception_audit_logs(created_at);

-- Incident audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_incident_audit_logs_incident_type ON public.incident_audit_logs(incident_type);
CREATE INDEX IF NOT EXISTS idx_incident_audit_logs_created_at ON public.incident_audit_logs(created_at);

-- Breach audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_breach_audit_logs_breach_type ON public.breach_audit_logs(breach_type);
CREATE INDEX IF NOT EXISTS idx_breach_audit_logs_created_at ON public.breach_audit_logs(created_at);

-- Vulnerability audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_vulnerability_audit_logs_vulnerability_type ON public.vulnerability_audit_logs(vulnerability_type);
CREATE INDEX IF NOT EXISTS idx_vulnerability_audit_logs_created_at ON public.vulnerability_audit_logs(created_at);

-- Threat audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_threat_audit_logs_threat_type ON public.threat_audit_logs(threat_type);
CREATE INDEX IF NOT EXISTS idx_threat_audit_logs_created_at ON public.threat_audit_logs(created_at);

-- Audit retention policies table indexes
CREATE INDEX IF NOT EXISTS idx_audit_retention_policies_table_name ON public.audit_retention_policies(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_retention_policies_is_active ON public.audit_retention_policies(is_active);

-- Audit archival logs table indexes
CREATE INDEX IF NOT EXISTS idx_audit_archival_logs_table_name ON public.audit_archival_logs(table_name);
CREATE INDEX IF NOT EXISTS idx_audit_archival_logs_archived_at ON public.audit_archival_logs(archived_at);

-- Audit retention audit logs table indexes
CREATE INDEX IF NOT EXISTS idx_audit_retention_audit_logs_policy_id ON public.audit_retention_audit_logs(policy_id);
CREATE INDEX IF NOT EXISTS idx_audit_retention_audit_logs_created_at ON public.audit_retention_audit_logs(created_at);

-- =====================================================
-- COMPOSITE INDEXES FOR COMMON QUERIES
-- =====================================================

-- User-related composite indexes
CREATE INDEX IF NOT EXISTS idx_profiles_user_id_created_at ON public.profiles(user_id, created_at);
CREATE INDEX IF NOT EXISTS idx_loan_applications_user_id_status ON public.loan_applications(user_id, status);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_user_id_status ON public.kyc_verifications(user_id, status);
CREATE INDEX IF NOT EXISTS idx_employee_verifications_user_id_company_id ON public.employee_verifications(user_id, company_id);

-- Date range composite indexes
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at_action ON public.audit_logs(created_at, action);
CREATE INDEX IF NOT EXISTS idx_financial_reports_period_start_period_end ON public.financial_reports(period_start, period_end);
CREATE INDEX IF NOT EXISTS idx_collection_schedules_due_date_status ON public.collection_schedules(due_date, status);

-- Status-based composite indexes
CREATE INDEX IF NOT EXISTS idx_loan_applications_status_created_at ON public.loan_applications(status, created_at);
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_status_created_at ON public.kyc_verifications(status, created_at);
CREATE INDEX IF NOT EXISTS idx_partner_companies_status_partnership_status ON public.partner_companies(status, partnership_status);

-- =====================================================
-- PARTIAL INDEXES FOR PERFORMANCE
-- =====================================================

-- Active records only
CREATE INDEX IF NOT EXISTS idx_profiles_active ON public.profiles(user_id) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_admin_users_active ON public.admin_users(id) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_companies_active ON public.companies(id) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_partner_companies_active ON public.partner_companies(id) WHERE status = 'active';

-- Recent records only (last 30 days)
CREATE INDEX IF NOT EXISTS idx_audit_logs_recent ON public.audit_logs(created_at, user_id) WHERE created_at >= CURRENT_DATE - INTERVAL '30 days';
CREATE INDEX IF NOT EXISTS idx_loan_applications_recent ON public.loan_applications(created_at, user_id) WHERE created_at >= CURRENT_DATE - INTERVAL '30 days';
CREATE INDEX IF NOT EXISTS idx_kyc_verifications_recent ON public.kyc_verifications(created_at, user_id) WHERE created_at >= CURRENT_DATE - INTERVAL '30 days';

-- High-value transactions only
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_high_value ON public.realpay_transactions(amount, created_at) WHERE amount >= 1000.00;
CREATE INDEX IF NOT EXISTS idx_loan_applications_high_value ON public.loan_applications(loan_amount, created_at) WHERE loan_amount >= 5000.00;

-- =====================================================
-- TEXT SEARCH INDEXES
-- =====================================================

-- Full-text search indexes for searchable content
CREATE INDEX IF NOT EXISTS idx_profiles_fulltext ON public.profiles USING gin(to_tsvector('english', first_name || ' ' || last_name || ' ' || COALESCE(phone_number, '') || ' ' || COALESCE(id_number, '')));
CREATE INDEX IF NOT EXISTS idx_companies_fulltext ON public.companies USING gin(to_tsvector('english', company_name || ' ' || COALESCE(registration_number, '') || ' ' || COALESCE(description, '')));
CREATE INDEX IF NOT EXISTS idx_partner_companies_fulltext ON public.partner_companies USING gin(to_tsvector('english', company_name || ' ' || COALESCE(company_registration_number, '') || ' ' || COALESCE(description, '')));

-- =====================================================
-- UNIQUE INDEXES FOR DATA INTEGRITY
-- =====================================================

-- Ensure unique constraints
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_user_id_unique ON public.profiles(user_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_phone_number_unique ON public.profiles(phone_number) WHERE phone_number IS NOT NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_profiles_id_number_unique ON public.profiles(id_number) WHERE id_number IS NOT NULL;
CREATE UNIQUE INDEX IF NOT EXISTS idx_admin_users_email_unique ON public.admin_users(email);
CREATE UNIQUE INDEX IF NOT EXISTS idx_companies_registration_number_unique ON public.companies(registration_number);
CREATE UNIQUE INDEX IF NOT EXISTS idx_partner_companies_registration_number_unique ON public.partner_companies(company_registration_number);
CREATE UNIQUE INDEX IF NOT EXISTS idx_realpay_transactions_transaction_id_unique ON public.realpay_transactions(transaction_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_fee_configurations_config_name_unique ON public.fee_configurations(config_name);
CREATE UNIQUE INDEX IF NOT EXISTS idx_fee_categories_category_name_unique ON public.fee_categories(category_name);

-- Add comments for documentation
COMMENT ON INDEX idx_profiles_user_id IS 'Index on user_id for fast profile lookups';
COMMENT ON INDEX idx_loan_applications_user_id_status IS 'Composite index on user_id and status for loan application queries';
COMMENT ON INDEX idx_audit_logs_created_at_action IS 'Composite index on created_at and action for audit log queries';
COMMENT ON INDEX idx_profiles_fulltext IS 'Full-text search index for profile search functionality';
COMMENT ON INDEX idx_profiles_active IS 'Partial index for active profiles only';
COMMENT ON INDEX idx_audit_logs_recent IS 'Partial index for recent audit logs (last 30 days)';
\n-- End of buffrlend-starter/supabase/migrations/11_database_indexes.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/supabase/migrations/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/012_create_unified_vector_search.sql --\n
-- =====================================================
-- BuffrLend Financial Tables RLS Policies Migration
-- =====================================================
-- Description: Creates Row Level Security policies for financial tables
-- Dependencies: 04_financial_tables.sql, 05_core_rls_policies.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- Enable RLS on financial tables
ALTER TABLE public.realpay_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collection_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collection_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.employer_reconciliations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.loan_rates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.loan_terms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.fee_configurations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_fee_breakdown ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.affordability_calculations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.responsible_lending_policies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.realpay_config ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- REALPAY_TRANSACTIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own transactions
CREATE POLICY "Users can view own transactions" ON public.realpay_transactions
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all transactions
CREATE POLICY "Admins can view all transactions" ON public.realpay_transactions
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- System can insert transactions (handled by functions)
CREATE POLICY "System can insert transactions" ON public.realpay_transactions
    FOR INSERT WITH CHECK (true);

-- Admins can update transactions
CREATE POLICY "Admins can update transactions" ON public.realpay_transactions
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- =====================================================
-- COLLECTION_SCHEDULES TABLE RLS POLICIES
-- =====================================================

-- Users can view schedules for their loans
CREATE POLICY "Users can view own loan schedules" ON public.collection_schedules
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.loan_applications la
            WHERE la.id = loan_application_id
            AND la.user_id = auth.uid()
        )
    );

-- Admins can view all schedules
CREATE POLICY "Admins can view all schedules" ON public.collection_schedules
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can insert schedules
CREATE POLICY "Admins can insert schedules" ON public.collection_schedules
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update schedules
CREATE POLICY "Admins can update schedules" ON public.collection_schedules
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Company managers can view schedules for their company
CREATE POLICY "Company managers can view company schedules" ON public.collection_schedules
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            JOIN public.partner_companies pc ON pc.id = company_id
            WHERE up.id = auth.uid()
            AND up.user_role = 'enterprise_user'::user_role_enum -- Assuming company manager is an enterprise user
        )
    );

-- =====================================================
-- COLLECTION_TRANSACTIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view transactions for their loans
CREATE POLICY "Users can view own loan transactions" ON public.collection_transactions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.loan_applications la
            WHERE la.id = loan_application_id
            AND la.user_id = auth.uid()
        )
    );

-- Admins can view all transactions
CREATE POLICY "Admins can view all collection transactions" ON public.collection_transactions
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- System can insert transactions (handled by functions)
CREATE POLICY "System can insert collection transactions" ON public.collection_transactions
    FOR INSERT WITH CHECK (true);

-- Admins can update transactions
CREATE POLICY "Admins can update collection transactions" ON public.collection_transactions
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- =====================================================
-- EMPLOYER_RECONCILIATIONS TABLE RLS POLICIES
-- =====================================================

-- Admins can view all reconciliations
CREATE POLICY "Admins can view all reconciliations" ON public.employer_reconciliations
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can insert reconciliations
CREATE POLICY "Admins can insert reconciliations" ON public.employer_reconciliations
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Admins can update reconciliations
CREATE POLICY "Admins can update reconciliations" ON public.employer_reconciliations
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Company managers can view their company reconciliations
CREATE POLICY "Company managers can view company reconciliations" ON public.employer_reconciliations
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.profiles up
            JOIN public.partner_companies pc ON pc.id = employer_id
            WHERE up.id = auth.uid()
            AND up.user_role = 'enterprise_user'::user_role_enum -- Assuming company manager is an enterprise user
        )
    );

-- =====================================================
-- LOAN_RATES TABLE RLS POLICIES
-- =====================================================

-- Public can view current loan rates (for transparency)
CREATE POLICY "Public can view loan rates" ON public.loan_rates
    FOR SELECT USING (true);

-- Super admins can update loan rates
CREATE POLICY "Super admins can update loan rates" ON public.loan_rates
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- RATES TABLE RLS POLICIES
-- =====================================================

-- Public can view active rates
CREATE POLICY "Public can view active rates" ON public.rates
    FOR SELECT USING (is_active = true);

-- Admins can view all rates
CREATE POLICY "Admins can view all rates" ON public.rates
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Super admins can insert rates
CREATE POLICY "Super admins can insert rates" ON public.rates
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- Super admins can update rates
CREATE POLICY "Super admins can update rates" ON public.rates
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- LOAN_TERMS TABLE RLS POLICIES
-- =====================================================

-- Public can view active loan terms
CREATE POLICY "Public can view active loan terms" ON public.loan_terms
    FOR SELECT USING (is_active = true);

-- Admins can view all loan terms
CREATE POLICY "Admins can view all loan terms" ON public.loan_terms
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Super admins can insert loan terms
CREATE POLICY "Super admins can insert loan terms" ON public.loan_terms
    FOR INSERT WITH CHECK (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- Super admins can update loan terms
CREATE POLICY "Super admins can update loan terms" ON public.loan_terms
    FOR UPDATE USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- FEE_CATEGORIES TABLE RLS POLICIES
-- =====================================================

-- Public can view active fee categories
CREATE POLICY "Public can view active fee categories" ON public.fee_categories
    FOR SELECT USING (is_active = true);

-- Admins can view all fee categories
CREATE POLICY "Admins can view all fee categories" ON public.fee_categories
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Super admins can manage fee categories
CREATE POLICY "Super admins can manage fee categories" ON public.fee_categories
    FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- FEE_CONFIGURATIONS TABLE RLS POLICIES
-- =====================================================

-- Public can view active fee configurations
CREATE POLICY "Public can view active fee configurations" ON public.fee_configurations
    FOR SELECT USING (is_active = true);

-- Admins can view all fee configurations
CREATE POLICY "Admins can view all fee configurations" ON public.fee_configurations
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Super admins can manage fee configurations
CREATE POLICY "Super admins can manage fee configurations" ON public.fee_configurations
    FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- USER_FEE_BREAKDOWN TABLE RLS POLICIES
-- =====================================================

-- Users can view their own fee breakdowns
CREATE POLICY "Users can view own fee breakdowns" ON public.user_fee_breakdown
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.loan_applications la
            WHERE la.id = loan_application_id
            AND la.user_id = auth.uid()
        )
    );

-- Admins can view all fee breakdowns
CREATE POLICY "Admins can view all fee breakdowns" ON public.user_fee_breakdown
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- System can insert fee breakdowns (handled by functions)
CREATE POLICY "System can insert fee breakdowns" ON public.user_fee_breakdown
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- AFFORDABILITY_CALCULATIONS TABLE RLS POLICIES
-- =====================================================

-- Users can view their own affordability calculations
CREATE POLICY "Users can view own affordability calculations" ON public.affordability_calculations
    FOR SELECT USING (auth.uid() = user_id);

-- Admins can view all affordability calculations
CREATE POLICY "Admins can view all affordability calculations" ON public.affordability_calculations
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- System can insert affordability calculations (handled by functions)
CREATE POLICY "System can insert affordability calculations" ON public.affordability_calculations
    FOR INSERT WITH CHECK (true);

-- =====================================================
-- RESPONSIBLE_LENDING_POLICIES TABLE RLS POLICIES
-- =====================================================

-- Public can view active policies
CREATE POLICY "Public can view active policies" ON public.responsible_lending_policies
    FOR SELECT USING (is_active = true);

-- Admins can view all policies
CREATE POLICY "Admins can view all policies" ON public.responsible_lending_policies
    FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'admin'::user_role_enum));

-- Super admins can manage policies
CREATE POLICY "Super admins can manage policies" ON public.responsible_lending_policies
    FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));

-- =====================================================
-- REALPAY_CONFIG TABLE RLS POLICIES
-- =====================================================

-- Super admins can view and manage RealPay config
CREATE POLICY "Super admins can manage RealPay config" ON public.realpay_config
    FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles up WHERE up.id = auth.uid() AND up.user_role = 'super_admin'::user_role_enum));


\n-- End of buffrlend-starter/supabase/migrations/07_financial_rls_policies.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/011_create_unified_file_management.sql --\n
-- RLS Policies for Integration Tables
-- RealPay, NAMFISA, and Adumo integration security policies

-- Enable RLS on integration tables
ALTER TABLE realpay_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE realpay_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE namfisa_compliance ENABLE ROW LEVEL SECURITY;
ALTER TABLE namfisa_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE namfisa_compliance_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE namfisa_audit_trail ENABLE ROW LEVEL SECURITY;
ALTER TABLE adumo_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE adumo_credit_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE adumo_risk_assessments ENABLE ROW LEVEL SECURITY;
ALTER TABLE adumo_api_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE adumo_webhook_events ENABLE ROW LEVEL SECURITY;

-- RealPay RLS Policies
CREATE POLICY "Admins can manage RealPay config" ON realpay_config
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "Users can view their own RealPay transactions" ON realpay_transactions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM loan_applications 
            WHERE loan_applications.id = realpay_transactions.loan_application_id 
            AND loan_applications.user_id = auth.uid()
        )
    );

CREATE POLICY "Admins can view all RealPay transactions" ON realpay_transactions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can insert RealPay transactions" ON realpay_transactions
    FOR INSERT WITH CHECK (true);

CREATE POLICY "System can update RealPay transactions" ON realpay_transactions
    FOR UPDATE USING (true);

-- NAMFISA RLS Policies
CREATE POLICY "Admins can manage NAMFISA compliance" ON namfisa_compliance
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "Admins can manage NAMFISA reports" ON namfisa_reports
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "Users can view their own compliance tracking" ON namfisa_compliance_tracking
    FOR SELECT USING (
        customer_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM loan_applications 
            WHERE loan_applications.id = namfisa_compliance_tracking.loan_application_id 
            AND loan_applications.user_id = auth.uid()
        )
    );

CREATE POLICY "Admins can manage compliance tracking" ON namfisa_compliance_tracking
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "Admins can view audit trail" ON namfisa_audit_trail
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can insert audit trail" ON namfisa_audit_trail
    FOR INSERT WITH CHECK (true);

-- Adumo RLS Policies
CREATE POLICY "Admins can manage Adumo config" ON adumo_config
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "Users can view their own credit scores" ON adumo_credit_scores
    FOR SELECT USING (
        customer_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM loan_applications 
            WHERE loan_applications.id = adumo_credit_scores.loan_application_id 
            AND loan_applications.user_id = auth.uid()
        )
    );

CREATE POLICY "Admins can view all credit scores" ON adumo_credit_scores
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can manage credit scores" ON adumo_credit_scores
    FOR ALL USING (true);

CREATE POLICY "Users can view their own risk assessments" ON adumo_risk_assessments
    FOR SELECT USING (
        customer_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM loan_applications 
            WHERE loan_applications.id = adumo_risk_assessments.loan_application_id 
            AND loan_applications.user_id = auth.uid()
        )
    );

CREATE POLICY "Admins can view all risk assessments" ON adumo_risk_assessments
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can manage risk assessments" ON adumo_risk_assessments
    FOR ALL USING (true);

CREATE POLICY "Admins can view API logs" ON adumo_api_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can insert API logs" ON adumo_api_logs
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Admins can view webhook events" ON adumo_webhook_events
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid()
        )
    );

CREATE POLICY "System can manage webhook events" ON adumo_webhook_events
    FOR ALL USING (true);

-- Public access for specific integration endpoints
CREATE POLICY "Public can access RealPay webhooks" ON realpay_transactions
    FOR UPDATE USING (true);

CREATE POLICY "Public can access Adumo webhooks" ON adumo_webhook_events
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Public can access NAMFISA webhooks" ON namfisa_audit_trail
    FOR INSERT WITH CHECK (true);
\n-- End of buffrlend-starter/supabase/migrations/29_integration_rls_policies.sql --\n
-- RealPay Integration Migration
-- Creates tables for RealPay payment processing integration

-- RealPay Configuration Table
CREATE TABLE IF NOT EXISTS realpay_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    config_name VARCHAR(100) NOT NULL UNIQUE,
    api_endpoint VARCHAR(255) NOT NULL,
    api_key VARCHAR(255) NOT NULL,
    merchant_id VARCHAR(100) NOT NULL,
    environment VARCHAR(20) NOT NULL DEFAULT 'sandbox' CHECK (environment IN ('sandbox', 'production')),
    webhook_url VARCHAR(255),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- RealPay Transactions Table
CREATE TABLE IF NOT EXISTS realpay_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    transaction_id VARCHAR(100) NOT NULL UNIQUE,
    loan_application_id UUID REFERENCES loan_applications(id),
    amount DECIMAL(15,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'NAD',
    payment_method VARCHAR(50) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled')),
    realpay_reference VARCHAR(100),
    customer_reference VARCHAR(100),
    description TEXT,
    metadata JSONB,
    processed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- RealPay Fee Summary View
CREATE OR REPLACE VIEW realpay_fee_summary AS
SELECT 
    DATE_TRUNC('month', created_at) as month,
    COUNT(*) as total_transactions,
    SUM(amount) as total_amount,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful_transactions,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_transactions,
    ROUND(
        (COUNT(CASE WHEN status = 'completed' THEN 1 END)::DECIMAL / COUNT(*)) * 100, 
        2
    ) as success_rate
FROM realpay_transactions
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month DESC;

-- Indexes for RealPay tables
CREATE INDEX IF NOT EXISTS idx_realpay_config_active ON realpay_config(is_active);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_status ON realpay_transactions(status);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_loan_app ON realpay_transactions(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_realpay_transactions_created_at ON realpay_transactions(created_at);

-- RealPay Functions
CREATE OR REPLACE FUNCTION process_realpay_transaction(
    p_loan_application_id UUID,
    p_amount DECIMAL,
    p_payment_method VARCHAR,
    p_description TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
    v_transaction_id UUID;
    v_transaction_reference VARCHAR;
BEGIN
    -- Generate transaction reference
    v_transaction_reference := 'RP' || EXTRACT(EPOCH FROM NOW())::BIGINT;
    
    -- Insert transaction record
    INSERT INTO realpay_transactions (
        loan_application_id,
        amount,
        payment_method,
        description,
        transaction_id
    ) VALUES (
        p_loan_application_id,
        p_amount,
        p_payment_method,
        p_description,
        v_transaction_reference
    ) RETURNING id INTO v_transaction_id;
    
    RETURN v_transaction_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RealPay Webhook Processing Function
CREATE OR REPLACE FUNCTION process_realpay_webhook(
    p_transaction_id VARCHAR,
    p_status VARCHAR,
    p_realpay_reference VARCHAR DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL
) RETURNS BOOLEAN AS $$
BEGIN
    UPDATE realpay_transactions 
    SET 
        status = p_status,
        realpay_reference = p_realpay_reference,
        metadata = COALESCE(p_metadata, metadata),
        processed_at = CASE WHEN p_status = 'completed' THEN NOW() ELSE processed_at END,
        updated_at = NOW()
    WHERE transaction_id = p_transaction_id;
    
    RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RealPay Analytics Function
CREATE OR REPLACE FUNCTION get_realpay_analytics(
    p_start_date DATE DEFAULT NULL,
    p_end_date DATE DEFAULT NULL
) RETURNS TABLE (
    total_transactions BIGINT,
    total_amount DECIMAL,
    successful_transactions BIGINT,
    failed_transactions BIGINT,
    success_rate DECIMAL
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*) as total_transactions,
        COALESCE(SUM(amount), 0) as total_amount,
        COUNT(CASE WHEN status = 'completed' THEN 1 END) as successful_transactions,
        COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_transactions,
        CASE 
            WHEN COUNT(*) > 0 THEN 
                ROUND((COUNT(CASE WHEN status = 'completed' THEN 1 END)::DECIMAL / COUNT(*)) * 100, 2)
            ELSE 0 
        END as success_rate
    FROM realpay_transactions
    WHERE 
        (p_start_date IS NULL OR created_at >= p_start_date)
        AND (p_end_date IS NULL OR created_at <= p_end_date);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Triggers for RealPay tables
CREATE TRIGGER update_realpay_config_updated_at
    BEFORE UPDATE ON realpay_config
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_transactions_updated_at
    BEFORE UPDATE ON realpay_transactions
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Sample RealPay configuration
INSERT INTO realpay_config (
    config_name,
    api_endpoint,
    api_key,
    merchant_id,
    environment,
    webhook_url,
    is_active
) VALUES (
    'BuffrLend Production',
    'https://api.realpay.com/v1',
    'your-api-key-here',
    'BUFFR001',
    'sandbox',
    'https://lend.buffr.ai/api/webhooks/realpay',
    true
) ON CONFLICT (config_name) DO NOTHING;\n-- End of buffrlend-starter/supabase/migrations/26_realpay_integration.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/supabase/migrations/07_unified_evaluations.sql --\n
-- =====================================================
-- BuffrLend Audit Logging Tables Migration
-- =====================================================
-- Description: Creates audit logging and compliance tables
-- Dependencies: 02_core_tables.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================



-- Create namfisa_compliance table
CREATE TABLE IF NOT EXISTS public.namfisa_compliance (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    license_number TEXT UNIQUE,
    license_type TEXT DEFAULT 'fintech_sandbox' CHECK (license_type IN ('fintech_sandbox', 'money_lending', 'payment_services', 'full_banking')),
    license_status TEXT DEFAULT 'application_submitted' CHECK (license_status IN ('application_submitted', 'under_review', 'approved', 'conditional', 'suspended', 'revoked')),
    application_date DATE,
    approval_date DATE,
    expiry_date DATE,
    renewal_due_date DATE,
    sandbox_phase TEXT DEFAULT 'phase_1' CHECK (sandbox_phase IN ('phase_1', 'phase_2', 'phase_3', 'graduated')),
    sandbox_conditions JSONB DEFAULT '[]',
    sandbox_metrics JSONB DEFAULT '{}',
    capital_requirement NUMERIC,
    current_capital NUMERIC,
    capital_adequacy_ratio NUMERIC,
    monthly_reporting_enabled BOOLEAN DEFAULT TRUE,
    quarterly_reporting_enabled BOOLEAN DEFAULT TRUE,
    annual_reporting_enabled BOOLEAN DEFAULT TRUE,
    last_monthly_report_date DATE,
    last_quarterly_report_date DATE,
    last_annual_report_date DATE,
    risk_management_framework TEXT,
    aml_policy_document TEXT,
    kyc_policy_document TEXT,
    data_protection_policy TEXT,
    max_customers INTEGER DEFAULT 1000,
    max_transaction_amount NUMERIC DEFAULT 50000.00,
    max_monthly_volume NUMERIC DEFAULT 1000000.00,
    current_customer_count INTEGER DEFAULT 0,
    current_monthly_volume NUMERIC DEFAULT 0.00,
    aml_compliance_status TEXT DEFAULT 'under_review' CHECK (aml_compliance_status IN ('compliant', 'non_compliant', 'under_review')),
    kyc_compliance_status TEXT DEFAULT 'under_review' CHECK (kyc_compliance_status IN ('compliant', 'non_compliant', 'under_review')),
    data_protection_status TEXT DEFAULT 'under_review' CHECK (data_protection_status IN ('compliant', 'non_compliant', 'under_review')),
    last_audit_date DATE,
    next_audit_date DATE,
    audit_findings JSONB DEFAULT '[]',
    corrective_actions JSONB DEFAULT '[]',
    compliance_officer_name TEXT,
    compliance_officer_email TEXT,
    compliance_officer_phone TEXT,
    license_certificate_path TEXT,
    compliance_certificates JSONB DEFAULT '[]',
    regulatory_correspondence JSONB DEFAULT '[]',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    updated_by UUID REFERENCES public.unified_profiles(id)
);

-- Create financial_reports table
CREATE TABLE IF NOT EXISTS public.financial_reports (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    report_type TEXT NOT NULL CHECK (report_type IN ('daily_disbursements', 'monthly_portfolio', 'quarterly_namfisa', 'annual_audit', 'risk_analysis')),
    report_name TEXT NOT NULL,
    report_period_start DATE NOT NULL,
    report_period_end DATE NOT NULL,
    report_data JSONB NOT NULL,
    report_summary JSONB,
    report_file_path TEXT,
    generated_by UUID REFERENCES public.unified_profiles(id),
    reviewed_by UUID REFERENCES public.unified_profiles(id),
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'generated', 'reviewed', 'submitted', 'approved')),
    submitted_to TEXT,
    submission_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create namfisa_reports table
CREATE TABLE IF NOT EXISTS public.namfisa_reports (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    report_type TEXT NOT NULL CHECK (report_type IN ('monthly', 'quarterly', 'annual', 'audit', 'compliance')),
    reporting_period TEXT NOT NULL,
    due_date DATE,
    submission_date DATE,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'draft', 'submitted', 'approved', 'rejected')),
    report_data JSONB DEFAULT '{}',
    file_path TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create notifications table
CREATE TABLE IF NOT EXISTS public.notifications (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    admin_id UUID REFERENCES public.unified_profiles(id),
    title TEXT NOT NULL,
    message TEXT NOT NULL,
    type TEXT DEFAULT 'info' CHECK (type IN ('info', 'success', 'warning', 'error', 'kyc_review', 'loan_update', 'system_alert', 'job_application', 'partnership_request')),
    priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
    sent_via_email BOOLEAN DEFAULT FALSE,
    sent_via_whatsapp BOOLEAN DEFAULT FALSE,
    sent_via_sms BOOLEAN DEFAULT FALSE,
    sent_via_dashboard BOOLEAN DEFAULT TRUE,
    related_entity_type TEXT,
    related_entity_id TEXT,
    related_application_id TEXT,
    related_company_id UUID REFERENCES public.partner_companies(id),
    action_required BOOLEAN DEFAULT FALSE,
    action_url TEXT,
    expires_at TIMESTAMPTZ,
    read_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance


CREATE INDEX IF NOT EXISTS idx_namfisa_compliance_license_number ON public.namfisa_compliance(license_number);
CREATE INDEX IF NOT EXISTS idx_namfisa_compliance_status ON public.namfisa_compliance(license_status);
CREATE INDEX IF NOT EXISTS idx_namfisa_compliance_expiry_date ON public.namfisa_compliance(expiry_date);

CREATE INDEX IF NOT EXISTS idx_financial_reports_type ON public.financial_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_financial_reports_period_start ON public.financial_reports(report_period_start);
CREATE INDEX IF NOT EXISTS idx_financial_reports_status ON public.financial_reports(status);
CREATE INDEX IF NOT EXISTS idx_financial_reports_generated_by ON public.financial_reports(generated_by);

CREATE INDEX IF NOT EXISTS idx_namfisa_reports_type ON public.namfisa_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_period ON public.namfisa_reports(reporting_period);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_status ON public.namfisa_reports(status);

CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON public.notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_admin_id ON public.notifications(admin_id);
CREATE INDEX IF NOT EXISTS idx_notifications_type ON public.notifications(type);
CREATE INDEX IF NOT EXISTS idx_notifications_priority ON public.notifications(priority);
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON public.notifications(created_at);
CREATE INDEX IF NOT EXISTS idx_notifications_read_at ON public.notifications(read_at);

-- Add table comments

COMMENT ON TABLE public.namfisa_compliance IS 'NAMFISA regulatory compliance tracking and status';
COMMENT ON TABLE public.financial_reports IS 'Financial reports for regulatory compliance';
COMMENT ON TABLE public.namfisa_reports IS 'NAMFISA specific regulatory reports';
COMMENT ON TABLE public.notifications IS 'User and admin notifications across all channels';

-- Apply updated_at triggers
CREATE TRIGGER update_namfisa_compliance_updated_at
    BEFORE UPDATE ON public.namfisa_compliance
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_financial_reports_updated_at
    BEFORE UPDATE ON public.financial_reports
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_namfisa_reports_updated_at
    BEFORE UPDATE ON public.namfisa_reports
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/08_audit_logging_tables.sql --\n
-- Email Campaign Management
-- This migration creates tables for managing email campaigns, automation, and marketing

-- Email Campaigns
CREATE TABLE IF NOT EXISTS email_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id TEXT NOT NULL UNIQUE,
    campaign_name TEXT NOT NULL,
    campaign_type TEXT NOT NULL CHECK (campaign_type IN ('transactional', 'marketing', 'automated', 'triggered')),
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'sending', 'sent', 'paused', 'cancelled', 'completed')),
    subject TEXT NOT NULL,
    from_email TEXT NOT NULL,
    from_name TEXT NOT NULL,
    reply_to_email TEXT,
    reply_to_name TEXT,
    template_id TEXT,
    content_html TEXT,
    content_text TEXT,
    variables JSONB DEFAULT '{}'::jsonb,
    target_audience JSONB DEFAULT '{}'::jsonb,
    send_schedule TIMESTAMP WITH TIME ZONE,
    send_timezone TEXT DEFAULT 'UTC',
    is_scheduled BOOLEAN DEFAULT false,
    is_recurring BOOLEAN DEFAULT false,
    recurrence_pattern TEXT,
    recurrence_end_date TIMESTAMP WITH TIME ZONE,
    total_recipients INTEGER DEFAULT 0,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    emails_spam_reported INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Email Campaign Recipients
CREATE TABLE IF NOT EXISTS email_campaign_recipients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_id UUID REFERENCES email_campaigns(id),
    recipient_email TEXT NOT NULL,
    recipient_name TEXT,
    recipient_data JSONB DEFAULT '{}'::jsonb,
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'delivered', 'bounced', 'opened', 'clicked', 'unsubscribed', 'spam', 'failed')),
    sent_at TIMESTAMP WITH TIME ZONE,
    delivered_at TIMESTAMP WITH TIME ZONE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    bounced_at TIMESTAMP WITH TIME ZONE,
    unsubscribed_at TIMESTAMP WITH TIME ZONE,
    spam_reported_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Automation Rules
CREATE TABLE IF NOT EXISTS email_automation_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name TEXT NOT NULL,
    rule_type TEXT NOT NULL CHECK (rule_type IN ('trigger', 'condition', 'action', 'delay')),
    trigger_event TEXT NOT NULL,
    trigger_conditions JSONB DEFAULT '{}'::jsonb,
    actions JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    priority INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Email Automation Workflows
CREATE TABLE IF NOT EXISTS email_automation_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_name TEXT NOT NULL,
    workflow_type TEXT NOT NULL CHECK (workflow_type IN ('welcome', 'onboarding', 'abandoned_cart', 're_engagement', 'birthday', 'anniversary', 'custom')),
    trigger_event TEXT NOT NULL,
    trigger_conditions JSONB DEFAULT '{}'::jsonb,
    workflow_steps JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    total_emails_sent INTEGER DEFAULT 0,
    total_emails_delivered INTEGER DEFAULT 0,
    total_emails_opened INTEGER DEFAULT 0,
    total_emails_clicked INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Email Automation Executions
CREATE TABLE IF NOT EXISTS email_automation_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID REFERENCES email_automation_workflows(id),
    user_id UUID REFERENCES auth.users(id),
    execution_status TEXT NOT NULL DEFAULT 'pending' CHECK (execution_status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
    current_step INTEGER DEFAULT 0,
    total_steps INTEGER DEFAULT 0,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    execution_data JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email A/B Testing
CREATE TABLE IF NOT EXISTS email_ab_tests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    test_name TEXT NOT NULL,
    campaign_id UUID REFERENCES email_campaigns(id),
    variant_a_config JSONB NOT NULL,
    variant_b_config JSONB NOT NULL,
    traffic_split NUMERIC(3,2) DEFAULT 0.50,
    test_status TEXT DEFAULT 'draft' CHECK (test_status IN ('draft', 'running', 'completed', 'cancelled')),
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    winner_variant TEXT,
    confidence_level NUMERIC(5,2),
    test_results JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_campaigns_type ON email_campaigns(campaign_type);
CREATE INDEX IF NOT EXISTS idx_email_campaigns_status ON email_campaigns(status);
CREATE INDEX IF NOT EXISTS idx_email_campaigns_schedule ON email_campaigns(send_schedule);
CREATE INDEX IF NOT EXISTS idx_email_campaign_recipients_campaign ON email_campaign_recipients(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_campaign_recipients_email ON email_campaign_recipients(recipient_email);
CREATE INDEX IF NOT EXISTS idx_email_campaign_recipients_status ON email_campaign_recipients(status);
CREATE INDEX IF NOT EXISTS idx_email_automation_rules_type ON email_automation_rules(rule_type);
CREATE INDEX IF NOT EXISTS idx_email_automation_workflows_type ON email_automation_workflows(workflow_type);
CREATE INDEX IF NOT EXISTS idx_email_automation_executions_workflow ON email_automation_executions(workflow_id);
CREATE INDEX IF NOT EXISTS idx_email_automation_executions_user ON email_automation_executions(user_id);
CREATE INDEX IF NOT EXISTS idx_email_ab_tests_campaign ON email_ab_tests(campaign_id);
CREATE INDEX IF NOT EXISTS idx_email_ab_tests_status ON email_ab_tests(test_status);

-- Triggers for updated_at
CREATE TRIGGER update_email_campaigns_updated_at BEFORE UPDATE ON email_campaigns FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_campaign_recipients_updated_at BEFORE UPDATE ON email_campaign_recipients FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_automation_rules_updated_at BEFORE UPDATE ON email_automation_rules FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_automation_workflows_updated_at BEFORE UPDATE ON email_automation_workflows FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_automation_executions_updated_at BEFORE UPDATE ON email_automation_executions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_ab_tests_updated_at BEFORE UPDATE ON email_ab_tests FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/22_email_campaign_management.sql --\n
-- Admin Email Controls Migration
-- Founder: George Nekwaya (george@buffr.ai +12065308433)

-- Create manual email requests table
CREATE TABLE IF NOT EXISTS manual_email_requests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    admin_id VARCHAR(255) NOT NULL,
    admin_name VARCHAR(255) NOT NULL,
    email_type VARCHAR(50) NOT NULL,
    recipients JSONB NOT NULL,
    subject TEXT NOT NULL,
    content JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ,
    priority VARCHAR(20) DEFAULT 'normal',
    reason TEXT NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    conflicts JSONB DEFAULT '[]',
    approver_id VARCHAR(255),
    approver_name VARCHAR(255),
    approved_at TIMESTAMPTZ,
    rejected_at TIMESTAMPTZ,
    rejection_reason TEXT,
    cancelled_at TIMESTAMPTZ,
    cancellation_reason TEXT,
    cancelled_by VARCHAR(255),
    sent_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create admin email activity log table
CREATE TABLE IF NOT EXISTS admin_email_activity (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    admin_id VARCHAR(255) NOT NULL,
    action VARCHAR(100) NOT NULL,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create email queue table (if not exists)
CREATE TABLE IF NOT EXISTS email_queue (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    email_type VARCHAR(50) NOT NULL,
    recipient_email VARCHAR(255) NOT NULL,
    subject TEXT NOT NULL,
    content JSONB NOT NULL,
    scheduled_for TIMESTAMPTZ NOT NULL,
    priority INTEGER DEFAULT 3,
    status VARCHAR(20) DEFAULT 'queued',
    attempts INTEGER DEFAULT 0,
    last_attempt TIMESTAMPTZ,
    error_message TEXT,
    is_manual BOOLEAN DEFAULT FALSE,
    manual_request_id UUID REFERENCES manual_email_requests(id),
    admin_id VARCHAR(255),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_status ON manual_email_requests(status);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_admin_id ON manual_email_requests(admin_id);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_created_at ON manual_email_requests(created_at);
CREATE INDEX IF NOT EXISTS idx_manual_email_requests_scheduled_for ON manual_email_requests(scheduled_for);

CREATE INDEX IF NOT EXISTS idx_admin_email_activity_admin_id ON admin_email_activity(admin_id);
CREATE INDEX IF NOT EXISTS idx_admin_email_activity_created_at ON admin_email_activity(created_at);
CREATE INDEX IF NOT EXISTS idx_admin_email_activity_action ON admin_email_activity(action);

CREATE INDEX IF NOT EXISTS idx_email_queue_status ON email_queue(status);
CREATE INDEX IF NOT EXISTS idx_email_queue_scheduled_for ON email_queue(scheduled_for);
CREATE INDEX IF NOT EXISTS idx_email_queue_priority ON email_queue(priority);
CREATE INDEX IF NOT EXISTS idx_email_queue_is_manual ON email_queue(is_manual);
CREATE INDEX IF NOT EXISTS idx_email_queue_manual_request_id ON email_queue(manual_request_id);

-- Create updated_at trigger function (if not exists)
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS update_manual_email_requests_updated_at ON manual_email_requests;
CREATE TRIGGER update_manual_email_requests_updated_at
    BEFORE UPDATE ON manual_email_requests
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_email_queue_updated_at ON email_queue;
CREATE TRIGGER update_email_queue_updated_at
    BEFORE UPDATE ON email_queue
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create RLS policies
ALTER TABLE manual_email_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE admin_email_activity ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_queue ENABLE ROW LEVEL SECURITY;

-- Manual email requests policies
CREATE POLICY "Admins can view all manual email requests" ON manual_email_requests
    FOR SELECT USING (true);

CREATE POLICY "Admins can insert manual email requests" ON manual_email_requests
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Admins can update manual email requests" ON manual_email_requests
    FOR UPDATE USING (true);

-- Admin email activity policies
CREATE POLICY "Admins can view all admin email activity" ON admin_email_activity
    FOR SELECT USING (true);

CREATE POLICY "System can insert admin email activity" ON admin_email_activity
    FOR INSERT WITH CHECK (true);

-- Email queue policies
CREATE POLICY "Admins can view all email queue items" ON email_queue
    FOR SELECT USING (true);

CREATE POLICY "System can insert email queue items" ON email_queue
    FOR INSERT WITH CHECK (true);

CREATE POLICY "System can update email queue items" ON email_queue
    FOR UPDATE USING (true);

-- Create function to check email conflicts
CREATE OR REPLACE FUNCTION check_email_conflicts(
    recipient_emails TEXT[],
    email_type VARCHAR(50),
    hours_back INTEGER DEFAULT 24
)
RETURNS TABLE (
    conflict_type VARCHAR(50),
    severity VARCHAR(20),
    message TEXT,
    recommendation TEXT,
    affected_email VARCHAR(255)
) AS $$
BEGIN
    -- Check for recent emails of same type
    RETURN QUERY
    SELECT 
        'duplicate'::VARCHAR(50) as conflict_type,
        'high'::VARCHAR(20) as severity,
        ('Recent automated ' || email_type || ' email sent to ' || en.recipient_email || ' at ' || en.sent_at)::TEXT as message,
        'Consider delaying manual email or targeting different recipients'::TEXT as recommendation,
        en.recipient_email as affected_email
    FROM email_notifications en
    WHERE en.recipient_email = ANY(recipient_emails)
    AND en.email_type = email_type
    AND en.sent_at >= NOW() - (hours_back || ' hours')::INTERVAL
    ORDER BY en.sent_at DESC;
END;
$$ LANGUAGE plpgsql;

-- Create function to get email frequency for recipients
CREATE OR REPLACE FUNCTION get_email_frequency(
    recipient_emails TEXT[],
    hours_back INTEGER DEFAULT 24
)
RETURNS TABLE (
    email VARCHAR(255),
    email_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        en.recipient_email as email,
        COUNT(*) as email_count
    FROM email_notifications en
    WHERE en.recipient_email = ANY(recipient_emails)
    AND en.sent_at >= NOW() - (hours_back || ' hours')::INTERVAL
    GROUP BY en.recipient_email
    HAVING COUNT(*) >= 3
    ORDER BY email_count DESC;
END;
$$ LANGUAGE plpgsql;

-- Create function to process email queue
CREATE OR REPLACE FUNCTION process_email_queue(batch_size INTEGER DEFAULT 10)
RETURNS TABLE (
    id UUID,
    email_type VARCHAR(50),
    recipient_email VARCHAR(255),
    subject TEXT,
    content JSONB,
    priority INTEGER,
    attempts INTEGER
) AS $$
BEGIN
    -- Get queued emails ordered by priority and creation time
    RETURN QUERY
    SELECT 
        eq.id,
        eq.email_type,
        eq.recipient_email,
        eq.subject,
        eq.content,
        eq.priority,
        eq.attempts
    FROM email_queue eq
    WHERE eq.status = 'queued'
    AND eq.scheduled_for <= NOW()
    AND eq.attempts < 3
    ORDER BY eq.priority ASC, eq.created_at ASC
    LIMIT batch_size;
END;
$$ LANGUAGE plpgsql;

-- Create function to update email queue item status
CREATE OR REPLACE FUNCTION update_email_queue_status(
    queue_id UUID,
    new_status VARCHAR(20),
    error_msg TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    UPDATE email_queue 
    SET 
        status = new_status,
        attempts = attempts + 1,
        last_attempt = NOW(),
        error_message = error_msg,
        updated_at = NOW()
    WHERE id = queue_id;
END;
$$ LANGUAGE plpgsql;

-- Insert default admin user (replace with actual admin data)
INSERT INTO manual_email_requests (
    admin_id,
    admin_name,
    email_type,
    recipients,
    subject,
    content,
    priority,
    reason,
    status
) VALUES (
    'system',
    'System',
    'custom',
    '{"type": "custom", "ids": [], "emails": []}',
    'System Initialization',
    '{"html": "", "text": ""}',
    'low',
    'System initialization',
    'sent'
) ON CONFLICT DO NOTHING;

-- Create view for email conflict monitoring
CREATE OR REPLACE VIEW email_conflict_monitoring AS
SELECT 
    mer.id,
    mer.admin_name,
    mer.email_type,
    mer.subject,
    mer.status,
    mer.created_at,
    jsonb_array_length(mer.conflicts) as conflict_count,
    CASE 
        WHEN jsonb_array_length(mer.conflicts) = 0 THEN 'none'
        WHEN jsonb_array_length(mer.conflicts) <= 2 THEN 'low'
        WHEN jsonb_array_length(mer.conflicts) <= 5 THEN 'medium'
        ELSE 'high'
    END as conflict_severity
FROM manual_email_requests mer
WHERE mer.status IN ('pending', 'approved')
ORDER BY mer.created_at DESC;

-- Create view for email queue monitoring
CREATE OR REPLACE VIEW email_queue_monitoring AS
SELECT 
    status,
    is_manual,
    COUNT(*) as count,
    AVG(EXTRACT(EPOCH FROM (NOW() - created_at))/60) as avg_wait_minutes
FROM email_queue
GROUP BY status, is_manual
ORDER BY status, is_manual;

-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON manual_email_requests TO authenticated;
GRANT SELECT, INSERT ON admin_email_activity TO authenticated;
GRANT SELECT, INSERT, UPDATE ON email_queue TO authenticated;
GRANT SELECT ON email_conflict_monitoring TO authenticated;
GRANT SELECT ON email_queue_monitoring TO authenticated;
GRANT EXECUTE ON FUNCTION check_email_conflicts TO authenticated;
GRANT EXECUTE ON FUNCTION get_email_frequency TO authenticated;
GRANT EXECUTE ON FUNCTION process_email_queue TO authenticated;
GRANT EXECUTE ON FUNCTION update_email_queue_status TO authenticated;

-- Add comments
COMMENT ON TABLE manual_email_requests IS 'Stores manual email requests submitted by admins with conflict detection';
COMMENT ON TABLE admin_email_activity IS 'Logs all admin email-related actions for audit purposes';
COMMENT ON TABLE email_queue IS 'Queue for both manual and automated emails with priority and retry logic';
COMMENT ON VIEW email_conflict_monitoring IS 'Monitoring view for email conflicts in manual requests';
COMMENT ON VIEW email_queue_monitoring IS 'Monitoring view for email queue status and performance';
\n-- End of buffrlend-starter/supabase/migrations/20241201000000_admin_email_controls.sql --\n
-- JWT Tables Migration for BuffrLend
-- This migration creates tables for JWT token management

-- Create refresh_tokens table
CREATE TABLE IF NOT EXISTS refresh_tokens (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    token TEXT NOT NULL UNIQUE,
    jti TEXT NOT NULL UNIQUE, -- JWT ID for tracking
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_revoked BOOLEAN DEFAULT FALSE,
    revoked_at TIMESTAMP WITH TIME ZONE,
    device_info JSONB, -- Store device information for security
    ip_address INET,
    user_agent TEXT
);

-- Create blacklisted_tokens table
CREATE TABLE IF NOT EXISTS blacklisted_tokens (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    jti TEXT NOT NULL UNIQUE, -- JWT ID
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    token_type TEXT NOT NULL CHECK (token_type IN ('access', 'refresh', 'api', 'session')),
    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    reason TEXT, -- Reason for blacklisting (logout, security, etc.)
    revoked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Create token_audit_log table for security monitoring
CREATE TABLE IF NOT EXISTS token_audit_log (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    action TEXT NOT NULL CHECK (action IN ('login', 'logout', 'refresh', 'revoke', 'blacklist', 'verify_failed')),
    token_type TEXT,
    jti TEXT,
    ip_address INET,
    user_agent TEXT,
    success BOOLEAN NOT NULL,
    error_message TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    metadata JSONB -- Additional context information
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user_id ON refresh_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires_at ON refresh_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_jti ON refresh_tokens(jti);
CREATE INDEX IF NOT EXISTS idx_refresh_tokens_is_revoked ON refresh_tokens(is_revoked);

CREATE INDEX IF NOT EXISTS idx_blacklisted_tokens_jti ON blacklisted_tokens(jti);
CREATE INDEX IF NOT EXISTS idx_blacklisted_tokens_user_id ON blacklisted_tokens(user_id);
CREATE INDEX IF NOT EXISTS idx_blacklisted_tokens_expires_at ON blacklisted_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_blacklisted_tokens_token_type ON blacklisted_tokens(token_type);

CREATE INDEX IF NOT EXISTS idx_token_audit_log_user_id ON token_audit_log(user_id);
CREATE INDEX IF NOT EXISTS idx_token_audit_log_action ON token_audit_log(action);
CREATE INDEX IF NOT EXISTS idx_token_audit_log_created_at ON token_audit_log(created_at);
CREATE INDEX IF NOT EXISTS idx_token_audit_log_success ON token_audit_log(success);

-- Enable Row Level Security (RLS)
ALTER TABLE refresh_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE blacklisted_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE token_audit_log ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for refresh_tokens
CREATE POLICY "Users can view own refresh tokens" ON refresh_tokens
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own refresh tokens" ON refresh_tokens
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own refresh tokens" ON refresh_tokens
    FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own refresh tokens" ON refresh_tokens
    FOR DELETE USING (auth.uid() = user_id);

-- Create RLS policies for blacklisted_tokens
CREATE POLICY "Users can view own blacklisted tokens" ON blacklisted_tokens
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can manage blacklisted tokens" ON blacklisted_tokens
    FOR ALL USING (true); -- Allow system operations

-- Create RLS policies for token_audit_log
CREATE POLICY "Users can view own audit logs" ON token_audit_log
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert audit logs" ON token_audit_log
    FOR INSERT WITH CHECK (true); -- Allow system to log all actions

-- Create function to clean up expired tokens
CREATE OR REPLACE FUNCTION cleanup_expired_tokens()
RETURNS void AS $$
BEGIN
    -- Delete expired refresh tokens
    DELETE FROM refresh_tokens 
    WHERE expires_at < NOW() OR is_revoked = TRUE;
    
    -- Delete expired blacklisted tokens
    DELETE FROM blacklisted_tokens 
    WHERE expires_at < NOW();
    
    -- Clean up old audit logs (keep last 90 days)
    DELETE FROM token_audit_log 
    WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to revoke all user tokens
CREATE OR REPLACE FUNCTION revoke_all_user_tokens(target_user_id UUID)
RETURNS void AS $$
BEGIN
    -- Revoke all refresh tokens for user
    UPDATE refresh_tokens 
    SET is_revoked = TRUE, revoked_at = NOW() 
    WHERE user_id = target_user_id AND is_revoked = FALSE;
    
    -- Log the action
    INSERT INTO token_audit_log (user_id, action, success, metadata)
    VALUES (target_user_id, 'revoke', TRUE, jsonb_build_object('reason', 'bulk_revoke'));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to log token actions
CREATE OR REPLACE FUNCTION log_token_action(
    p_user_id UUID,
    p_action TEXT,
    p_token_type TEXT DEFAULT NULL,
    p_jti TEXT DEFAULT NULL,
    p_success BOOLEAN DEFAULT TRUE,
    p_error_message TEXT DEFAULT NULL,
    p_metadata JSONB DEFAULT NULL
)
RETURNS void AS $$
BEGIN
    INSERT INTO token_audit_log (
        user_id, 
        action, 
        token_type, 
        jti, 
        success, 
        error_message, 
        metadata
    ) VALUES (
        p_user_id, 
        p_action, 
        p_token_type, 
        p_jti, 
        p_success, 
        p_error_message, 
        p_metadata
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_refresh_tokens_updated_at
    BEFORE UPDATE ON refresh_tokens
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON refresh_tokens TO authenticated;
GRANT ALL ON blacklisted_tokens TO authenticated;
GRANT ALL ON token_audit_log TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_expired_tokens() TO authenticated;
GRANT EXECUTE ON FUNCTION revoke_all_user_tokens(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION log_token_action(UUID, TEXT, TEXT, TEXT, BOOLEAN, TEXT, JSONB) TO authenticated;

-- Create a scheduled job to clean up expired tokens (if using pg_cron extension)
-- SELECT cron.schedule('cleanup-expired-tokens', '0 2 * * *', 'SELECT cleanup_expired_tokens();');
\n-- End of buffrlend-starter/supabase/migrations/20241201000001_create_jwt_tables.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/007_create_unified_monitoring_analytics.sql --\n
-- =====================================================
-- BuffrLend Notification System
-- =====================================================
-- Description: Comprehensive notification system for email, SMS, and WhatsApp
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- NOTIFICATION TABLES
-- =====================================================

-- Notification templates table
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_name VARCHAR(255) NOT NULL UNIQUE,
    template_type VARCHAR(50) NOT NULL CHECK (template_type IN ('email', 'sms', 'whatsapp', 'push')),
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification queue table
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    notification_type VARCHAR(50) NOT NULL CHECK (notification_type IN ('email', 'sms', 'whatsapp', 'push')),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE CASCADE,
    recipient VARCHAR(255) NOT NULL,
    subject VARCHAR(255),
    content TEXT NOT NULL,
    variables JSONB,
    priority INTEGER DEFAULT 5 CHECK (priority >= 1 AND priority <= 10),
    scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'sent', 'delivered', 'failed', 'cancelled')),
    attempts INTEGER DEFAULT 0,
    max_attempts INTEGER DEFAULT 3,
    error_message TEXT,
    sent_at TIMESTAMP WITH TIME ZONE,
    delivered_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification preferences table
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL UNIQUE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT TRUE,
    whatsapp_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT TRUE,
    email_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (email_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    sms_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (sms_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    whatsapp_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (whatsapp_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    push_frequency VARCHAR(20) DEFAULT 'immediate' CHECK (push_frequency IN ('immediate', 'daily', 'weekly', 'never')),
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    timezone VARCHAR(50) DEFAULT 'Africa/Windhoek',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification delivery logs table
CREATE TABLE IF NOT EXISTS public.notification_delivery_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    notification_id UUID NOT NULL REFERENCES public.notification_queue(id) ON DELETE CASCADE,
    delivery_status VARCHAR(20) NOT NULL CHECK (delivery_status IN ('sent', 'delivered', 'opened', 'clicked', 'bounced', 'failed')),
    delivery_provider VARCHAR(100),
    provider_message_id VARCHAR(255),
    delivery_timestamp TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    error_code VARCHAR(50),
    error_message TEXT,
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Notification campaigns table
CREATE TABLE IF NOT EXISTS public.notification_campaigns (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    campaign_name VARCHAR(255) NOT NULL,
    campaign_type VARCHAR(50) NOT NULL CHECK (campaign_type IN ('marketing', 'transactional', 'promotional', 'system')),
    template_id UUID NOT NULL REFERENCES public.notification_templates(id) ON DELETE CASCADE,
    target_audience JSONB,
    scheduled_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(20) DEFAULT 'draft' CHECK (status IN ('draft', 'scheduled', 'running', 'completed', 'cancelled')),
    total_recipients INTEGER DEFAULT 0,
    sent_count INTEGER DEFAULT 0,
    delivered_count INTEGER DEFAULT 0,
    opened_count INTEGER DEFAULT 0,
    clicked_count INTEGER DEFAULT 0,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- NOTIFICATION FUNCTIONS
-- =====================================================

-- Function to send notification
CREATE OR REPLACE FUNCTION public.send_notification(
    p_user_id TEXT,
    p_notification_type VARCHAR(50),
    p_template_name VARCHAR(255),
    p_recipient VARCHAR(255),
    p_variables JSONB DEFAULT '{}',
    p_priority INTEGER DEFAULT 5,
    p_scheduled_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
)
RETURNS UUID AS $$
DECLARE
    template_record RECORD;
    notification_id UUID;
    processed_content TEXT;
    processed_subject TEXT;
BEGIN
    -- Get template
    SELECT * INTO template_record 
    FROM public.notification_templates 
    WHERE template_name = p_template_name 
    AND template_type = p_notification_type 
    AND is_active = TRUE;
    
    IF template_record IS NULL THEN
        RAISE EXCEPTION 'Template not found: %', p_template_name;
    END IF;
    
    -- Process content with variables
    processed_content := template_record.content;
    processed_subject := COALESCE(template_record.subject, '');
    
    -- Replace variables in content
    IF p_variables IS NOT NULL THEN
        FOR key, value IN SELECT * FROM jsonb_each_text(p_variables) LOOP
            processed_content := replace(processed_content, '{{' || key || '}}', value);
            processed_subject := replace(processed_subject, '{{' || key || '}}', value);
        END LOOP;
    END IF;
    
    -- Insert notification into queue
    INSERT INTO public.notification_queue (
        user_id, notification_type, template_id, recipient, 
        subject, content, variables, priority, scheduled_at
    ) VALUES (
        p_user_id, p_notification_type, template_record.id, p_recipient,
        processed_subject, processed_content, p_variables, p_priority, p_scheduled_at
    ) RETURNING id INTO notification_id;
    
    RETURN notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to process notification queue
CREATE OR REPLACE FUNCTION public.process_notification_queue()
RETURNS VOID AS $$
DECLARE
    notification_record RECORD;
    delivery_status VARCHAR(20);
    error_message TEXT;
BEGIN
    -- Get pending notifications
    FOR notification_record IN 
        SELECT * FROM public.notification_queue 
        WHERE status = 'pending' 
        AND scheduled_at <= CURRENT_TIMESTAMP
        AND attempts < max_attempts
        ORDER BY priority DESC, created_at ASC
        LIMIT 100
    LOOP
        -- Update status to processing
        UPDATE public.notification_queue 
        SET status = 'processing', attempts = attempts + 1
        WHERE id = notification_record.id;
        
        -- Process based on notification type
        CASE notification_record.notification_type
            WHEN 'email' THEN
                -- Email processing logic would go here
                delivery_status := 'sent';
            WHEN 'sms' THEN
                -- SMS processing logic would go here
                delivery_status := 'sent';
            WHEN 'whatsapp' THEN
                -- WhatsApp processing logic would go here
                delivery_status := 'sent';
            WHEN 'push' THEN
                -- Push notification processing logic would go here
                delivery_status := 'sent';
            ELSE
                delivery_status := 'failed';
                error_message := 'Unknown notification type';
        END CASE;
        
        -- Update notification status
        IF delivery_status = 'sent' THEN
            UPDATE public.notification_queue 
            SET status = 'sent', sent_at = CURRENT_TIMESTAMP
            WHERE id = notification_record.id;
            
            -- Log delivery
            INSERT INTO public.notification_delivery_logs (
                notification_id, delivery_status, delivery_timestamp
            ) VALUES (
                notification_record.id, delivery_status, CURRENT_TIMESTAMP
            );
        ELSE
            UPDATE public.notification_queue 
            SET status = 'failed', error_message = error_message
            WHERE id = notification_record.id;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Function to get user notification preferences
CREATE OR REPLACE FUNCTION public.get_user_notification_preferences(p_user_id TEXT)
RETURNS JSONB AS $$
DECLARE
    preferences_record RECORD;
    result JSONB;
BEGIN
    SELECT * INTO preferences_record 
    FROM public.notification_preferences 
    WHERE user_id = p_user_id;
    
    IF preferences_record IS NULL THEN
        -- Create default preferences
        INSERT INTO public.notification_preferences (user_id) 
        VALUES (p_user_id) 
        RETURNING * INTO preferences_record;
    END IF;
    
    result := jsonb_build_object(
        'email_enabled', preferences_record.email_enabled,
        'sms_enabled', preferences_record.sms_enabled,
        'whatsapp_enabled', preferences_record.whatsapp_enabled,
        'push_enabled', preferences_record.push_enabled,
        'email_frequency', preferences_record.email_frequency,
        'sms_frequency', preferences_record.sms_frequency,
        'whatsapp_frequency', preferences_record.whatsapp_frequency,
        'push_frequency', preferences_record.push_frequency,
        'quiet_hours_start', preferences_record.quiet_hours_start,
        'quiet_hours_end', preferences_record.quiet_hours_end,
        'timezone', preferences_record.timezone
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to update notification preferences
CREATE OR REPLACE FUNCTION public.update_notification_preferences(
    p_user_id TEXT,
    p_preferences JSONB
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO public.notification_preferences (
        user_id, email_enabled, sms_enabled, whatsapp_enabled, push_enabled,
        email_frequency, sms_frequency, whatsapp_frequency, push_frequency,
        quiet_hours_start, quiet_hours_end, timezone
    ) VALUES (
        p_user_id,
        COALESCE((p_preferences->>'email_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'sms_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'whatsapp_enabled')::BOOLEAN, TRUE),
        COALESCE((p_preferences->>'push_enabled')::BOOLEAN, TRUE),
        COALESCE(p_preferences->>'email_frequency', 'immediate'),
        COALESCE(p_preferences->>'sms_frequency', 'immediate'),
        COALESCE(p_preferences->>'whatsapp_frequency', 'immediate'),
        COALESCE(p_preferences->>'push_frequency', 'immediate'),
        (p_preferences->>'quiet_hours_start')::TIME,
        (p_preferences->>'quiet_hours_end')::TIME,
        COALESCE(p_preferences->>'timezone', 'Africa/Windhoek')
    ) ON CONFLICT (user_id) DO UPDATE SET
        email_enabled = EXCLUDED.email_enabled,
        sms_enabled = EXCLUDED.sms_enabled,
        whatsapp_enabled = EXCLUDED.whatsapp_enabled,
        push_enabled = EXCLUDED.push_enabled,
        email_frequency = EXCLUDED.email_frequency,
        sms_frequency = EXCLUDED.sms_frequency,
        whatsapp_frequency = EXCLUDED.whatsapp_frequency,
        push_frequency = EXCLUDED.push_frequency,
        quiet_hours_start = EXCLUDED.quiet_hours_start,
        quiet_hours_end = EXCLUDED.quiet_hours_end,
        timezone = EXCLUDED.timezone,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup old notifications
CREATE OR REPLACE FUNCTION public.cleanup_old_notifications()
RETURNS VOID AS $$
BEGIN
    -- Cleanup old notification queue (keep for 30 days)
    DELETE FROM public.notification_queue 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days'
    AND status IN ('sent', 'delivered', 'failed', 'cancelled');
    
    -- Cleanup old delivery logs (keep for 90 days)
    DELETE FROM public.notification_delivery_logs 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '90 days';
    
    -- Cleanup old campaigns (keep for 1 year)
    DELETE FROM public.notification_campaigns 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '1 year'
    AND status = 'completed';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- NOTIFICATION TRIGGERS
-- =====================================================

-- Trigger function for loan application notifications
CREATE OR REPLACE FUNCTION public.notify_loan_application_status()
RETURNS TRIGGER AS $$
DECLARE
    user_profile RECORD;
    notification_variables JSONB;
BEGIN
    -- Get user profile
    SELECT * INTO user_profile FROM public.profiles WHERE user_id = NEW.user_id;
    
    IF user_profile IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Prepare notification variables
    notification_variables := jsonb_build_object(
        'user_name', user_profile.first_name || ' ' || user_profile.last_name,
        'loan_amount', NEW.loan_amount,
        'loan_term', NEW.loan_term_months,
        'application_id', NEW.id,
        'status', NEW.status
    );
    
    -- Send notification based on status
    CASE NEW.status
        WHEN 'approved' THEN
            PERFORM public.send_notification(
                NEW.user_id, 'email', 'loan_approved', user_profile.email,
                notification_variables, 8
            );
            PERFORM public.send_notification(
                NEW.user_id, 'whatsapp', 'loan_approved', user_profile.phone_number,
                notification_variables, 8
            );
        WHEN 'rejected' THEN
            PERFORM public.send_notification(
                NEW.user_id, 'email', 'loan_rejected', user_profile.email,
                notification_variables, 7
            );
            PERFORM public.send_notification(
                NEW.user_id, 'whatsapp', 'loan_rejected', user_profile.phone_number,
                notification_variables, 7
            );
        WHEN 'pending' THEN
            PERFORM public.send_notification(
                NEW.user_id, 'email', 'loan_submitted', user_profile.email,
                notification_variables, 6
            );
    END CASE;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_notify_loan_application_status
    AFTER INSERT OR UPDATE ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.notify_loan_application_status();

-- =====================================================
-- DEFAULT NOTIFICATION TEMPLATES
-- =====================================================

-- Insert default notification templates
INSERT INTO public.notification_templates (template_name, template_type, subject, content, variables) VALUES
('loan_approved', 'email', 'Loan Application Approved - {{user_name}}', 
 'Dear {{user_name}},\n\nYour loan application for N${{loan_amount}} has been approved.\n\nLoan Details:\n- Amount: N${{loan_amount}}\n- Term: {{loan_term}} months\n- Application ID: {{application_id}}\n\nPlease log in to your account to view the loan agreement.\n\nBest regards,\nBuffrLend Team', 
 '{"user_name": "string", "loan_amount": "number", "loan_term": "number", "application_id": "string"}'),
('loan_rejected', 'email', 'Loan Application Update - {{user_name}}', 
 'Dear {{user_name}},\n\nWe regret to inform you that your loan application for N${{loan_amount}} has not been approved at this time.\n\nApplication ID: {{application_id}}\n\nPlease contact our customer service team for more information.\n\nBest regards,\nBuffrLend Team', 
 '{"user_name": "string", "loan_amount": "number", "application_id": "string"}'),
('loan_submitted', 'email', 'Loan Application Received - {{user_name}}', 
 'Dear {{user_name}},\n\nWe have received your loan application for N${{loan_amount}}.\n\nApplication ID: {{application_id}}\n\nWe will review your application and notify you of the decision within 24 hours.\n\nBest regards,\nBuffrLend Team', 
 '{"user_name": "string", "loan_amount": "number", "application_id": "string"}'),
('kyc_reminder', 'email', 'KYC Verification Reminder - {{user_name}}', 
 'Dear {{user_name}},\n\nPlease complete your KYC verification to continue using our services.\n\nLog in to your account to upload the required documents.\n\nBest regards,\nBuffrLend Team', 
 '{"user_name": "string"}'),
('payment_reminder', 'email', 'Payment Reminder - {{user_name}}', 
 'Dear {{user_name}},\n\nThis is a reminder that your loan payment of N${{amount}} is due on {{due_date}}.\n\nPlease ensure payment is made on time to avoid late fees.\n\nBest regards,\nBuffrLend Team', 
 '{"user_name": "string", "amount": "number", "due_date": "date"}'),
('loan_approved', 'whatsapp', 'Loan Approved! 🎉', 
 'Hi {{user_name}}! Your loan application for N${{loan_amount}} has been approved. Application ID: {{application_id}}. Please log in to view your loan agreement.', 
 '{"user_name": "string", "loan_amount": "number", "application_id": "string"}'),
('loan_rejected', 'whatsapp', 'Loan Application Update', 
 'Hi {{user_name}}, your loan application for N${{loan_amount}} was not approved. Application ID: {{application_id}}. Please contact customer service for more information.', 
 '{"user_name": "string", "loan_amount": "number", "application_id": "string"}'),
('payment_reminder', 'whatsapp', 'Payment Reminder', 
 'Hi {{user_name}}, your loan payment of N${{amount}} is due on {{due_date}}. Please make payment on time to avoid late fees.', 
 '{"user_name": "string", "amount": "number", "due_date": "date"}')
ON CONFLICT (template_name) DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR NOTIFICATION TABLES
-- =====================================================

-- Enable RLS on notification tables
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_delivery_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_campaigns ENABLE ROW LEVEL SECURITY;

-- Notification templates policies
CREATE POLICY "Admin users can manage notification templates" ON public.notification_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Notification queue policies
CREATE POLICY "Users can view own notifications" ON public.notification_queue
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all notifications" ON public.notification_queue
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "System can manage notification queue" ON public.notification_queue
    FOR ALL USING (true);

-- Notification preferences policies
CREATE POLICY "Users can manage own notification preferences" ON public.notification_preferences
    FOR ALL USING (
        auth.uid()::text = user_id
    );

-- Notification delivery logs policies
CREATE POLICY "Users can view own delivery logs" ON public.notification_delivery_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.notification_queue nq 
            WHERE nq.id = notification_delivery_logs.notification_id 
            AND nq.user_id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can view all delivery logs" ON public.notification_delivery_logs
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Notification campaigns policies
CREATE POLICY "Admin users can manage notification campaigns" ON public.notification_campaigns
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- =====================================================
-- INDEXES FOR NOTIFICATION TABLES
-- =====================================================

-- Notification templates indexes
CREATE INDEX IF NOT EXISTS idx_notification_templates_template_name ON public.notification_templates(template_name);
CREATE INDEX IF NOT EXISTS idx_notification_templates_template_type ON public.notification_templates(template_type);
CREATE INDEX IF NOT EXISTS idx_notification_templates_is_active ON public.notification_templates(is_active);

-- Notification queue indexes
CREATE INDEX IF NOT EXISTS idx_notification_queue_user_id ON public.notification_queue(user_id);
CREATE INDEX IF NOT EXISTS idx_notification_queue_notification_type ON public.notification_queue(notification_type);
CREATE INDEX IF NOT EXISTS idx_notification_queue_status ON public.notification_queue(status);
CREATE INDEX IF NOT EXISTS idx_notification_queue_priority ON public.notification_queue(priority);
CREATE INDEX IF NOT EXISTS idx_notification_queue_scheduled_at ON public.notification_queue(scheduled_at);
CREATE INDEX IF NOT EXISTS idx_notification_queue_created_at ON public.notification_queue(created_at);

-- Notification preferences indexes
CREATE INDEX IF NOT EXISTS idx_notification_preferences_user_id ON public.notification_preferences(user_id);

-- Notification delivery logs indexes
CREATE INDEX IF NOT EXISTS idx_notification_delivery_logs_notification_id ON public.notification_delivery_logs(notification_id);
CREATE INDEX IF NOT EXISTS idx_notification_delivery_logs_delivery_status ON public.notification_delivery_logs(delivery_status);
CREATE INDEX IF NOT EXISTS idx_notification_delivery_logs_delivery_timestamp ON public.notification_delivery_logs(delivery_timestamp);

-- Notification campaigns indexes
CREATE INDEX IF NOT EXISTS idx_notification_campaigns_campaign_name ON public.notification_campaigns(campaign_name);
CREATE INDEX IF NOT EXISTS idx_notification_campaigns_campaign_type ON public.notification_campaigns(campaign_type);
CREATE INDEX IF NOT EXISTS idx_notification_campaigns_status ON public.notification_campaigns(status);
CREATE INDEX IF NOT EXISTS idx_notification_campaigns_scheduled_at ON public.notification_campaigns(scheduled_at);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.notification_templates IS 'Notification templates for different message types';
COMMENT ON TABLE public.notification_queue IS 'Queue for pending notifications';
COMMENT ON TABLE public.notification_preferences IS 'User notification preferences and settings';
COMMENT ON TABLE public.notification_delivery_logs IS 'Delivery logs for sent notifications';
COMMENT ON TABLE public.notification_campaigns IS 'Notification campaigns for bulk messaging';
COMMENT ON FUNCTION public.send_notification(TEXT, VARCHAR, VARCHAR, VARCHAR, JSONB, INTEGER, TIMESTAMP WITH TIME ZONE) IS 'Sends a notification to a user';
COMMENT ON FUNCTION public.process_notification_queue() IS 'Processes pending notifications in the queue';
COMMENT ON FUNCTION public.get_user_notification_preferences(TEXT) IS 'Gets user notification preferences';
COMMENT ON FUNCTION public.update_notification_preferences(TEXT, JSONB) IS 'Updates user notification preferences';
COMMENT ON FUNCTION public.cleanup_old_notifications() IS 'Cleans up old notification data';
\n-- End of buffrlend-starter/supabase/migrations/17_notification_system.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/supabase/migrations/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/009_create_unified_workflow_management.sql --\n
-- =====================================================
-- BuffrLend Database Enums and Types
-- =====================================================
-- Description: Custom enums and data types for BuffrLend
-- Dependencies: 01_extensions.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- USER AND PROFILE ENUMS
-- =====================================================

-- User status enum
CREATE TYPE public.user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'blocked'
);

-- Gender enum
CREATE TYPE public.gender AS ENUM (
    'male',
    'female',
    'other',
    'prefer_not_to_say'
);

-- Marital status enum
CREATE TYPE public.marital_status AS ENUM (
    'single',
    'married',
    'divorced',
    'widowed',
    'separated'
);

-- Employment status enum
CREATE TYPE public.employment_status AS ENUM (
    'employed',
    'self_employed',
    'unemployed',
    'retired',
    'student'
);

-- Employment type enum
CREATE TYPE public.employment_type AS ENUM (
    'full_time',
    'part_time',
    'contract',
    'temporary',
    'freelance'
);

-- =====================================================
-- ADMIN AND ROLE ENUMS
-- =====================================================

-- Admin role enum
CREATE TYPE public.admin_role AS ENUM (
    'super_admin',
    'system_admin',
    'compliance_admin',
    'security_admin',
    'loan_admin',
    'customer_service',
    'auditor',
    'viewer'
);

-- Admin status enum
CREATE TYPE public.admin_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_approval'
);

-- Permission type enum
CREATE TYPE public.permission_type AS ENUM (
    'read',
    'write',
    'update',
    'delete',
    'approve',
    'reject',
    'export',
    'import'
);

-- Resource type enum
CREATE TYPE public.resource_type AS ENUM (
    'users',
    'loans',
    'kyc',
    'payments',
    'reports',
    'settings',
    'audit_logs',
    'admin_users'
);

-- =====================================================
-- COMPANY AND PARTNER ENUMS
-- =====================================================

-- Company status enum
CREATE TYPE public.company_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_approval',
    'rejected'
);

-- Company size enum
CREATE TYPE public.company_size AS ENUM (
    'micro',
    'small',
    'medium',
    'large',
    'enterprise'
);

-- Industry sector enum
CREATE TYPE public.industry_sector AS ENUM (
    'agriculture',
    'mining',
    'manufacturing',
    'construction',
    'retail',
    'hospitality',
    'transportation',
    'financial_services',
    'real_estate',
    'professional_services',
    'healthcare',
    'education',
    'government',
    'non_profit',
    'other'
);

-- Partnership status enum
CREATE TYPE public.partnership_status AS ENUM (
    'active',
    'inactive',
    'pending',
    'suspended',
    'terminated'
);

-- Partnership tier enum
CREATE TYPE public.partnership_tier AS ENUM (
    'bronze',
    'silver',
    'gold',
    'platinum',
    'enterprise'
);

-- =====================================================
-- KYC AND VERIFICATION ENUMS
-- =====================================================

-- KYC status enum
CREATE TYPE public.kyc_status AS ENUM (
    'not_started',
    'in_progress',
    'pending',
    'verified',
    'rejected',
    'expired',
    'suspended'
);

-- Verification type enum
CREATE TYPE public.verification_type AS ENUM (
    'identity',
    'address',
    'employment',
    'income',
    'bank_account',
    'phone_number',
    'email'
);

-- Document type enum
CREATE TYPE public.document_type AS ENUM (
    'national_id',
    'passport',
    'drivers_license',
    'payslip',
    'employment_letter',
    'bank_statement',
    'utility_bill',
    'rental_agreement',
    'other'
);

-- Document status enum
CREATE TYPE public.document_status AS ENUM (
    'pending',
    'approved',
    'rejected',
    'expired',
    'under_review'
);

-- Verification level enum
CREATE TYPE public.verification_level AS ENUM (
    'basic',
    'standard',
    'enhanced',
    'premium'
);

-- =====================================================
-- LOAN AND FINANCIAL ENUMS
-- =====================================================

-- Loan status enum
CREATE TYPE public.loan_status AS ENUM (
    'draft',
    'pending',
    'under_review',
    'approved',
    'rejected',
    'active',
    'completed',
    'defaulted',
    'cancelled'
);

-- Loan purpose enum
CREATE TYPE public.loan_purpose AS ENUM (
    'personal',
    'emergency',
    'medical',
    'education',
    'business',
    'home_improvement',
    'debt_consolidation',
    'other'
);

-- Loan product enum
CREATE TYPE public.loan_product AS ENUM (
    'personal_loan',
    'emergency_loan',
    'salary_advance',
    'business_loan',
    'microloan'
);

-- Payment status enum
CREATE TYPE public.payment_status AS ENUM (
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled',
    'refunded'
);

-- Payment method enum
CREATE TYPE public.payment_method AS ENUM (
    'bank_transfer',
    'salary_deduction',
    'mobile_money',
    'cash',
    'card_payment'
);

-- Transaction type enum
CREATE TYPE public.transaction_type AS ENUM (
    'loan_disbursement',
    'loan_repayment',
    'interest_payment',
    'fee_payment',
    'refund',
    'adjustment'
);

-- Rate type enum
CREATE TYPE public.rate_type AS ENUM (
    'interest_rate',
    'processing_fee',
    'late_fee',
    'early_repayment_fee',
    'insurance_fee',
    'admin_fee'
);

-- Fee category enum
CREATE TYPE public.fee_category AS ENUM (
    'processing',
    'interest',
    'late_payment',
    'early_repayment',
    'insurance',
    'admin',
    'compliance',
    'bank_processing'
);

-- =====================================================
-- REALPAY AND PAYMENT ENUMS
-- =====================================================

-- RealPay status enum
CREATE TYPE public.realpay_status AS ENUM (
    'pending',
    'processing',
    'completed',
    'failed',
    'cancelled',
    'refunded'
);

-- RealPay transaction type enum
CREATE TYPE public.realpay_transaction_type AS ENUM (
    'loan_disbursement',
    'loan_repayment',
    'fee_payment',
    'refund',
    'adjustment'
);

-- =====================================================
-- COMPLIANCE AND REGULATORY ENUMS
-- =====================================================

-- NAMFISA license type enum
CREATE TYPE public.namfisa_license_type AS ENUM (
    'fintech_sandbox',
    'money_lending',
    'microfinance',
    'payment_service_provider'
);

-- NAMFISA license status enum
CREATE TYPE public.namfisa_license_status AS ENUM (
    'pending',
    'approved',
    'rejected',
    'suspended',
    'expired',
    'revoked'
);

-- NAMFISA sandbox phase enum
CREATE TYPE public.namfisa_sandbox_phase AS ENUM (
    'phase_1',
    'phase_2',
    'phase_3',
    'production'
);

-- Compliance type enum
CREATE TYPE public.compliance_type AS ENUM (
    'kyc',
    'aml',
    'responsible_lending',
    'data_protection',
    'reporting',
    'audit'
);

-- Risk level enum
CREATE TYPE public.risk_level AS ENUM (
    'low',
    'medium',
    'high',
    'critical'
);

-- =====================================================
-- AUDIT AND LOGGING ENUMS
-- =====================================================

-- Audit action enum
CREATE TYPE public.audit_action AS ENUM (
    'INSERT',
    'UPDATE',
    'DELETE',
    'SELECT',
    'LOGIN',
    'LOGOUT',
    'APPROVE',
    'REJECT',
    'EXPORT',
    'IMPORT'
);

-- Log level enum
CREATE TYPE public.log_level AS ENUM (
    'DEBUG',
    'INFO',
    'WARNING',
    'ERROR',
    'CRITICAL'
);

-- Security event enum
CREATE TYPE public.security_event AS ENUM (
    'login_success',
    'login_failed',
    'password_change',
    'permission_change',
    'data_access',
    'suspicious_activity',
    'breach_attempt',
    'unauthorized_access'
);

-- Activity type enum
CREATE TYPE public.activity_type AS ENUM (
    'login',
    'logout',
    'profile_update',
    'loan_application',
    'payment',
    'kyc_submission',
    'document_upload',
    'password_change'
);

-- =====================================================
-- COMMUNICATION ENUMS
-- =====================================================

-- Email type enum
CREATE TYPE public.email_type AS ENUM (
    'welcome',
    'verification',
    'loan_approval',
    'loan_rejection',
    'payment_reminder',
    'payment_confirmation',
    'kyc_reminder',
    'system_notification'
);

-- Email status enum
CREATE TYPE public.email_status AS ENUM (
    'pending',
    'sent',
    'delivered',
    'opened',
    'clicked',
    'bounced',
    'failed'
);

-- SMS type enum
CREATE TYPE public.sms_type AS ENUM (
    'verification',
    'notification',
    'reminder',
    'alert',
    'marketing'
);

-- SMS status enum
CREATE TYPE public.sms_status AS ENUM (
    'pending',
    'sent',
    'delivered',
    'failed',
    'bounced'
);

-- WhatsApp message type enum
CREATE TYPE public.whatsapp_message_type AS ENUM (
    'text',
    'template',
    'document',
    'image',
    'video',
    'audio'
);

-- WhatsApp status enum
CREATE TYPE public.whatsapp_status AS ENUM (
    'pending',
    'sent',
    'delivered',
    'read',
    'failed'
);

-- =====================================================
-- SYSTEM CONFIGURATION ENUMS
-- =====================================================

-- Config type enum
CREATE TYPE public.config_type AS ENUM (
    'string',
    'number',
    'boolean',
    'json',
    'array',
    'object'
);

-- Config category enum
CREATE TYPE public.config_category AS ENUM (
    'general',
    'loans',
    'payments',
    'kyc',
    'compliance',
    'notifications',
    'security',
    'api'
);

-- =====================================================
-- COLLECTION AND RECONCILIATION ENUMS
-- =====================================================

-- Collection status enum
CREATE TYPE public.collection_status AS ENUM (
    'pending',
    'in_progress',
    'completed',
    'failed',
    'cancelled'
);

-- Collection method enum
CREATE TYPE public.collection_method AS ENUM (
    'salary_deduction',
    'bank_transfer',
    'mobile_money',
    'cash',
    'automatic'
);

-- Reconciliation status enum
CREATE TYPE public.reconciliation_status AS ENUM (
    'pending',
    'in_progress',
    'completed',
    'discrepancy',
    'resolved'
);

-- =====================================================
-- REPORTING ENUMS
-- =====================================================

-- Report type enum
CREATE TYPE public.report_type AS ENUM (
    'loan_summary',
    'payment_summary',
    'kyc_summary',
    'compliance_summary',
    'financial_summary',
    'audit_summary',
    'namfisa_report',
    'custom_report'
);

-- Report status enum
CREATE TYPE public.report_status AS ENUM (
    'pending',
    'generating',
    'completed',
    'failed',
    'expired'
);

-- Report format enum
CREATE TYPE public.report_format AS ENUM (
    'pdf',
    'excel',
    'csv',
    'json',
    'xml'
);

-- =====================================================
-- ANALYTICS AND METRICS ENUMS
-- =====================================================

-- Analytics type enum
CREATE TYPE public.analytics_type AS ENUM (
    'user_behavior',
    'loan_performance',
    'payment_analysis',
    'kyc_completion',
    'system_usage',
    'error_analysis'
);

-- Metric type enum
CREATE TYPE public.metric_type AS ENUM (
    'counter',
    'gauge',
    'histogram',
    'summary'
);

-- Performance type enum
CREATE TYPE public.performance_type AS ENUM (
    'response_time',
    'throughput',
    'error_rate',
    'availability',
    'cpu_usage',
    'memory_usage'
);

-- =====================================================
-- ERROR AND INCIDENT ENUMS
-- =====================================================

-- Error type enum
CREATE TYPE public.error_type AS ENUM (
    'validation_error',
    'business_logic_error',
    'system_error',
    'network_error',
    'database_error',
    'api_error',
    'authentication_error',
    'authorization_error'
);

-- Exception type enum
CREATE TYPE public.exception_type AS ENUM (
    'null_pointer',
    'index_out_of_bounds',
    'illegal_argument',
    'concurrent_modification',
    'timeout',
    'resource_not_found',
    'permission_denied',
    'system_overload'
);

-- Incident type enum
CREATE TYPE public.incident_type AS ENUM (
    'system_outage',
    'performance_degradation',
    'security_breach',
    'data_loss',
    'service_unavailable',
    'third_party_failure',
    'configuration_error',
    'hardware_failure'
);

-- Breach type enum
CREATE TYPE public.breach_type AS ENUM (
    'data_breach',
    'security_breach',
    'privacy_breach',
    'access_breach',
    'integrity_breach',
    'availability_breach'
);

-- Vulnerability type enum
CREATE TYPE public.vulnerability_type AS ENUM (
    'sql_injection',
    'cross_site_scripting',
    'cross_site_request_forgery',
    'insecure_direct_object_reference',
    'security_misconfiguration',
    'sensitive_data_exposure',
    'missing_function_level_access_control',
    'using_components_with_known_vulnerabilities'
);

-- Threat type enum
CREATE TYPE public.threat_type AS ENUM (
    'malware',
    'phishing',
    'social_engineering',
    'insider_threat',
    'ddos_attack',
    'data_exfiltration',
    'ransomware',
    'advanced_persistent_threat'
);

-- =====================================================
-- COMPOSITE TYPES
-- =====================================================

-- Address type
CREATE TYPE public.address_type AS (
    street_address TEXT,
    city TEXT,
    state_province TEXT,
    postal_code TEXT,
    country TEXT
);

-- Contact information type
CREATE TYPE public.contact_info_type AS (
    phone_number TEXT,
    email TEXT,
    whatsapp_number TEXT,
    alternative_phone TEXT
);

-- Loan terms type
CREATE TYPE public.loan_terms_type AS (
    min_amount DECIMAL,
    max_amount DECIMAL,
    min_term_months INTEGER,
    max_term_months INTEGER,
    interest_rate DECIMAL,
    processing_fee DECIMAL
);

-- Payment schedule type
CREATE TYPE public.payment_schedule_type AS (
    due_date DATE,
    amount DECIMAL,
    status payment_status,
    paid_date DATE,
    late_fee DECIMAL
);

-- =====================================================
-- DOMAIN TYPES
-- =====================================================

-- Phone number domain
CREATE DOMAIN public.phone_number AS TEXT
CHECK (VALUE ~ '^\+264[0-9]{9}$');

-- Email domain
CREATE DOMAIN public.email_address AS TEXT
CHECK (VALUE ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$');

-- ID number domain (Namibian)
CREATE DOMAIN public.namibian_id_number AS TEXT
CHECK (VALUE ~ '^[0-9]{11}$');

-- Currency amount domain
CREATE DOMAIN public.currency_amount AS DECIMAL(15,2)
CHECK (VALUE >= 0);

-- Percentage domain
CREATE DOMAIN public.percentage AS DECIMAL(5,2)
CHECK (VALUE >= 0 AND VALUE <= 100);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TYPE public.user_status IS 'Status of user accounts in the system';
COMMENT ON TYPE public.gender IS 'Gender options for user profiles';
COMMENT ON TYPE public.marital_status IS 'Marital status options for user profiles';
COMMENT ON TYPE public.employment_status IS 'Employment status options for user profiles';
COMMENT ON TYPE public.employment_type IS 'Employment type options for user profiles';
COMMENT ON TYPE public.admin_role IS 'Administrative roles in the system';
COMMENT ON TYPE public.admin_status IS 'Status of administrative users';
COMMENT ON TYPE public.permission_type IS 'Types of permissions that can be granted';
COMMENT ON TYPE public.resource_type IS 'Types of resources that can be protected';
COMMENT ON TYPE public.company_status IS 'Status of company accounts';
COMMENT ON TYPE public.company_size IS 'Size categories for companies';
COMMENT ON TYPE public.industry_sector IS 'Industry sectors for companies';
COMMENT ON TYPE public.partnership_status IS 'Status of partnership agreements';
COMMENT ON TYPE public.partnership_tier IS 'Tiers of partnership agreements';
COMMENT ON TYPE public.kyc_status IS 'Status of KYC verification processes';
COMMENT ON TYPE public.verification_type IS 'Types of verification processes';
COMMENT ON TYPE public.document_type IS 'Types of documents that can be submitted';
COMMENT ON TYPE public.document_status IS 'Status of document submissions';
COMMENT ON TYPE public.verification_level IS 'Levels of verification completeness';
COMMENT ON TYPE public.loan_status IS 'Status of loan applications and loans';
COMMENT ON TYPE public.loan_purpose IS 'Purposes for loan applications';
COMMENT ON TYPE public.loan_product IS 'Types of loan products offered';
COMMENT ON TYPE public.payment_status IS 'Status of payment transactions';
COMMENT ON TYPE public.payment_method IS 'Methods of payment processing';
COMMENT ON TYPE public.transaction_type IS 'Types of financial transactions';
COMMENT ON TYPE public.rate_type IS 'Types of rates and fees';
COMMENT ON TYPE public.fee_category IS 'Categories of fees and charges';
COMMENT ON TYPE public.realpay_status IS 'Status of RealPay transactions';
COMMENT ON TYPE public.realpay_transaction_type IS 'Types of RealPay transactions';
COMMENT ON TYPE public.namfisa_license_type IS 'Types of NAMFISA licenses';
COMMENT ON TYPE public.namfisa_license_status IS 'Status of NAMFISA licenses';
COMMENT ON TYPE public.namfisa_sandbox_phase IS 'Phases of NAMFISA sandbox program';
COMMENT ON TYPE public.compliance_type IS 'Types of compliance requirements';
COMMENT ON TYPE public.risk_level IS 'Levels of risk assessment';
COMMENT ON TYPE public.audit_action IS 'Actions that can be audited';
COMMENT ON TYPE public.log_level IS 'Levels of logging severity';
COMMENT ON TYPE public.security_event IS 'Types of security events';
COMMENT ON TYPE public.activity_type IS 'Types of user activities';
COMMENT ON TYPE public.email_type IS 'Types of email communications';
COMMENT ON TYPE public.email_status IS 'Status of email delivery';
COMMENT ON TYPE public.sms_type IS 'Types of SMS communications';
COMMENT ON TYPE public.sms_status IS 'Status of SMS delivery';
COMMENT ON TYPE public.whatsapp_message_type IS 'Types of WhatsApp messages';
COMMENT ON TYPE public.whatsapp_status IS 'Status of WhatsApp message delivery';
COMMENT ON TYPE public.config_type IS 'Types of configuration values';
COMMENT ON TYPE public.config_category IS 'Categories of configuration settings';
COMMENT ON TYPE public.collection_status IS 'Status of collection processes';
COMMENT ON TYPE public.collection_method IS 'Methods of loan collection';
COMMENT ON TYPE public.reconciliation_status IS 'Status of reconciliation processes';
COMMENT ON TYPE public.report_type IS 'Types of reports that can be generated';
COMMENT ON TYPE public.report_status IS 'Status of report generation';
COMMENT ON TYPE public.report_format IS 'Formats for report output';
COMMENT ON TYPE public.analytics_type IS 'Types of analytics data';
COMMENT ON TYPE public.metric_type IS 'Types of metrics collection';
COMMENT ON TYPE public.performance_type IS 'Types of performance measurements';
COMMENT ON TYPE public.error_type IS 'Types of system errors';
COMMENT ON TYPE public.exception_type IS 'Types of system exceptions';
COMMENT ON TYPE public.incident_type IS 'Types of system incidents';
COMMENT ON TYPE public.breach_type IS 'Types of security breaches';
COMMENT ON TYPE public.vulnerability_type IS 'Types of security vulnerabilities';
COMMENT ON TYPE public.threat_type IS 'Types of security threats';
COMMENT ON TYPE public.address_type IS 'Composite type for address information';
COMMENT ON TYPE public.contact_info_type IS 'Composite type for contact information';
COMMENT ON TYPE public.loan_terms_type IS 'Composite type for loan terms';
COMMENT ON TYPE public.payment_schedule_type IS 'Composite type for payment schedules';
COMMENT ON DOMAIN public.phone_number IS 'Domain for Namibian phone numbers';
COMMENT ON DOMAIN public.email_address IS 'Domain for email addresses';
COMMENT ON DOMAIN public.namibian_id_number IS 'Domain for Namibian ID numbers';
COMMENT ON DOMAIN public.currency_amount IS 'Domain for currency amounts';
COMMENT ON DOMAIN public.percentage IS 'Domain for percentage values';
\n-- End of buffrlend-starter/supabase/migrations/13_database_enums.sql --\n
-- SendGrid RLS Policies
-- This migration creates Row Level Security policies for all SendGrid-related tables

-- Enable RLS on all SendGrid tables
ALTER TABLE sendgrid_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_senders ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_domains ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_ip_pools ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_ips ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_webhook_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_delivery_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_bounces ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_suppressions ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_unsubscribes ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_campaign_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_template_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_domain_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_ip_analytics ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_link_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_open_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_click_tracking ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_suppression_lists ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_suppression_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_bounce_management ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_compliance ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_suppression_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_campaign_recipients ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_automation_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_automation_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_automation_executions ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_ab_tests ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_versions ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_tag_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_tests ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_approvals ENABLE ROW LEVEL SECURITY;
ALTER TABLE sendgrid_template_blocks ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_reputation_scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_deliverability_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_ip_warmup ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_domain_auth ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_reputation_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_blacklist_monitoring ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_reputation_rules ENABLE ROW LEVEL SECURITY;

-- SendGrid Configuration Policies
CREATE POLICY "Admin users can manage sendgrid config" ON sendgrid_config
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Templates Policies
CREATE POLICY "Admin users can manage sendgrid templates" ON sendgrid_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Senders Policies
CREATE POLICY "Admin users can manage sendgrid senders" ON sendgrid_senders
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Domains Policies
CREATE POLICY "Admin users can manage sendgrid domains" ON sendgrid_domains
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid IP Pools Policies
CREATE POLICY "Admin users can manage sendgrid ip pools" ON sendgrid_ip_pools
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid IPs Policies
CREATE POLICY "Admin users can manage sendgrid ips" ON sendgrid_ips
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Settings Policies
CREATE POLICY "Admin users can manage sendgrid settings" ON sendgrid_settings
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Webhook Events Policies
CREATE POLICY "Admin users can view sendgrid webhook events" ON sendgrid_webhook_events
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Delivery Status Policies
CREATE POLICY "Admin users can view email delivery status" ON email_delivery_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Bounces Policies
CREATE POLICY "Admin users can manage email bounces" ON email_bounces
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Suppressions Policies
CREATE POLICY "Admin users can manage email suppressions" ON email_suppressions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Unsubscribes Policies
CREATE POLICY "Admin users can manage email unsubscribes" ON email_unsubscribes
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Analytics Policies
CREATE POLICY "Admin users can view email analytics" ON email_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Campaign Analytics Policies
CREATE POLICY "Admin users can view email campaign analytics" ON email_campaign_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Template Analytics Policies
CREATE POLICY "Admin users can view email template analytics" ON email_template_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Domain Analytics Policies
CREATE POLICY "Admin users can view email domain analytics" ON email_domain_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email IP Analytics Policies
CREATE POLICY "Admin users can view email ip analytics" ON email_ip_analytics
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Link Tracking Policies
CREATE POLICY "Admin users can view email link tracking" ON email_link_tracking
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Open Tracking Policies
CREATE POLICY "Admin users can view email open tracking" ON email_open_tracking
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Click Tracking Policies
CREATE POLICY "Admin users can view email click tracking" ON email_click_tracking
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Suppression Lists Policies
CREATE POLICY "Admin users can manage email suppression lists" ON email_suppression_lists
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Suppression Entries Policies
CREATE POLICY "Admin users can manage email suppression entries" ON email_suppression_entries
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Bounce Management Policies
CREATE POLICY "Admin users can manage email bounce management" ON email_bounce_management
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Compliance Policies
CREATE POLICY "Admin users can manage email compliance" ON email_compliance
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Reputation Monitoring Policies
CREATE POLICY "Admin users can manage email reputation monitoring" ON email_reputation_monitoring
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Suppression Rules Policies
CREATE POLICY "Admin users can manage email suppression rules" ON email_suppression_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Campaigns Policies
CREATE POLICY "Admin users can manage email campaigns" ON email_campaigns
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Campaign Recipients Policies
CREATE POLICY "Admin users can manage email campaign recipients" ON email_campaign_recipients
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Automation Rules Policies
CREATE POLICY "Admin users can manage email automation rules" ON email_automation_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Automation Workflows Policies
CREATE POLICY "Admin users can manage email automation workflows" ON email_automation_workflows
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Automation Executions Policies
CREATE POLICY "Admin users can view email automation executions" ON email_automation_executions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email A/B Tests Policies
CREATE POLICY "Admin users can manage email ab tests" ON email_ab_tests
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Versions Policies
CREATE POLICY "Admin users can manage sendgrid template versions" ON sendgrid_template_versions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Categories Policies
CREATE POLICY "Admin users can manage sendgrid template categories" ON sendgrid_template_categories
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Tags Policies
CREATE POLICY "Admin users can manage sendgrid template tags" ON sendgrid_template_tags
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Tag Assignments Policies
CREATE POLICY "Admin users can manage sendgrid template tag assignments" ON sendgrid_template_tag_assignments
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Usage Policies
CREATE POLICY "Admin users can view sendgrid template usage" ON sendgrid_template_usage
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Tests Policies
CREATE POLICY "Admin users can manage sendgrid template tests" ON sendgrid_template_tests
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Approvals Policies
CREATE POLICY "Admin users can manage sendgrid template approvals" ON sendgrid_template_approvals
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- SendGrid Template Blocks Policies
CREATE POLICY "Admin users can manage sendgrid template blocks" ON sendgrid_template_blocks
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Reputation Scores Policies
CREATE POLICY "Admin users can manage email reputation scores" ON email_reputation_scores
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Deliverability Alerts Policies
CREATE POLICY "Admin users can manage email deliverability alerts" ON email_deliverability_alerts
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email IP Warmup Policies
CREATE POLICY "Admin users can manage email ip warmup" ON email_ip_warmup
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Domain Auth Policies
CREATE POLICY "Admin users can manage email domain auth" ON email_domain_auth
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Reputation History Policies
CREATE POLICY "Admin users can view email reputation history" ON email_reputation_history
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Blacklist Monitoring Policies
CREATE POLICY "Admin users can manage email blacklist monitoring" ON email_blacklist_monitoring
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );

-- Email Reputation Rules Policies
CREATE POLICY "Admin users can manage email reputation rules" ON email_reputation_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM admin_users 
            WHERE admin_users.id = auth.uid() 
            AND admin_users.is_active = true
        )
    );
\n-- End of buffrlend-starter/supabase/migrations/25_sendgrid_rls_policies.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/supabase/migrations/01_unified_audit_logs.sql --\n
-- =====================================================
-- BuffrLend Security Features and Monitoring
-- =====================================================
-- Description: Advanced security features, monitoring, and threat detection
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- SECURITY MONITORING TABLES
-- =====================================================

-- Security events table
CREATE TABLE IF NOT EXISTS public.security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    user_id TEXT,
    ip_address INET,
    user_agent TEXT,
    event_data JSONB,
    risk_score INTEGER DEFAULT 0 CHECK (risk_score >= 0 AND risk_score <= 100),
    is_resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolved_by TEXT,
    resolution_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Failed login attempts table
CREATE TABLE IF NOT EXISTS public.failed_login_attempts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    email TEXT,
    ip_address INET,
    user_agent TEXT,
    failure_reason VARCHAR(100),
    attempt_count INTEGER DEFAULT 1,
    is_blocked BOOLEAN DEFAULT FALSE,
    block_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Suspicious activities table
CREATE TABLE IF NOT EXISTS public.suspicious_activities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    activity_type VARCHAR(100) NOT NULL,
    user_id TEXT,
    ip_address INET,
    description TEXT,
    risk_level VARCHAR(20) NOT NULL CHECK (risk_level IN ('low', 'medium', 'high', 'critical')),
    is_investigated BOOLEAN DEFAULT FALSE,
    investigated_by TEXT,
    investigation_notes TEXT,
    is_resolved BOOLEAN DEFAULT FALSE,
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolved_by TEXT,
    resolution_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Security alerts table
CREATE TABLE IF NOT EXISTS public.security_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_type VARCHAR(100) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    title TEXT NOT NULL,
    description TEXT,
    user_id TEXT,
    ip_address INET,
    alert_data JSONB,
    is_acknowledged BOOLEAN DEFAULT FALSE,
    acknowledged_by TEXT,
    acknowledged_at TIMESTAMP WITH TIME ZONE,
    is_resolved BOOLEAN DEFAULT FALSE,
    resolved_by TEXT,
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolution_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- IP whitelist table
CREATE TABLE IF NOT EXISTS public.ip_whitelist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- IP blacklist table
CREATE TABLE IF NOT EXISTS public.ip_blacklist (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    reason TEXT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Device fingerprinting table
CREATE TABLE IF NOT EXISTS public.device_fingerprints (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    fingerprint_hash VARCHAR(255) NOT NULL,
    device_info JSONB,
    is_trusted BOOLEAN DEFAULT FALSE,
    trust_level INTEGER DEFAULT 0 CHECK (trust_level >= 0 AND trust_level <= 100),
    last_seen TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, fingerprint_hash)
);

-- =====================================================
-- SECURITY FUNCTIONS
-- =====================================================

-- Function to detect suspicious login patterns
CREATE OR REPLACE FUNCTION public.detect_suspicious_login(
    p_user_id TEXT,
    p_ip_address INET,
    p_user_agent TEXT
)
RETURNS JSONB AS $$
DECLARE
    recent_attempts INTEGER;
    different_ips INTEGER;
    different_agents INTEGER;
    risk_score INTEGER := 0;
    is_suspicious BOOLEAN := FALSE;
    result JSONB;
BEGIN
    -- Count recent failed attempts
    SELECT COUNT(*) INTO recent_attempts
    FROM public.failed_login_attempts 
    WHERE user_id = p_user_id 
    AND created_at >= CURRENT_TIMESTAMP - INTERVAL '1 hour';
    
    -- Count different IPs in last 24 hours
    SELECT COUNT(DISTINCT ip_address) INTO different_ips
    FROM public.failed_login_attempts 
    WHERE user_id = p_user_id 
    AND created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours';
    
    -- Count different user agents in last 24 hours
    SELECT COUNT(DISTINCT user_agent) INTO different_agents
    FROM public.failed_login_attempts 
    WHERE user_id = p_user_id 
    AND created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours';
    
    -- Calculate risk score
    IF recent_attempts >= 5 THEN
        risk_score := risk_score + 30;
    END IF;
    
    IF different_ips >= 3 THEN
        risk_score := risk_score + 25;
    END IF;
    
    IF different_agents >= 3 THEN
        risk_score := risk_score + 20;
    END IF;
    
    -- Check if IP is blacklisted
    IF EXISTS(SELECT 1 FROM public.ip_blacklist WHERE ip_address = p_ip_address AND is_active = TRUE) THEN
        risk_score := risk_score + 50;
    END IF;
    
    -- Determine if suspicious
    is_suspicious := risk_score >= 50;
    
    result := jsonb_build_object(
        'is_suspicious', is_suspicious,
        'risk_score', risk_score,
        'recent_attempts', recent_attempts,
        'different_ips', different_ips,
        'different_agents', different_agents
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to record security event
CREATE OR REPLACE FUNCTION public.record_security_event(
    p_event_type VARCHAR(100),
    p_severity VARCHAR(20),
    p_user_id TEXT,
    p_ip_address INET,
    p_user_agent TEXT,
    p_event_data JSONB
)
RETURNS UUID AS $$
DECLARE
    event_id UUID;
    risk_score INTEGER := 0;
BEGIN
    -- Calculate risk score based on event type
    CASE p_event_type
        WHEN 'failed_login' THEN risk_score := 20;
        WHEN 'multiple_failed_logins' THEN risk_score := 40;
        WHEN 'suspicious_ip' THEN risk_score := 60;
        WHEN 'unusual_activity' THEN risk_score := 30;
        WHEN 'data_breach_attempt' THEN risk_score := 80;
        WHEN 'unauthorized_access' THEN risk_score := 70;
        ELSE risk_score := 10;
    END CASE;
    
    -- Insert security event
    INSERT INTO public.security_events (
        event_type, severity, user_id, ip_address, user_agent, 
        event_data, risk_score
    ) VALUES (
        p_event_type, p_severity, p_user_id, p_ip_address, p_user_agent,
        p_event_data, risk_score
    ) RETURNING id INTO event_id;
    
    -- Create security alert if high risk
    IF risk_score >= 50 THEN
        INSERT INTO public.security_alerts (
            alert_type, severity, title, description, user_id, ip_address, alert_data
        ) VALUES (
            p_event_type, p_severity, 
            'Security Event: ' || p_event_type,
            'A security event has been detected: ' || p_event_type,
            p_user_id, p_ip_address, p_event_data
        );
    END IF;
    
    RETURN event_id;
END;
$$ LANGUAGE plpgsql;

-- Function to check IP reputation
CREATE OR REPLACE FUNCTION public.check_ip_reputation(p_ip_address INET)
RETURNS JSONB AS $$
DECLARE
    is_whitelisted BOOLEAN := FALSE;
    is_blacklisted BOOLEAN := FALSE;
    blacklist_reason TEXT;
    result JSONB;
BEGIN
    -- Check whitelist
    SELECT EXISTS(
        SELECT 1 FROM public.ip_whitelist 
        WHERE ip_address = p_ip_address AND is_active = TRUE
    ) INTO is_whitelisted;
    
    -- Check blacklist
    SELECT EXISTS(
        SELECT 1 FROM public.ip_blacklist 
        WHERE ip_address = p_ip_address AND is_active = TRUE
    ), reason INTO is_blacklisted, blacklist_reason
    FROM public.ip_blacklist 
    WHERE ip_address = p_ip_address AND is_active = TRUE;
    
    result := jsonb_build_object(
        'is_whitelisted', is_whitelisted,
        'is_blacklisted', is_blacklisted,
        'blacklist_reason', blacklist_reason,
        'is_safe', is_whitelisted OR NOT is_blacklisted
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to generate device fingerprint
CREATE OR REPLACE FUNCTION public.generate_device_fingerprint(
    p_user_agent TEXT,
    p_screen_resolution TEXT,
    p_timezone TEXT,
    p_language TEXT
)
RETURNS TEXT AS $$
DECLARE
    fingerprint_data TEXT;
    fingerprint_hash TEXT;
BEGIN
    -- Combine device information
    fingerprint_data := p_user_agent || '|' || 
                       COALESCE(p_screen_resolution, '') || '|' || 
                       COALESCE(p_timezone, '') || '|' || 
                       COALESCE(p_language, '');
    
    -- Generate hash
    fingerprint_hash := encode(digest(fingerprint_data, 'sha256'), 'hex');
    
    RETURN fingerprint_hash;
END;
$$ LANGUAGE plpgsql;

-- Function to check device trust
CREATE OR REPLACE FUNCTION public.check_device_trust(
    p_user_id TEXT,
    p_fingerprint_hash TEXT
)
RETURNS JSONB AS $$
DECLARE
    device_record RECORD;
    is_trusted BOOLEAN := FALSE;
    trust_level INTEGER := 0;
    result JSONB;
BEGIN
    -- Get device record
    SELECT * INTO device_record 
    FROM public.device_fingerprints 
    WHERE user_id = p_user_id AND fingerprint_hash = p_fingerprint_hash;
    
    IF device_record IS NOT NULL THEN
        is_trusted := device_record.is_trusted;
        trust_level := device_record.trust_level;
        
        -- Update last seen
        UPDATE public.device_fingerprints 
        SET last_seen = CURRENT_TIMESTAMP 
        WHERE id = device_record.id;
    END IF;
    
    result := jsonb_build_object(
        'is_known_device', device_record IS NOT NULL,
        'is_trusted', is_trusted,
        'trust_level', trust_level,
        'last_seen', device_record.last_seen
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup old security data
CREATE OR REPLACE FUNCTION public.cleanup_security_data()
RETURNS VOID AS $$
BEGIN
    -- Cleanup old failed login attempts (keep for 30 days)
    DELETE FROM public.failed_login_attempts 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
    
    -- Cleanup old security events (keep for 90 days)
    DELETE FROM public.security_events 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '90 days';
    
    -- Cleanup old suspicious activities (keep for 60 days)
    DELETE FROM public.suspicious_activities 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '60 days';
    
    -- Cleanup old security alerts (keep for 30 days)
    DELETE FROM public.security_alerts 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
    
    -- Cleanup old device fingerprints (keep for 1 year)
    DELETE FROM public.device_fingerprints 
    WHERE last_seen < CURRENT_TIMESTAMP - INTERVAL '1 year';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- SECURITY TRIGGERS
-- =====================================================

-- Trigger function for failed login attempts
CREATE OR REPLACE FUNCTION public.handle_failed_login()
RETURNS TRIGGER AS $$
DECLARE
    suspicious_result JSONB;
    event_id UUID;
BEGIN
    -- Check for suspicious patterns
    suspicious_result := public.detect_suspicious_login(
        NEW.user_id, NEW.ip_address, NEW.user_agent
    );
    
    -- Record security event if suspicious
    IF (suspicious_result->>'is_suspicious')::BOOLEAN THEN
        event_id := public.record_security_event(
            'failed_login', 'medium', NEW.user_id, NEW.ip_address, 
            NEW.user_agent, suspicious_result
        );
        
        -- Create suspicious activity record
        INSERT INTO public.suspicious_activities (
            activity_type, user_id, ip_address, description, risk_level
        ) VALUES (
            'failed_login', NEW.user_id, NEW.ip_address,
            'Multiple failed login attempts detected', 'medium'
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_handle_failed_login
    AFTER INSERT ON public.failed_login_attempts
    FOR EACH ROW EXECUTE FUNCTION public.handle_failed_login();

-- =====================================================
-- RLS POLICIES FOR SECURITY TABLES
-- =====================================================

-- Enable RLS on security tables
ALTER TABLE public.security_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.failed_login_attempts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.suspicious_activities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.security_alerts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ip_whitelist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ip_blacklist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.device_fingerprints ENABLE ROW LEVEL SECURITY;

-- Security events policies
CREATE POLICY "Admin users can view security events" ON public.security_events
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "System can insert security events" ON public.security_events
    FOR INSERT WITH CHECK (true);

-- Failed login attempts policies
CREATE POLICY "Users can view own failed login attempts" ON public.failed_login_attempts
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all failed login attempts" ON public.failed_login_attempts
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "System can insert failed login attempts" ON public.failed_login_attempts
    FOR INSERT WITH CHECK (true);

-- Suspicious activities policies
CREATE POLICY "Admin users can view suspicious activities" ON public.suspicious_activities
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can modify suspicious activities" ON public.suspicious_activities
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Security alerts policies
CREATE POLICY "Admin users can view security alerts" ON public.security_alerts
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can modify security alerts" ON public.security_alerts
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- IP whitelist policies
CREATE POLICY "Admin users can manage IP whitelist" ON public.ip_whitelist
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- IP blacklist policies
CREATE POLICY "Admin users can manage IP blacklist" ON public.ip_blacklist
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Device fingerprints policies
CREATE POLICY "Users can view own device fingerprints" ON public.device_fingerprints
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "System can manage device fingerprints" ON public.device_fingerprints
    FOR ALL USING (true);

-- =====================================================
-- INDEXES FOR SECURITY TABLES
-- =====================================================

-- Security events indexes
CREATE INDEX IF NOT EXISTS idx_security_events_event_type ON public.security_events(event_type);
CREATE INDEX IF NOT EXISTS idx_security_events_severity ON public.security_events(severity);
CREATE INDEX IF NOT EXISTS idx_security_events_user_id ON public.security_events(user_id);
CREATE INDEX IF NOT EXISTS idx_security_events_ip_address ON public.security_events(ip_address);
CREATE INDEX IF NOT EXISTS idx_security_events_created_at ON public.security_events(created_at);
CREATE INDEX IF NOT EXISTS idx_security_events_risk_score ON public.security_events(risk_score);

-- Failed login attempts indexes
CREATE INDEX IF NOT EXISTS idx_failed_login_attempts_user_id ON public.failed_login_attempts(user_id);
CREATE INDEX IF NOT EXISTS idx_failed_login_attempts_ip_address ON public.failed_login_attempts(ip_address);
CREATE INDEX IF NOT EXISTS idx_failed_login_attempts_created_at ON public.failed_login_attempts(created_at);
CREATE INDEX IF NOT EXISTS idx_failed_login_attempts_is_blocked ON public.failed_login_attempts(is_blocked);

-- Suspicious activities indexes
CREATE INDEX IF NOT EXISTS idx_suspicious_activities_activity_type ON public.suspicious_activities(activity_type);
CREATE INDEX IF NOT EXISTS idx_suspicious_activities_user_id ON public.suspicious_activities(user_id);
CREATE INDEX IF NOT EXISTS idx_suspicious_activities_ip_address ON public.suspicious_activities(ip_address);
CREATE INDEX IF NOT EXISTS idx_suspicious_activities_risk_level ON public.suspicious_activities(risk_level);
CREATE INDEX IF NOT EXISTS idx_suspicious_activities_created_at ON public.suspicious_activities(created_at);

-- Security alerts indexes
CREATE INDEX IF NOT EXISTS idx_security_alerts_alert_type ON public.security_alerts(alert_type);
CREATE INDEX IF NOT EXISTS idx_security_alerts_severity ON public.security_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_security_alerts_user_id ON public.security_alerts(user_id);
CREATE INDEX IF NOT EXISTS idx_security_alerts_created_at ON public.security_alerts(created_at);
CREATE INDEX IF NOT EXISTS idx_security_alerts_is_acknowledged ON public.security_alerts(is_acknowledged);

-- IP whitelist indexes
CREATE INDEX IF NOT EXISTS idx_ip_whitelist_ip_address ON public.ip_whitelist(ip_address);
CREATE INDEX IF NOT EXISTS idx_ip_whitelist_is_active ON public.ip_whitelist(is_active);

-- IP blacklist indexes
CREATE INDEX IF NOT EXISTS idx_ip_blacklist_ip_address ON public.ip_blacklist(ip_address);
CREATE INDEX IF NOT EXISTS idx_ip_blacklist_is_active ON public.ip_blacklist(is_active);
CREATE INDEX IF NOT EXISTS idx_ip_blacklist_expires_at ON public.ip_blacklist(expires_at);

-- Device fingerprints indexes
CREATE INDEX IF NOT EXISTS idx_device_fingerprints_user_id ON public.device_fingerprints(user_id);
CREATE INDEX IF NOT EXISTS idx_device_fingerprints_fingerprint_hash ON public.device_fingerprints(fingerprint_hash);
CREATE INDEX IF NOT EXISTS idx_device_fingerprints_is_trusted ON public.device_fingerprints(is_trusted);
CREATE INDEX IF NOT EXISTS idx_device_fingerprints_last_seen ON public.device_fingerprints(last_seen);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.security_events IS 'Security events and incidents tracking';
COMMENT ON TABLE public.failed_login_attempts IS 'Failed login attempts tracking';
COMMENT ON TABLE public.suspicious_activities IS 'Suspicious activities monitoring';
COMMENT ON TABLE public.security_alerts IS 'Security alerts and notifications';
COMMENT ON TABLE public.ip_whitelist IS 'IP addresses whitelist';
COMMENT ON TABLE public.ip_blacklist IS 'IP addresses blacklist';
COMMENT ON TABLE public.device_fingerprints IS 'Device fingerprinting for security';
COMMENT ON FUNCTION public.detect_suspicious_login(TEXT, INET, TEXT) IS 'Detects suspicious login patterns';
COMMENT ON FUNCTION public.record_security_event(VARCHAR, VARCHAR, TEXT, INET, TEXT, JSONB) IS 'Records security events';
COMMENT ON FUNCTION public.check_ip_reputation(INET) IS 'Checks IP address reputation';
COMMENT ON FUNCTION public.generate_device_fingerprint(TEXT, TEXT, TEXT, TEXT) IS 'Generates device fingerprint hash';
COMMENT ON FUNCTION public.check_device_trust(TEXT, TEXT) IS 'Checks device trust level';
COMMENT ON FUNCTION public.cleanup_security_data() IS 'Cleans up old security data';
\n-- End of buffrlend-starter/supabase/migrations/16_security_features.sql --\n
-- Email Suppression and Bounce Management
-- This migration creates tables for managing email suppressions, bounces, and compliance

-- Email Suppression Lists (Global)
CREATE TABLE IF NOT EXISTS email_suppression_lists (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    list_name TEXT NOT NULL UNIQUE,
    list_type TEXT NOT NULL CHECK (list_type IN ('bounce', 'block', 'spam', 'unsubscribe', 'manual', 'compliance')),
    description TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Email Suppression Entries
CREATE TABLE IF NOT EXISTS email_suppression_entries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    suppression_list_id UUID REFERENCES email_suppression_lists(id),
    suppression_type TEXT NOT NULL CHECK (suppression_type IN ('bounce', 'block', 'spam', 'unsubscribe', 'manual', 'compliance')),
    reason TEXT,
    source TEXT DEFAULT 'sendgrid',
    is_active BOOLEAN DEFAULT true,
    suppressed_at TIMESTAMP WITH TIME ZONE NOT NULL,
    unsuppressed_at TIMESTAMP WITH TIME ZONE,
    unsuppressed_by UUID REFERENCES auth.users(id),
    unsuppression_reason TEXT,
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Bounce Management
CREATE TABLE IF NOT EXISTS email_bounce_management (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    bounce_type TEXT NOT NULL CHECK (bounce_type IN ('hard', 'soft', 'block', 'spam', 'invalid')),
    bounce_reason TEXT,
    bounce_code TEXT,
    bounce_description TEXT,
    first_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    last_bounce_at TIMESTAMP WITH TIME ZONE NOT NULL,
    bounce_count INTEGER DEFAULT 1,
    is_suppressed BOOLEAN DEFAULT false,
    suppression_reason TEXT,
    suppressed_at TIMESTAMP WITH TIME ZONE,
    suppressed_by UUID REFERENCES auth.users(id),
    raw_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Compliance Management
CREATE TABLE IF NOT EXISTS email_compliance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email TEXT NOT NULL,
    compliance_type TEXT NOT NULL CHECK (compliance_type IN ('gdpr', 'ccpa', 'can_spam', 'casl', 'other')),
    compliance_status TEXT NOT NULL CHECK (compliance_status IN ('compliant', 'non_compliant', 'pending', 'exempt')),
    consent_given BOOLEAN DEFAULT false,
    consent_date TIMESTAMP WITH TIME ZONE,
    consent_method TEXT,
    consent_source TEXT,
    opt_out_date TIMESTAMP WITH TIME ZONE,
    opt_out_method TEXT,
    opt_out_source TEXT,
    data_retention_until TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    ip_address INET,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    reputation_status TEXT DEFAULT 'unknown' CHECK (reputation_status IN ('excellent', 'good', 'fair', 'poor', 'bad', 'unknown')),
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    complaint_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    next_check_at TIMESTAMP WITH TIME ZONE,
    is_monitored BOOLEAN DEFAULT true,
    alerts_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Suppression Rules
CREATE TABLE IF NOT EXISTS email_suppression_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name TEXT NOT NULL,
    rule_type TEXT NOT NULL CHECK (rule_type IN ('automatic', 'manual', 'scheduled')),
    conditions JSONB NOT NULL,
    actions JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    priority INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_suppression_lists_type ON email_suppression_lists(list_type);
CREATE INDEX IF NOT EXISTS idx_email_suppression_entries_email ON email_suppression_entries(email);
CREATE INDEX IF NOT EXISTS idx_email_suppression_entries_type ON email_suppression_entries(suppression_type);
CREATE INDEX IF NOT EXISTS idx_email_bounce_management_email ON email_bounce_management(email);
CREATE INDEX IF NOT EXISTS idx_email_bounce_management_type ON email_bounce_management(bounce_type);
CREATE INDEX IF NOT EXISTS idx_email_compliance_email ON email_compliance(email);
CREATE INDEX IF NOT EXISTS idx_email_compliance_type ON email_compliance(compliance_type);
CREATE INDEX IF NOT EXISTS idx_email_reputation_monitoring_domain ON email_reputation_monitoring(domain);
CREATE INDEX IF NOT EXISTS idx_email_reputation_monitoring_ip ON email_reputation_monitoring(ip_address);
CREATE INDEX IF NOT EXISTS idx_email_suppression_rules_type ON email_suppression_rules(rule_type);

-- Triggers for updated_at
CREATE TRIGGER update_email_suppression_lists_updated_at BEFORE UPDATE ON email_suppression_lists FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_suppression_entries_updated_at BEFORE UPDATE ON email_suppression_entries FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_bounce_management_updated_at BEFORE UPDATE ON email_bounce_management FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_compliance_updated_at BEFORE UPDATE ON email_compliance FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_reputation_monitoring_updated_at BEFORE UPDATE ON email_reputation_monitoring FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_suppression_rules_updated_at BEFORE UPDATE ON email_suppression_rules FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert default suppression lists
INSERT INTO email_suppression_lists (list_name, list_type, description) VALUES
('Global Bounce List', 'bounce', 'Global list of bounced email addresses'),
('Global Block List', 'block', 'Global list of blocked email addresses'),
('Global Spam List', 'spam', 'Global list of spam-reported email addresses'),
('Global Unsubscribe List', 'unsubscribe', 'Global list of unsubscribed email addresses'),
('Manual Suppression List', 'manual', 'Manually managed suppression list'),
('Compliance List', 'compliance', 'Compliance-related suppressions')
ON CONFLICT (list_name) DO NOTHING;
\n-- End of buffrlend-starter/supabase/migrations/21_email_suppression_management.sql --\n
-- Email Reputation Monitoring
-- This migration creates tables for monitoring email reputation, deliverability, and performance

-- Email Reputation Scores
CREATE TABLE IF NOT EXISTS email_reputation_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    ip_address INET,
    reputation_score NUMERIC(3,2) DEFAULT 0.00,
    reputation_status TEXT DEFAULT 'unknown' CHECK (reputation_status IN ('excellent', 'good', 'fair', 'poor', 'bad', 'unknown')),
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    complaint_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    next_check_at TIMESTAMP WITH TIME ZONE,
    is_monitored BOOLEAN DEFAULT true,
    alerts_enabled BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Deliverability Alerts
CREATE TABLE IF NOT EXISTS email_deliverability_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    alert_type TEXT NOT NULL CHECK (alert_type IN ('bounce_rate_high', 'complaint_rate_high', 'spam_rate_high', 'delivery_rate_low', 'reputation_degraded', 'ip_blacklisted', 'domain_blacklisted')),
    severity TEXT NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),
    domain TEXT,
    ip_address INET,
    alert_message TEXT NOT NULL,
    alert_data JSONB DEFAULT '{}'::jsonb,
    is_resolved BOOLEAN DEFAULT false,
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolved_by UUID REFERENCES auth.users(id),
    resolution_notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email IP Warmup
CREATE TABLE IF NOT EXISTS email_ip_warmup (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ip_address INET NOT NULL UNIQUE,
    warmup_status TEXT DEFAULT 'pending' CHECK (warmup_status IN ('pending', 'warming', 'completed', 'failed', 'cancelled')),
    warmup_start_date TIMESTAMP WITH TIME ZONE,
    warmup_end_date TIMESTAMP WITH TIME ZONE,
    current_volume INTEGER DEFAULT 0,
    target_volume INTEGER DEFAULT 0,
    warmup_schedule JSONB DEFAULT '{}'::jsonb,
    warmup_progress NUMERIC(5,2) DEFAULT 0.00,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Domain Authentication
CREATE TABLE IF NOT EXISTS email_domain_auth (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL UNIQUE,
    dkim_public_key TEXT,
    dkim_selector TEXT,
    spf_record TEXT,
    dmarc_policy TEXT,
    dmarc_rua TEXT,
    dmarc_ruf TEXT,
    is_verified BOOLEAN DEFAULT false,
    verification_status TEXT DEFAULT 'pending' CHECK (verification_status IN ('pending', 'verified', 'failed', 'expired')),
    verification_date TIMESTAMP WITH TIME ZONE,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    next_check_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Reputation History
CREATE TABLE IF NOT EXISTS email_reputation_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT NOT NULL,
    ip_address INET,
    reputation_score NUMERIC(3,2) NOT NULL,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    complaint_rate NUMERIC(5,2) DEFAULT 0.00,
    spam_rate NUMERIC(5,2) DEFAULT 0.00,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    recorded_at TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Blacklist Monitoring
CREATE TABLE IF NOT EXISTS email_blacklist_monitoring (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    domain TEXT,
    ip_address INET,
    blacklist_name TEXT NOT NULL,
    blacklist_status TEXT NOT NULL CHECK (blacklist_status IN ('listed', 'not_listed', 'unknown', 'error')),
    blacklist_url TEXT,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    next_check_at TIMESTAMP WITH TIME ZONE,
    is_monitored BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Email Reputation Rules
CREATE TABLE IF NOT EXISTS email_reputation_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name TEXT NOT NULL,
    rule_type TEXT NOT NULL CHECK (rule_type IN ('threshold', 'trend', 'anomaly', 'schedule')),
    conditions JSONB NOT NULL,
    actions JSONB NOT NULL,
    is_active BOOLEAN DEFAULT true,
    priority INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_email_reputation_scores_domain ON email_reputation_scores(domain);
CREATE INDEX IF NOT EXISTS idx_email_reputation_scores_ip ON email_reputation_scores(ip_address);
CREATE INDEX IF NOT EXISTS idx_email_reputation_scores_status ON email_reputation_scores(reputation_status);
CREATE INDEX IF NOT EXISTS idx_email_deliverability_alerts_type ON email_deliverability_alerts(alert_type);
CREATE INDEX IF NOT EXISTS idx_email_deliverability_alerts_severity ON email_deliverability_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_email_deliverability_alerts_resolved ON email_deliverability_alerts(is_resolved);
CREATE INDEX IF NOT EXISTS idx_email_ip_warmup_status ON email_ip_warmup(warmup_status);
CREATE INDEX IF NOT EXISTS idx_email_domain_auth_domain ON email_domain_auth(domain);
CREATE INDEX IF NOT EXISTS idx_email_domain_auth_verified ON email_domain_auth(is_verified);
CREATE INDEX IF NOT EXISTS idx_email_reputation_history_domain ON email_reputation_history(domain);
CREATE INDEX IF NOT EXISTS idx_email_reputation_history_recorded ON email_reputation_history(recorded_at);
CREATE INDEX IF NOT EXISTS idx_email_blacklist_monitoring_domain ON email_blacklist_monitoring(domain);
CREATE INDEX IF NOT EXISTS idx_email_blacklist_monitoring_ip ON email_blacklist_monitoring(ip_address);
CREATE INDEX IF NOT EXISTS idx_email_reputation_rules_type ON email_reputation_rules(rule_type);

-- Triggers for updated_at
CREATE TRIGGER update_email_reputation_scores_updated_at BEFORE UPDATE ON email_reputation_scores FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_deliverability_alerts_updated_at BEFORE UPDATE ON email_deliverability_alerts FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_ip_warmup_updated_at BEFORE UPDATE ON email_ip_warmup FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_domain_auth_updated_at BEFORE UPDATE ON email_domain_auth FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_blacklist_monitoring_updated_at BEFORE UPDATE ON email_blacklist_monitoring FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_email_reputation_rules_updated_at BEFORE UPDATE ON email_reputation_rules FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/24_email_reputation_monitoring.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/supabase/migrations/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/002_create_unified_audit_logging.sql --\n
-- =====================================================
-- BuffrLend Core Tables Migration
-- =====================================================
-- Description: Creates core application tables
-- Dependencies: 01_extensions.sql
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================



-- Create partner_companies table
CREATE TABLE IF NOT EXISTS public.partner_companies (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    company_name TEXT NOT NULL,
    company_registration_number TEXT UNIQUE,
    tax_identification_number TEXT,
    industry_sector TEXT,
    company_size TEXT CHECK (company_size IN ('startup', 'small', 'medium', 'large', 'enterprise')),
    primary_contact_name TEXT NOT NULL,
    primary_contact_email TEXT NOT NULL,
    primary_contact_phone TEXT,
    secondary_contact_name TEXT,
    secondary_contact_email TEXT,
    street_address TEXT NOT NULL,
    city TEXT NOT NULL,
    state_province TEXT NOT NULL,
    postal_code TEXT NOT NULL,
    country TEXT DEFAULT 'Namibia',
    website_url TEXT,
    linkedin_url TEXT,
    partnership_status TEXT DEFAULT 'prospective' CHECK (partnership_status IN ('prospective', 'under_review', 'active', 'suspended', 'terminated')),
    partnership_tier TEXT DEFAULT 'basic' CHECK (partnership_tier IN ('basic', 'premium', 'enterprise')),
    commission_rate NUMERIC DEFAULT 0.00,
    payroll_system TEXT,
    payroll_frequency TEXT CHECK (payroll_frequency IN ('weekly', 'bi-weekly', 'monthly', 'semi-monthly')),
    next_payroll_date DATE,
    max_loan_amount NUMERIC DEFAULT 10000.00,
    interest_rate_override NUMERIC,
    max_loan_term_months INTEGER DEFAULT 5,
    minimum_tenure_months INTEGER DEFAULT 3,
    minimum_monthly_salary NUMERIC DEFAULT 3000.00,
    eligible_departments JSONB DEFAULT '[]',
    excluded_job_titles JSONB DEFAULT '[]',
    agreement_document_path TEXT,
    agreement_signed_date DATE,
    agreement_expiry_date DATE,
    credit_limit NUMERIC,
    current_exposure NUMERIC DEFAULT 0.00,
    namfisa_approved BOOLEAN DEFAULT FALSE,
    compliance_status TEXT DEFAULT 'pending' CHECK (compliance_status IN ('compliant', 'pending', 'non_compliant')),
    last_audit_date DATE,
    next_audit_date DATE,
    total_employees INTEGER DEFAULT 0,
    active_borrowers INTEGER DEFAULT 0,
    total_loans_disbursed NUMERIC DEFAULT 0.00,
    default_rate NUMERIC DEFAULT 0.00,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    admin_notes TEXT,
    logo_url TEXT,
    status VARCHAR DEFAULT 'active',
    category VARCHAR DEFAULT 'employer',
    description TEXT,
    featured BOOLEAN DEFAULT FALSE
);

-- Create loan_applications table
CREATE TABLE IF NOT EXISTS public.loan_applications (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    application_id TEXT UNIQUE NOT NULL,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    company_id UUID REFERENCES public.partner_companies(id) ON DELETE CASCADE NOT NULL,
    employee_verification_id UUID,
    loan_amount NUMERIC NOT NULL CHECK (loan_amount >= 500 AND loan_amount <= 10000),
    loan_term INTEGER DEFAULT 1 CHECK (loan_term >= 1 AND loan_term <= 5),
    interest_rate NUMERIC DEFAULT 15.00,
    monthly_payment NUMERIC,
    total_repayment NUMERIC,
    payroll_deduction_amount NUMERIC,
    payroll_deduction_start_date DATE,
    remaining_balance NUMERIC,
    employment_info JSONB,
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'submitted', 'under_review', 'approved', 'rejected', 'funded', 'active', 'completed', 'defaulted')),
    assigned_to UUID REFERENCES auth.users(id),
    admin_notes TEXT,
    kyc_verification_id UUID,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    approved_at TIMESTAMPTZ,
    funded_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    fee_breakdown JSONB,
    monthly_income NUMERIC,
    monthly_expenses NUMERIC,
    dti_ratio NUMERIC,
    affordability_score INTEGER,
    risk_category VARCHAR,
    namfisa_compliant BOOLEAN DEFAULT TRUE,
    loan_purpose TEXT,
    net_income_from_payslip NUMERIC,
    payslip_verified BOOLEAN DEFAULT FALSE,
    payslip_verification_date TIMESTAMPTZ,
    payslip_verification_notes TEXT,
    currency TEXT DEFAULT 'NAD',
    namfisa_levy NUMERIC DEFAULT 0,
    stamp_duty NUMERIC DEFAULT 5,
    collection_fee NUMERIC DEFAULT 0,
    disbursement_fee NUMERIC DEFAULT 0,
    total_fees NUMERIC DEFAULT 0,
    bond_payment_amount NUMERIC DEFAULT 0,
    coupon_payment_amount NUMERIC DEFAULT 0,
    max_loan_amount NUMERIC DEFAULT 10000,
    min_loan_amount NUMERIC DEFAULT 500,
    max_loan_term INTEGER DEFAULT 5,
    competitive_rate NUMERIC DEFAULT 15.00,
    loan_term_months INTEGER CHECK (loan_term_months >= 1 AND loan_term_months <= 5),
    net_income NUMERIC,
    total_interest NUMERIC,
    total_payable NUMERIC,
    serial_number TEXT UNIQUE
);



-- Create system_configuration table
CREATE TABLE IF NOT EXISTS public.system_configuration (
    id UUID DEFAULT extensions.uuid_generate_v4() PRIMARY KEY,
    config_key TEXT UNIQUE NOT NULL,
    config_value JSONB NOT NULL,
    config_type TEXT DEFAULT 'string' CHECK (config_type IN ('string', 'number', 'boolean', 'object', 'array')),
    description TEXT,
    category TEXT,
    is_sensitive BOOLEAN DEFAULT FALSE,
    updated_by UUID REFERENCES public.profiles(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for performance


CREATE INDEX IF NOT EXISTS idx_partner_companies_name ON public.partner_companies(company_name);
CREATE INDEX IF NOT EXISTS idx_partner_companies_status ON public.partner_companies(partnership_status);
CREATE INDEX IF NOT EXISTS idx_partner_companies_tier ON public.partner_companies(partnership_tier);

CREATE INDEX IF NOT EXISTS idx_loan_applications_user_id ON public.loan_applications(user_id);
CREATE INDEX IF NOT EXISTS idx_loan_applications_company_id ON public.loan_applications(company_id);
CREATE INDEX IF NOT EXISTS idx_loan_applications_status ON public.loan_applications(status);
CREATE INDEX IF NOT EXISTS idx_loan_applications_application_id ON public.loan_applications(application_id);



CREATE INDEX IF NOT EXISTS idx_system_config_key ON public.system_configuration(config_key);
CREATE INDEX IF NOT EXISTS idx_system_config_category ON public.system_configuration(category);

-- Add table comments
COMMENT ON TABLE public.profiles IS 'Extended user profiles with additional fintech-specific fields';
COMMENT ON TABLE public.partner_companies IS 'Partner companies offering salary deduction loans';
COMMENT ON TABLE public.loan_applications IS 'Loan application data and status tracking';

COMMENT ON TABLE public.system_configuration IS 'System-wide configuration settings';

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply updated_at triggers


CREATE TRIGGER update_partner_companies_updated_at
    BEFORE UPDATE ON public.partner_companies
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_loan_applications_updated_at
    BEFORE UPDATE ON public.loan_applications
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();



CREATE TRIGGER update_system_configuration_updated_at
    BEFORE UPDATE ON public.system_configuration
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/supabase/migrations/02_core_tables.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/003_create_unified_notifications_email.sql --\n
-- =====================================================
-- BuffrLend Rate Limiting and Throttling
-- =====================================================
-- Description: Rate limiting tables and functions for API and user actions
-- Dependencies: All previous migrations
-- Version: 1.0
-- Author: BuffrLend Development Team
-- =====================================================

-- =====================================================
-- RATE LIMITING TABLES
-- =====================================================

-- Rate limiting rules table
CREATE TABLE IF NOT EXISTS public.rate_limiting_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_name VARCHAR(255) NOT NULL UNIQUE,
    rule_type VARCHAR(50) NOT NULL CHECK (rule_type IN ('api', 'user_action', 'loan_application', 'kyc_submission', 'payment', 'login_attempt')),
    resource VARCHAR(255) NOT NULL,
    limit_count INTEGER NOT NULL CHECK (limit_count > 0),
    time_window_minutes INTEGER NOT NULL CHECK (time_window_minutes > 0),
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting violations table
CREATE TABLE IF NOT EXISTS public.rate_limiting_violations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    violation_count INTEGER NOT NULL DEFAULT 1,
    first_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_violation_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    is_blocked BOOLEAN NOT NULL DEFAULT FALSE,
    block_until TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Rate limiting counters table (for real-time tracking)
CREATE TABLE IF NOT EXISTS public.rate_limiting_counters (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    counter_value INTEGER NOT NULL DEFAULT 0,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, ip_address, rule_id, window_start)
);

-- Rate limiting exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT,
    ip_address INET,
    rule_id UUID NOT NULL REFERENCES public.rate_limiting_rules(id) ON DELETE CASCADE,
    exemption_reason TEXT NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    expires_at TIMESTAMP WITH TIME ZONE,
    created_by TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =====================================================
-- RATE LIMITING FUNCTIONS
-- =====================================================

-- Function to check rate limit
CREATE OR REPLACE FUNCTION public.check_rate_limit(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS JSONB AS $$
DECLARE
    rule_record RECORD;
    counter_record RECORD;
    current_count INTEGER := 0;
    is_exempted BOOLEAN := FALSE;
    is_blocked BOOLEAN := FALSE;
    block_until TIMESTAMP WITH TIME ZONE;
    result JSONB;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN jsonb_build_object(
            'allowed', TRUE,
            'reason', 'No rate limiting rule found'
        );
    END IF;
    
    -- Check if user/IP is exempted
    SELECT EXISTS(
        SELECT 1 FROM public.rate_limiting_exemptions 
        WHERE rule_id = rule_record.id 
        AND (user_id = p_user_id OR ip_address = p_ip_address)
        AND is_active = TRUE 
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    ) INTO is_exempted;
    
    IF is_exempted THEN
        RETURN jsonb_build_object(
            'allowed', TRUE,
            'reason', 'User/IP is exempted from rate limiting'
        );
    END IF;
    
    -- Check if user/IP is blocked
    SELECT is_blocked, block_until INTO is_blocked, block_until
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND is_blocked = TRUE
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    IF is_blocked AND block_until > CURRENT_TIMESTAMP THEN
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'reason', 'User/IP is blocked until ' || block_until,
            'block_until', block_until
        );
    END IF;
    
    -- Get current counter
    SELECT counter_value INTO current_count
    FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND window_start <= CURRENT_TIMESTAMP 
    AND window_end >= CURRENT_TIMESTAMP
    ORDER BY window_start DESC 
    LIMIT 1;
    
    -- Check if limit is exceeded
    IF current_count >= rule_record.limit_count THEN
        -- Record violation
        INSERT INTO public.rate_limiting_violations (
            user_id, ip_address, rule_id, violation_count, 
            first_violation_at, last_violation_at, is_blocked, block_until
        ) VALUES (
            p_user_id, p_ip_address, rule_record.id, 1,
            CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, TRUE, 
            CURRENT_TIMESTAMP + INTERVAL '1 hour'
        ) ON CONFLICT (user_id, ip_address, rule_id) 
        DO UPDATE SET 
            violation_count = rate_limiting_violations.violation_count + 1,
            last_violation_at = CURRENT_TIMESTAMP,
            is_blocked = TRUE,
            block_until = CURRENT_TIMESTAMP + INTERVAL '1 hour';
        
        RETURN jsonb_build_object(
            'allowed', FALSE,
            'reason', 'Rate limit exceeded',
            'limit', rule_record.limit_count,
            'current_count', current_count,
            'time_window_minutes', rule_record.time_window_minutes
        );
    END IF;
    
    RETURN jsonb_build_object(
        'allowed', TRUE,
        'reason', 'Rate limit not exceeded',
        'limit', rule_record.limit_count,
        'current_count', current_count + 1,
        'time_window_minutes', rule_record.time_window_minutes
    );
END;
$$ LANGUAGE plpgsql;

-- Function to increment rate limit counter
CREATE OR REPLACE FUNCTION public.increment_rate_limit_counter(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS VOID AS $$
DECLARE
    rule_record RECORD;
    window_start TIMESTAMP WITH TIME ZONE;
    window_end TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN;
    END IF;
    
    -- Calculate time window
    window_start := date_trunc('minute', CURRENT_TIMESTAMP);
    window_end := window_start + INTERVAL '1 minute' * rule_record.time_window_minutes;
    
    -- Insert or update counter
    INSERT INTO public.rate_limiting_counters (
        user_id, ip_address, rule_id, counter_value, 
        window_start, window_end
    ) VALUES (
        p_user_id, p_ip_address, rule_record.id, 1,
        window_start, window_end
    ) ON CONFLICT (user_id, ip_address, rule_id, window_start) 
    DO UPDATE SET 
        counter_value = rate_limiting_counters.counter_value + 1,
        updated_at = CURRENT_TIMESTAMP;
END;
$$ LANGUAGE plpgsql;

-- Function to reset rate limit counter
CREATE OR REPLACE FUNCTION public.reset_rate_limit_counter(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS VOID AS $$
DECLARE
    rule_record RECORD;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN;
    END IF;
    
    -- Delete counter
    DELETE FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address);
    
    -- Unblock user/IP
    UPDATE public.rate_limiting_violations 
    SET is_blocked = FALSE, block_until = NULL
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address);
END;
$$ LANGUAGE plpgsql;

-- Function to get rate limit status
CREATE OR REPLACE FUNCTION public.get_rate_limit_status(
    p_user_id TEXT,
    p_ip_address INET,
    p_rule_name VARCHAR(255)
)
RETURNS JSONB AS $$
DECLARE
    rule_record RECORD;
    counter_record RECORD;
    violation_record RECORD;
    current_count INTEGER := 0;
    is_exempted BOOLEAN := FALSE;
    is_blocked BOOLEAN := FALSE;
    block_until TIMESTAMP WITH TIME ZONE;
    result JSONB;
BEGIN
    -- Get rate limiting rule
    SELECT * INTO rule_record 
    FROM public.rate_limiting_rules 
    WHERE rule_name = p_rule_name AND is_active = TRUE;
    
    IF rule_record IS NULL THEN
        RETURN jsonb_build_object(
            'rule_exists', FALSE,
            'message', 'No rate limiting rule found'
        );
    END IF;
    
    -- Check if user/IP is exempted
    SELECT EXISTS(
        SELECT 1 FROM public.rate_limiting_exemptions 
        WHERE rule_id = rule_record.id 
        AND (user_id = p_user_id OR ip_address = p_ip_address)
        AND is_active = TRUE 
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
    ) INTO is_exempted;
    
    -- Check if user/IP is blocked
    SELECT is_blocked, block_until INTO is_blocked, block_until
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND is_blocked = TRUE
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    -- Get current counter
    SELECT counter_value INTO current_count
    FROM public.rate_limiting_counters 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    AND window_start <= CURRENT_TIMESTAMP 
    AND window_end >= CURRENT_TIMESTAMP
    ORDER BY window_start DESC 
    LIMIT 1;
    
    -- Get violation history
    SELECT violation_count, first_violation_at, last_violation_at 
    INTO violation_record
    FROM public.rate_limiting_violations 
    WHERE rule_id = rule_record.id 
    AND (user_id = p_user_id OR ip_address = p_ip_address)
    ORDER BY last_violation_at DESC 
    LIMIT 1;
    
    result := jsonb_build_object(
        'rule_name', rule_record.rule_name,
        'rule_type', rule_record.rule_type,
        'resource', rule_record.resource,
        'limit_count', rule_record.limit_count,
        'time_window_minutes', rule_record.time_window_minutes,
        'current_count', COALESCE(current_count, 0),
        'remaining_count', GREATEST(0, rule_record.limit_count - COALESCE(current_count, 0)),
        'is_exempted', is_exempted,
        'is_blocked', is_blocked,
        'block_until', block_until,
        'violation_count', COALESCE(violation_record.violation_count, 0),
        'first_violation_at', violation_record.first_violation_at,
        'last_violation_at', violation_record.last_violation_at
    );
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Function to cleanup expired rate limiting data
CREATE OR REPLACE FUNCTION public.cleanup_rate_limiting_data()
RETURNS VOID AS $$
BEGIN
    -- Cleanup expired counters
    DELETE FROM public.rate_limiting_counters 
    WHERE window_end < CURRENT_TIMESTAMP - INTERVAL '1 day';
    
    -- Cleanup expired exemptions
    DELETE FROM public.rate_limiting_exemptions 
    WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP;
    
    -- Cleanup old violations (keep for 30 days)
    DELETE FROM public.rate_limiting_violations 
    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;

-- =====================================================
-- RATE LIMITING TRIGGERS
-- =====================================================

-- Trigger function for loan applications rate limiting
CREATE OR REPLACE FUNCTION public.rate_limit_loan_applications()
RETURNS TRIGGER AS $$
DECLARE
    rate_limit_result JSONB;
BEGIN
    -- Check rate limit for loan applications
    rate_limit_result := public.check_rate_limit(
        NEW.user_id,
        NULL, -- IP address not available in trigger context
        'loan_application_per_user'
    );
    
    IF NOT (rate_limit_result->>'allowed')::BOOLEAN THEN
        RAISE EXCEPTION 'Rate limit exceeded for loan applications: %', 
            rate_limit_result->>'reason';
    END IF;
    
    -- Increment counter
    PERFORM public.increment_rate_limit_counter(
        NEW.user_id,
        NULL,
        'loan_application_per_user'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit_loan_applications
    BEFORE INSERT ON public.loan_applications
    FOR EACH ROW EXECUTE FUNCTION public.rate_limit_loan_applications();

-- Trigger function for KYC submissions rate limiting
CREATE OR REPLACE FUNCTION public.rate_limit_kyc_submissions()
RETURNS TRIGGER AS $$
DECLARE
    rate_limit_result JSONB;
BEGIN
    -- Check rate limit for KYC submissions
    rate_limit_result := public.check_rate_limit(
        NEW.user_id,
        NULL,
        'kyc_submission_per_user'
    );
    
    IF NOT (rate_limit_result->>'allowed')::BOOLEAN THEN
        RAISE EXCEPTION 'Rate limit exceeded for KYC submissions: %', 
            rate_limit_result->>'reason';
    END IF;
    
    -- Increment counter
    PERFORM public.increment_rate_limit_counter(
        NEW.user_id,
        NULL,
        'kyc_submission_per_user'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_rate_limit_kyc_submissions
    BEFORE INSERT ON public.kyc_verifications
    FOR EACH ROW EXECUTE FUNCTION public.rate_limit_kyc_submissions();

-- =====================================================
-- DEFAULT RATE LIMITING RULES
-- =====================================================

-- Insert default rate limiting rules
INSERT INTO public.rate_limiting_rules (rule_name, rule_type, resource, limit_count, time_window_minutes, description) VALUES
('api_requests_per_minute', 'api', 'api_endpoints', 100, 1, 'API requests per minute per user/IP'),
('api_requests_per_hour', 'api', 'api_endpoints', 1000, 60, 'API requests per hour per user/IP'),
('loan_application_per_user', 'loan_application', 'loan_applications', 3, 60, 'Loan applications per user per hour'),
('kyc_submission_per_user', 'kyc_submission', 'kyc_verifications', 5, 60, 'KYC submissions per user per hour'),
('payment_attempt_per_user', 'payment', 'realpay_transactions', 10, 60, 'Payment attempts per user per hour'),
('login_attempt_per_ip', 'login_attempt', 'auth_login', 5, 15, 'Login attempts per IP per 15 minutes'),
('login_attempt_per_user', 'login_attempt', 'auth_login', 3, 15, 'Login attempts per user per 15 minutes'),
('password_reset_per_user', 'user_action', 'password_reset', 3, 60, 'Password reset requests per user per hour'),
('email_verification_per_user', 'user_action', 'email_verification', 5, 60, 'Email verification requests per user per hour'),
('phone_verification_per_user', 'user_action', 'phone_verification', 3, 60, 'Phone verification requests per user per hour')
ON CONFLICT (rule_name) DO NOTHING;

-- =====================================================
-- RLS POLICIES FOR RATE LIMITING TABLES
-- =====================================================

-- Enable RLS on rate limiting tables
ALTER TABLE public.rate_limiting_rules ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_violations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_counters ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;

-- Rate limiting rules policies
CREATE POLICY "Admin users can view rate limiting rules" ON public.rate_limiting_rules
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can modify rate limiting rules" ON public.rate_limiting_rules
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- Rate limiting violations policies
CREATE POLICY "Users can view own rate limiting violations" ON public.rate_limiting_violations
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all rate limiting violations" ON public.rate_limiting_violations
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "System can insert rate limiting violations" ON public.rate_limiting_violations
    FOR INSERT WITH CHECK (true);

-- Rate limiting counters policies
CREATE POLICY "Users can view own rate limiting counters" ON public.rate_limiting_counters
    FOR SELECT USING (
        auth.uid()::text = user_id
    );

CREATE POLICY "Admin users can view all rate limiting counters" ON public.rate_limiting_counters
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "System can manage rate limiting counters" ON public.rate_limiting_counters
    FOR ALL USING (true);

-- Rate limiting exemptions policies
CREATE POLICY "Admin users can view rate limiting exemptions" ON public.rate_limiting_exemptions
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

CREATE POLICY "Admin users can modify rate limiting exemptions" ON public.rate_limiting_exemptions
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM public.admin_users 
            WHERE id = auth.uid()::text
        )
    );

-- =====================================================
-- INDEXES FOR RATE LIMITING TABLES
-- =====================================================

-- Rate limiting rules indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_rule_name ON public.rate_limiting_rules(rule_name);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_rule_type ON public.rate_limiting_rules(rule_type);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_rules_is_active ON public.rate_limiting_rules(is_active);

-- Rate limiting violations indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_user_id ON public.rate_limiting_violations(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_ip_address ON public.rate_limiting_violations(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_rule_id ON public.rate_limiting_violations(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_is_blocked ON public.rate_limiting_violations(is_blocked);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_violations_created_at ON public.rate_limiting_violations(created_at);

-- Rate limiting counters indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_user_id ON public.rate_limiting_counters(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_ip_address ON public.rate_limiting_counters(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_rule_id ON public.rate_limiting_counters(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_window_start ON public.rate_limiting_counters(window_start);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_counters_window_end ON public.rate_limiting_counters(window_end);

-- Rate limiting exemptions indexes
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_user_id ON public.rate_limiting_exemptions(user_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_ip_address ON public.rate_limiting_exemptions(ip_address);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_rule_id ON public.rate_limiting_exemptions(rule_id);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_is_active ON public.rate_limiting_exemptions(is_active);
CREATE INDEX IF NOT EXISTS idx_rate_limiting_exemptions_expires_at ON public.rate_limiting_exemptions(expires_at);

-- =====================================================
-- COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE public.rate_limiting_rules IS 'Rate limiting rules configuration';
COMMENT ON TABLE public.rate_limiting_violations IS 'Rate limiting violations tracking';
COMMENT ON TABLE public.rate_limiting_counters IS 'Real-time rate limiting counters';
COMMENT ON TABLE public.rate_limiting_exemptions IS 'Rate limiting exemptions for specific users/IPs';
COMMENT ON FUNCTION public.check_rate_limit(TEXT, INET, VARCHAR) IS 'Checks if a request is within rate limits';
COMMENT ON FUNCTION public.increment_rate_limit_counter(TEXT, INET, VARCHAR) IS 'Increments rate limit counter for a request';
COMMENT ON FUNCTION public.reset_rate_limit_counter(TEXT, INET, VARCHAR) IS 'Resets rate limit counter for a user/IP';
COMMENT ON FUNCTION public.get_rate_limit_status(TEXT, INET, VARCHAR) IS 'Gets current rate limit status for a user/IP';
COMMENT ON FUNCTION public.cleanup_rate_limiting_data() IS 'Cleans up expired rate limiting data';
\n-- End of buffrlend-starter/supabase/migrations/15_rate_limiting.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/supabase/migrations/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/supabase/migrations/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/supabase/migrations/08_unified_workflows.sql --\n
-- NAMFISA Compliance Migration
-- Creates tables for NAMFISA regulatory compliance and reporting

-- NAMFISA Compliance Table
CREATE TABLE IF NOT EXISTS namfisa_compliance (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    compliance_type VARCHAR(50) NOT NULL,
    requirement_name VARCHAR(200) NOT NULL,
    description TEXT,
    applicable_to VARCHAR(50) NOT NULL, -- 'lending', 'payments', 'kyc', 'aml'
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),
    effective_date DATE NOT NULL,
    expiry_date DATE,
    compliance_level VARCHAR(20) NOT NULL DEFAULT 'mandatory' CHECK (compliance_level IN ('mandatory', 'recommended', 'optional')),
    penalty_amount DECIMAL(15,2),
    penalty_currency VARCHAR(3) DEFAULT 'NAD',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- NAMFISA Reports Table
CREATE TABLE IF NOT EXISTS namfisa_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    report_type VARCHAR(50) NOT NULL,
    report_name VARCHAR(200) NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    submission_deadline DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'submitted', 'approved', 'rejected')),
    submission_date TIMESTAMP WITH TIME ZONE,
    approval_date TIMESTAMP WITH TIME ZONE,
    rejection_reason TEXT,
    file_path VARCHAR(500),
    file_size BIGINT,
    checksum VARCHAR(64),
    data_snapshot JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- NAMFISA Compliance Tracking Table
CREATE TABLE IF NOT EXISTS namfisa_compliance_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    compliance_id UUID REFERENCES namfisa_compliance(id),
    loan_application_id UUID REFERENCES loan_applications(id),
    customer_id UUID REFERENCES profiles(id),
    compliance_status VARCHAR(20) NOT NULL DEFAULT 'pending' CHECK (compliance_status IN ('pending', 'compliant', 'non_compliant', 'exempt')),
    compliance_date TIMESTAMP WITH TIME ZONE,
    compliance_notes TEXT,
    evidence_files JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- NAMFISA Audit Trail Table
CREATE TABLE IF NOT EXISTS namfisa_audit_trail (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    action_type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    old_values JSONB,
    new_values JSONB,
    change_reason TEXT,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Indexes for NAMFISA tables
CREATE INDEX IF NOT EXISTS idx_namfisa_compliance_type ON namfisa_compliance(compliance_type);
CREATE INDEX IF NOT EXISTS idx_namfisa_compliance_status ON namfisa_compliance(status);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_type ON namfisa_reports(report_type);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_status ON namfisa_reports(status);
CREATE INDEX IF NOT EXISTS idx_namfisa_reports_period ON namfisa_reports(reporting_period_start, reporting_period_end);
CREATE INDEX IF NOT EXISTS idx_namfisa_tracking_compliance ON namfisa_compliance_tracking(compliance_id);
CREATE INDEX IF NOT EXISTS idx_namfisa_tracking_loan ON namfisa_compliance_tracking(loan_application_id);
CREATE INDEX IF NOT EXISTS idx_namfisa_audit_entity ON namfisa_audit_trail(entity_type, entity_id);

-- NAMFISA Functions
CREATE OR REPLACE FUNCTION generate_namfisa_report(
    p_report_type VARCHAR,
    p_period_start DATE,
    p_period_end DATE
) RETURNS UUID AS $$
DECLARE
    v_report_id UUID;
    v_report_data JSONB;
BEGIN
    -- Generate report data based on type
    CASE p_report_type
        WHEN 'monthly_lending' THEN
            SELECT jsonb_build_object(
                'total_loans', COUNT(*),
                'total_amount', SUM(amount),
                'average_loan_size', AVG(amount),
                'default_rate', ROUND(
                    (COUNT(CASE WHEN status = 'defaulted' THEN 1 END)::DECIMAL / COUNT(*)) * 100, 2
                )
            ) INTO v_report_data
            FROM loan_applications
            WHERE created_at BETWEEN p_period_start AND p_period_end;
            
        WHEN 'kyc_compliance' THEN
            SELECT jsonb_build_object(
                'total_verifications', COUNT(*),
                'successful_verifications', COUNT(CASE WHEN status = 'approved' THEN 1 END),
                'pending_verifications', COUNT(CASE WHEN status = 'pending' THEN 1 END),
                'rejected_verifications', COUNT(CASE WHEN status = 'rejected' THEN 1 END)
            ) INTO v_report_data
            FROM kyc_verifications
            WHERE created_at BETWEEN p_period_start AND p_period_end;
            
        ELSE
            v_report_data := '{}'::jsonb;
    END CASE;
    
    -- Create report record
    INSERT INTO namfisa_reports (
        report_type,
        report_name,
        reporting_period_start,
        reporting_period_end,
        submission_deadline,
        data_snapshot
    ) VALUES (
        p_report_type,
        p_report_type || '_' || p_period_start || '_to_' || p_period_end,
        p_period_start,
        p_period_end,
        p_period_end + INTERVAL '30 days',
        v_report_data
    ) RETURNING id INTO v_report_id;
    
    RETURN v_report_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- NAMFISA Compliance Check Function
CREATE OR REPLACE FUNCTION check_namfisa_compliance(
    p_loan_application_id UUID
) RETURNS TABLE (
    compliance_id UUID,
    requirement_name VARCHAR,
    status VARCHAR,
    is_compliant BOOLEAN
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        nc.id,
        nc.requirement_name,
        nct.compliance_status,
        CASE WHEN nct.compliance_status = 'compliant' THEN true ELSE false END
    FROM namfisa_compliance nc
    LEFT JOIN namfisa_compliance_tracking nct ON nc.id = nct.compliance_id 
        AND nct.loan_application_id = p_loan_application_id
    WHERE nc.status = 'active' 
        AND nc.applicable_to = 'lending';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- NAMFISA Audit Function
CREATE OR REPLACE FUNCTION log_namfisa_audit(
    p_action_type VARCHAR,
    p_entity_type VARCHAR,
    p_entity_id UUID,
    p_old_values JSONB DEFAULT NULL,
    p_new_values JSONB DEFAULT NULL,
    p_change_reason TEXT DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
    v_audit_id UUID;
BEGIN
    INSERT INTO namfisa_audit_trail (
        action_type,
        entity_type,
        entity_id,
        old_values,
        new_values,
        change_reason,
        ip_address
    ) VALUES (
        p_action_type,
        p_entity_type,
        p_entity_id,
        p_old_values,
        p_new_values,
        p_change_reason,
        inet_client_addr()
    ) RETURNING id INTO v_audit_id;
    
    RETURN v_audit_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Triggers for NAMFISA tables
CREATE TRIGGER update_namfisa_compliance_updated_at
    BEFORE UPDATE ON namfisa_compliance
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_namfisa_reports_updated_at
    BEFORE UPDATE ON namfisa_reports
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_namfisa_tracking_updated_at
    BEFORE UPDATE ON namfisa_compliance_tracking
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Sample NAMFISA compliance requirements
INSERT INTO namfisa_compliance (
    compliance_type,
    requirement_name,
    description,
    applicable_to,
    status,
    effective_date,
    compliance_level,
    penalty_amount
) VALUES 
(
    'lending_limits',
    'Maximum Loan Amount',
    'Individual loans cannot exceed N$50,000 without additional approval',
    'lending',
    'active',
    '2024-01-01',
    'mandatory',
    10000.00
),
(
    'kyc_requirements',
    'Customer Due Diligence',
    'All customers must complete KYC verification before loan approval',
    'kyc',
    'active',
    '2024-01-01',
    'mandatory',
    5000.00
),
(
    'reporting_requirements',
    'Monthly Lending Report',
    'Monthly submission of lending activities to NAMFISA',
    'lending',
    'active',
    '2024-01-01',
    'mandatory',
    15000.00
) ON CONFLICT DO NOTHING;
\n-- End of buffrlend-starter/supabase/migrations/27_namfisa_compliance.sql --\n
-- SendGrid Template Management
-- This migration creates tables for managing SendGrid templates, versions, and content

-- SendGrid Template Versions
CREATE TABLE IF NOT EXISTS sendgrid_template_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    version_id TEXT NOT NULL,
    version_name TEXT,
    version_number INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT false,
    subject TEXT,
    content_html TEXT,
    content_text TEXT,
    variables JSONB DEFAULT '[]'::jsonb,
    test_data JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id),
    UNIQUE(template_id, version_number)
);

-- SendGrid Template Categories
CREATE TABLE IF NOT EXISTS sendgrid_template_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    category_name TEXT NOT NULL UNIQUE,
    category_description TEXT,
    parent_category_id UUID REFERENCES sendgrid_template_categories(id),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Template Tags
CREATE TABLE IF NOT EXISTS sendgrid_template_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tag_name TEXT NOT NULL UNIQUE,
    tag_description TEXT,
    tag_color TEXT DEFAULT '#007bff',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Template Tag Assignments
CREATE TABLE IF NOT EXISTS sendgrid_template_tag_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    tag_id UUID REFERENCES sendgrid_template_tags(id),
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    assigned_by UUID REFERENCES auth.users(id),
    UNIQUE(template_id, tag_id)
);

-- SendGrid Template Usage Tracking
CREATE TABLE IF NOT EXISTS sendgrid_template_usage (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    version_id TEXT,
    usage_date DATE NOT NULL,
    emails_sent INTEGER DEFAULT 0,
    emails_delivered INTEGER DEFAULT 0,
    emails_opened INTEGER DEFAULT 0,
    emails_clicked INTEGER DEFAULT 0,
    emails_bounced INTEGER DEFAULT 0,
    emails_unsubscribed INTEGER DEFAULT 0,
    delivery_rate NUMERIC(5,2) DEFAULT 0.00,
    open_rate NUMERIC(5,2) DEFAULT 0.00,
    click_rate NUMERIC(5,2) DEFAULT 0.00,
    bounce_rate NUMERIC(5,2) DEFAULT 0.00,
    unsubscribe_rate NUMERIC(5,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Template Testing
CREATE TABLE IF NOT EXISTS sendgrid_template_tests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    version_id TEXT,
    test_name TEXT NOT NULL,
    test_recipients JSONB NOT NULL,
    test_data JSONB DEFAULT '{}'::jsonb,
    test_status TEXT DEFAULT 'pending' CHECK (test_status IN ('pending', 'running', 'completed', 'failed', 'cancelled')),
    test_results JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- SendGrid Template Approval Workflow
CREATE TABLE IF NOT EXISTS sendgrid_template_approvals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    version_id TEXT,
    approval_status TEXT DEFAULT 'pending' CHECK (approval_status IN ('pending', 'approved', 'rejected', 'cancelled')),
    approval_notes TEXT,
    approved_by UUID REFERENCES auth.users(id),
    approved_at TIMESTAMP WITH TIME ZONE,
    rejected_by UUID REFERENCES auth.users(id),
    rejected_at TIMESTAMP WITH TIME ZONE,
    rejection_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- SendGrid Template Content Blocks
CREATE TABLE IF NOT EXISTS sendgrid_template_blocks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id TEXT NOT NULL,
    block_name TEXT NOT NULL,
    block_type TEXT NOT NULL CHECK (block_type IN ('text', 'html', 'image', 'button', 'spacer', 'divider', 'social', 'footer', 'header')),
    block_content TEXT,
    block_styles JSONB DEFAULT '{}'::jsonb,
    block_settings JSONB DEFAULT '{}'::jsonb,
    is_editable BOOLEAN DEFAULT true,
    is_required BOOLEAN DEFAULT false,
    sort_order INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    created_by UUID REFERENCES auth.users(id),
    updated_by UUID REFERENCES auth.users(id)
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_versions_template ON sendgrid_template_versions(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_versions_active ON sendgrid_template_versions(is_active);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_categories_parent ON sendgrid_template_categories(parent_category_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_tag_assignments_template ON sendgrid_template_tag_assignments(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_tag_assignments_tag ON sendgrid_template_tag_assignments(tag_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_usage_template ON sendgrid_template_usage(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_usage_date ON sendgrid_template_usage(usage_date);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_tests_template ON sendgrid_template_tests(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_tests_status ON sendgrid_template_tests(test_status);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_approvals_template ON sendgrid_template_approvals(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_approvals_status ON sendgrid_template_approvals(approval_status);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_blocks_template ON sendgrid_template_blocks(template_id);
CREATE INDEX IF NOT EXISTS idx_sendgrid_template_blocks_type ON sendgrid_template_blocks(block_type);

-- Triggers for updated_at
CREATE TRIGGER update_sendgrid_template_versions_updated_at BEFORE UPDATE ON sendgrid_template_versions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_categories_updated_at BEFORE UPDATE ON sendgrid_template_categories FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_tags_updated_at BEFORE UPDATE ON sendgrid_template_tags FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_usage_updated_at BEFORE UPDATE ON sendgrid_template_usage FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_tests_updated_at BEFORE UPDATE ON sendgrid_template_tests FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_approvals_updated_at BEFORE UPDATE ON sendgrid_template_approvals FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_sendgrid_template_blocks_updated_at BEFORE UPDATE ON sendgrid_template_blocks FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert default template categories
INSERT INTO sendgrid_template_categories (category_name, category_description) VALUES
('Transactional', 'Transactional email templates for user actions'),
('Marketing', 'Marketing email templates for campaigns'),
('Automated', 'Automated email templates for workflows'),
('Notifications', 'Notification email templates'),
('Onboarding', 'User onboarding email templates'),
('Support', 'Customer support email templates')
ON CONFLICT (category_name) DO NOTHING;

-- Insert default template tags
INSERT INTO sendgrid_template_tags (tag_name, tag_description, tag_color) VALUES
('High Priority', 'High priority templates', '#dc3545'),
('Low Priority', 'Low priority templates', '#6c757d'),
('A/B Test', 'Templates used for A/B testing', '#17a2b8'),
('Seasonal', 'Seasonal templates', '#28a745'),
('Promotional', 'Promotional templates', '#ffc107'),
('Transactional', 'Transactional templates', '#007bff')
ON CONFLICT (tag_name) DO NOTHING;
\n-- End of buffrlend-starter/supabase/migrations/23_sendgrid_template_management.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/supabase/migrations/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/supabase/migrations/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/supabase/migrations/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/supabase/migrations/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/supabase/migrations/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/supabase/migrations/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/supabase/migrations/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/supabase/migrations/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/supabase/migrations/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/supabase/migrations/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/supabase/migrations/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/supabase/migrations/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/supabase/migrations/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/supabase/migrations/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/supabase/migrations/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/supabase/migrations/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/supabase/migrations/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/supabase/migrations/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/supabase/migrations/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/supabase/migrations/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/supabase/migrations/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/supabase/migrations/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/supabase/migrations/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/supabase/migrations/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/supabase/migrations/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/supabase/migrations/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/supabase/migrations/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/supabase/migrations/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/supabase/migrations/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/supabase/migrations/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/supabase/migrations/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/supabase/migrations/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/supabase/migrations/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/supabase/migrations/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/supabase/migrations/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/supabase/migrations/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/supabase/migrations/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/supabase/migrations/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/supabase/migrations/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/supabase/migrations/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/supabase/migrations/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/supabase/migrations/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/supabase/migrations/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/supabase/migrations/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/supabase/migrations/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/supabase/migrations/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/supabase/migrations/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/supabase/migrations/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/supabase/migrations/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/supabase/migrations/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/supabase/migrations/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/supabase/migrations/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/supabase/migrations/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/supabase/migrations/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create evaluation_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_type_enum') THEN
        CREATE TYPE evaluation_type_enum AS ENUM (
            'a_b_test',
            'feature_rollout',
            'model_performance',
            'user_experience',
            'system_benchmark',
            'custom'
        );
    END IF;
END $$;

-- Create evaluation_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'evaluation_status_enum') THEN
        CREATE TYPE evaluation_status_enum AS ENUM (
            'pending',
            'running',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Unified Evaluation Runs table
CREATE TABLE IF NOT EXISTS public.evaluation_runs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    evaluation_type evaluation_type_enum NOT NULL,
    status evaluation_status_enum DEFAULT 'pending'::evaluation_status_enum,
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Configuration parameters for the evaluation
    results_summary JSONB DEFAULT '{}'::jsonb, -- High-level summary of results
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Evaluation Metrics table
CREATE TABLE IF NOT EXISTS public.evaluation_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    metric_name TEXT NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    metric_unit TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Test Results table (for detailed test outcomes)
CREATE TABLE IF NOT EXISTS public.test_results (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    evaluation_run_id UUID REFERENCES public.evaluation_runs(id) ON DELETE CASCADE,
    test_name TEXT NOT NULL,
    test_suite TEXT,
    status TEXT NOT NULL, -- e.g., 'pass', 'fail', 'skip'
    duration_ms INTEGER,
    error_details TEXT,
    log_output TEXT,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables
ALTER TABLE public.evaluation_runs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation runs" ON public.evaluation_runs FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation runs" ON public.evaluation_runs FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.evaluation_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read evaluation metrics" ON public.evaluation_metrics FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage evaluation metrics" ON public.evaluation_metrics FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.test_results ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read test results" ON public.test_results FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage test results" ON public.test_results FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/008_create_unified_evaluation_systems.sql --\n
-- Unified Monitoring and Analytics Tables
-- This file establishes a system for monitoring system health and performance.

-- Health Check Status Enum
CREATE TYPE health_check_status AS ENUM (
    'healthy',
    'unhealthy',
    'degraded'
);

-- System Metrics Table
CREATE TABLE system_metrics (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    metric_name VARCHAR(100) NOT NULL,
    metric_value FLOAT NOT NULL,
    tags JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- API Performance Logs Table
CREATE TABLE api_performance_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    endpoint TEXT NOT NULL,
    method VARCHAR(10) NOT NULL,
    status_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    user_id UUID REFERENCES users(id),
    ip_address INET,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Health Checks Table
CREATE TABLE health_checks (
    id SERIAL PRIMARY KEY,
    service_name VARCHAR(100) UNIQUE NOT NULL,
    status health_check_status NOT NULL,
    details JSONB,
    last_checked_at TIMESTAMP WITH TIME ZONE
);

-- Error Logs Table
CREATE TABLE error_logs (
    id BIGSERIAL PRIMARY KEY,
    service_name VARCHAR(100) NOT NULL,
    error_message TEXT NOT NULL,
    stack_trace TEXT,
    details JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_system_metrics_timestamp ON system_metrics(timestamp);
CREATE INDEX idx_system_metrics_service_metric ON system_metrics(service_name, metric_name);
CREATE INDEX idx_api_performance_logs_timestamp ON api_performance_logs(timestamp);
CREATE INDEX idx_api_performance_logs_endpoint ON api_performance_logs(endpoint);
CREATE INDEX idx_error_logs_timestamp ON error_logs(timestamp);
CREATE INDEX idx_error_logs_service_name ON error_logs(service_name);
\n-- End of buffrlend-starter/sql/06_unified_monitoring.sql --\n
-- Create ml_model_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_model_status_enum') THEN
        CREATE TYPE ml_model_status_enum AS ENUM (
            'draft',
            'training',
            'trained',
            'deployed',
            'archived',
            'failed'
        );
    END IF;
END $$;

-- Create ml_evaluation_metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ml_evaluation_metric_type_enum') THEN
        CREATE TYPE ml_evaluation_metric_type_enum AS ENUM (
            'accuracy',
            'precision',
            'recall',
            'f1_score',
            'roc_auc',
            'mse',
            'rmse',
            'mae',
            'r_squared',
            'log_loss',
            'perplexity',
            'bleu',
            'rouge',
            'custom'
        );
    END IF;
END $$;

-- Unified ML Models table
CREATE TABLE IF NOT EXISTS public.ml_models (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    framework TEXT, -- e.g., 'tensorflow', 'pytorch', 'scikit-learn'
    task_type TEXT, -- e.g., 'classification', 'regression', 'nlp', 'computer_vision'
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified ML Model Versions table
CREATE TABLE IF NOT EXISTS public.ml_model_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_id UUID REFERENCES public.ml_models(id) ON DELETE CASCADE,
    version_number TEXT NOT NULL,
    storage_path TEXT NOT NULL, -- Path to stored model artifact
    status ml_model_status_enum DEFAULT 'draft'::ml_model_status_enum,
    training_config JSONB DEFAULT '{}'::jsonb,
    training_metrics JSONB DEFAULT '{}'::jsonb,
    deployed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (model_id, version_number)
);

-- Unified ML Model Evaluations table
CREATE TABLE IF NOT EXISTS public.ml_model_evaluations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    model_version_id UUID REFERENCES public.ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset TEXT NOT NULL, -- Name or path of the dataset used for evaluation
    metric_type ml_evaluation_metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    evaluation_config JSONB DEFAULT '{}'::jsonb,
    evaluated_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL
);

-- Set up RLS for all new tables
ALTER TABLE public.ml_models ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML models" ON public.ml_models FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML models" ON public.ml_models FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model versions" ON public.ml_model_versions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model versions" ON public.ml_model_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.ml_model_evaluations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read ML model evaluations" ON public.ml_model_evaluations FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage ML model evaluations" ON public.ml_model_evaluations FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/006_create_unified_ml_models.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Unified Machine Learning Model Management Tables
-- This file establishes a system for managing the lifecycle of machine learning models.

-- Model Type Enum
CREATE TYPE ml_model_type AS ENUM (
    'classification',
    'regression',
    'clustering',
    'natural_language_processing',
    'computer_vision',
    'recommendation_system'
);

-- Model Status Enum
CREATE TYPE ml_model_status AS ENUM (
    'development',
    'staging',
    'production',
    'archived',
    'deprecated'
);

-- ML Models Table
CREATE TABLE ml_models (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    model_type ml_model_type NOT NULL,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Model Versions Table
CREATE TABLE ml_model_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_id UUID NOT NULL REFERENCES ml_models(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    description TEXT,
    status ml_model_status NOT NULL DEFAULT 'development',
    model_path TEXT, -- e.g., path to model file in a storage bucket
    parameters JSONB, -- Hyperparameters, etc.
    training_dataset_ref TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(model_id, version_number)
);

-- Model Deployments Table
CREATE TABLE ml_model_deployments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    environment VARCHAR(100) NOT NULL, -- e.g., development, staging, production
    deployment_url TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    deployed_by UUID REFERENCES users(id),
    deployed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Model Evaluations Table
CREATE TABLE ml_model_evaluations (
    id BIGSERIAL PRIMARY KEY,
    version_id UUID NOT NULL REFERENCES ml_model_versions(id) ON DELETE CASCADE,
    evaluation_dataset_ref TEXT,
    metrics JSONB NOT NULL, -- e.g., accuracy, precision, recall, f1-score
    notes TEXT,
    evaluated_by UUID REFERENCES users(id),
    evaluated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_ml_models_updated_at
BEFORE UPDATE ON ml_models
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_ml_model_versions_updated_at
BEFORE UPDATE ON ml_model_versions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_ml_model_versions_model_id ON ml_model_versions(model_id);
CREATE INDEX idx_ml_model_deployments_version_id ON ml_model_deployments(version_id);
CREATE INDEX idx_ml_model_evaluations_version_id ON ml_model_evaluations(version_id);
\n-- End of buffrlend-starter/sql/05_unified_ml_models.sql --\n
-- Unified KYC System Tables
-- This file establishes a comprehensive system for KYC (Know Your Customer) processes.

-- KYC Workflow State Enum
CREATE TYPE kyc_workflow_state AS ENUM (
    'initialized',
    'document_uploaded',
    'ocr_extraction_complete',
    'ai_country_detection',
    'ai_field_extraction',
    'sadc_validation',
    'compliance_checked',
    'auto_approved',
    'auto_rejected',
    'manual_review',
    'completed',
    'failed',
    'expired'
);

-- KYC Decision Enum
CREATE TYPE kyc_decision AS ENUM (
    'approved',
    'rejected',
    'pending',
    'requires_review'
);

-- SADC Countries Table (for reference)
CREATE TABLE sadc_countries (
    id SERIAL PRIMARY KEY,
    country_code VARCHAR(2) UNIQUE NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    id_format_type VARCHAR(50),
    id_regex_patterns TEXT[],
    date_format VARCHAR(20),
    keywords TEXT[],
    validation_rules JSONB,
    is_active BOOLEAN DEFAULT TRUE
);

-- KYC Workflows Table
CREATE TABLE kyc_workflows (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    workflow_state kyc_workflow_state NOT NULL DEFAULT 'initialized',
    detected_country_code VARCHAR(2) REFERENCES sadc_countries(country_code),
    final_decision kyc_decision,
    decision_confidence FLOAT,
    rejection_reasons TEXT[],
    processing_time_ms INTEGER,
    total_confidence FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- KYC Documents Table
CREATE TABLE kyc_documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    document_type VARCHAR(100) NOT NULL, -- e.g., national_id, passport, proof_of_address
    file_url TEXT NOT NULL,
    storage_provider VARCHAR(50) DEFAULT 'supabase',
    upload_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_primary BOOLEAN DEFAULT FALSE
);

-- AI Analysis Steps Table
CREATE TABLE kyc_analysis_steps (
    id BIGSERIAL PRIMARY KEY,
    workflow_id UUID NOT NULL REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    step_name VARCHAR(100) NOT NULL,
    step_order INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    ai_method VARCHAR(100),
    confidence_score FLOAT,
    processing_time_ms INTEGER,
    input_data JSONB,
    output_data JSONB,
    error_details JSONB,
    started_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Extracted ID Fields Table
CREATE TABLE extracted_id_fields (
    workflow_id UUID PRIMARY KEY REFERENCES kyc_workflows(id) ON DELETE CASCADE,
    id_number VARCHAR(100),
    full_name VARCHAR(255),
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    gender VARCHAR(20),
    nationality VARCHAR(100),
    issue_date DATE,
    expiry_date DATE,
    place_of_birth VARCHAR(255),
    address TEXT,
    confidence_score FLOAT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_kyc_workflows_updated_at
BEFORE UPDATE ON kyc_workflows
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_kyc_workflows_user_id ON kyc_workflows(user_id);
CREATE INDEX idx_kyc_workflows_state ON kyc_workflows(workflow_state);
CREATE INDEX idx_kyc_documents_workflow_id ON kyc_documents(workflow_id);
CREATE INDEX idx_kyc_analysis_steps_workflow_id ON kyc_analysis_steps(workflow_id);
\n-- End of buffrlend-starter/sql/02_unified_kyc_system.sql --\n
-- Unified Rate Limiting Tables
-- This file establishes a system for API rate limiting to prevent abuse.

-- Rate Limiting Rule Type Enum
CREATE TYPE rate_limit_rule_type AS ENUM (
    'api',
    'login_attempt',
    'kyc_attempt',
    'document_upload',
    'signature_request'
);

-- Rate Limiting Rules Table
CREATE TABLE rate_limiting_rules (
    id SERIAL PRIMARY KEY,
    rule_name VARCHAR(100) UNIQUE NOT NULL,
    rule_type rate_limit_rule_type NOT NULL,
    resource TEXT NOT NULL, -- e.g., /api/v1/login, specific user action
    limit_count INTEGER NOT NULL,
    time_window_minutes INTEGER NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Rate Limiting Counters Table
CREATE TABLE rate_limiting_counters (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- e.g., user_id, ip_address, api_key
    count INTEGER NOT NULL DEFAULT 1,
    window_start TIMESTAMP WITH TIME ZONE NOT NULL,
    window_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(rule_id, identifier, window_start)
);

-- Rate Limiting Violations Table
CREATE TABLE rate_limiting_violations (
    id BIGSERIAL PRIMARY KEY,
    rule_id INTEGER NOT NULL REFERENCES rate_limiting_rules(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    details JSONB
);

-- Rate Limiting Exemptions Table
CREATE TABLE rate_limiting_exemptions (
    id SERIAL PRIMARY KEY,
    identifier TEXT UNIQUE NOT NULL, -- e.g., specific user_id or ip_address
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_rate_limiting_rules_updated_at
BEFORE UPDATE ON rate_limiting_rules
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_counters_updated_at
BEFORE UPDATE ON rate_limiting_counters
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_rate_limiting_exemptions_updated_at
BEFORE UPDATE ON rate_limiting_exemptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_rate_limiting_counters_identifier ON rate_limiting_counters(identifier);
CREATE INDEX idx_rate_limiting_violations_identifier ON rate_limiting_violations(identifier);
\n-- End of buffrlend-starter/sql/04_unified_rate_limiting.sql --\n
-- Unified Helper Functions and Triggers
-- This file contains utility functions and triggers for the unified schema.

-- Function to validate email format
CREATE OR REPLACE FUNCTION is_valid_email(email TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN email ~ '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$';
END;
$$ LANGUAGE plpgsql;

-- Function to validate phone number format (simple international format)
CREATE OR REPLACE FUNCTION is_valid_phone(phone TEXT)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN phone ~ '^\+[1-9]\d{1,14}$';
END;
$$ LANGUAGE plpgsql;

-- Function to generate a BFR-SIGN-ID
CREATE OR REPLACE FUNCTION generate_bfr_sign_id(user_id UUID, country_code TEXT, national_id TEXT)
RETURNS TEXT AS $$
DECLARE
    national_id_uuid UUID;
    timestamp_str TEXT;
BEGIN
    -- Create a deterministic UUID from the national ID
    national_id_uuid := uuid_generate_v5(uuid_ns_dns(), country_code || national_id);
    timestamp_str := to_char(NOW(), 'YYYYMMDDHH24MISS');
    RETURN 'BFS-' || country_code || '-' || national_id_uuid::text || '-' || timestamp_str;
END;
$$ LANGUAGE plpgsql;

-- Trigger to create a user profile automatically
CREATE OR REPLACE FUNCTION create_user_profile()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO profiles (id, full_name) VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name');
    INSERT INTO user_preferences (user_id) VALUES (NEW.id);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_user_profile
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_user_profile();

-- Trigger to handle new user registration from Supabase Auth
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.users (id, email, role, status)
    VALUES (NEW.id, NEW.email, 'individual', 'pending_verification');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION handle_new_user();

-- Add validation constraints to tables
ALTER TABLE users ADD CONSTRAINT email_validation CHECK (is_valid_email(email));
ALTER TABLE users ADD CONSTRAINT phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
ALTER TABLE organizations ADD CONSTRAINT org_email_validation CHECK (email IS NULL OR is_valid_email(email));
ALTER TABLE organizations ADD CONSTRAINT org_phone_validation CHECK (phone IS NULL OR is_valid_phone(phone));
\n-- End of buffrlend-starter/sql/12_unified_functions_and_triggers.sql --\n
-- Create compliance_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'compliance_status_enum') THEN
        CREATE TYPE compliance_status_enum AS ENUM (
            'pending',
            'compliant',
            'non_compliant',
            'needs_review',
            'exempt'
        );
    END IF;
END $$;

-- Create regulatory_body enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'regulatory_body_enum') THEN
        CREATE TYPE regulatory_body_enum AS ENUM (
            'namfisa',
            'cran',
            'sadc',
            'gdpr',
            'other'
        );
    END IF;
END $$;

-- Unified Compliance Checks table
CREATE TABLE IF NOT EXISTS public.compliance_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    check_name TEXT NOT NULL,
    description TEXT,
    regulatory_body regulatory_body_enum NOT NULL,
    regulation_reference TEXT, -- e.g., 'ETA 2019', 'GDPR Article 5'
    target_entity TEXT, -- e.g., 'document', 'user', 'system'
    target_id TEXT, -- ID of the entity being checked
    status compliance_status_enum DEFAULT 'pending'::compliance_status_enum,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_due_at TIMESTAMPTZ,
    checked_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    details JSONB DEFAULT '{}'::jsonb, -- Specific details about the check and findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Regulatory Reports table
CREATE TABLE IF NOT EXISTS public.regulatory_reports (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    report_name TEXT NOT NULL,
    regulatory_body regulatory_body_enum NOT NULL,
    reporting_period_start DATE NOT NULL,
    reporting_period_end DATE NOT NULL,
    status TEXT DEFAULT 'draft', -- e.g., 'draft', 'generated', 'submitted', 'approved'
    generated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    generated_at TIMESTAMPTZ DEFAULT NOW(),
    submission_date TIMESTAMPTZ,
    report_content_url TEXT, -- URL to the generated report document
    summary JSONB DEFAULT '{}'::jsonb, -- Summary of the report findings
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.compliance_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read compliance checks" ON public.compliance_checks FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage compliance checks" ON public.compliance_checks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.regulatory_reports ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read regulatory reports" ON public.regulatory_reports FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage regulatory reports" ON public.regulatory_reports FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/010_create_unified_compliance_framework.sql --\n
-- Create payment_gateway_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'payment_gateway_enum') THEN
        CREATE TYPE payment_gateway_enum AS ENUM (
            'realpay',
            'adumo',
            'stripe',
            'paypal',
            'other'
        );
    END IF;
END $$;

-- Create transaction_status_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_status_enum') THEN
        CREATE TYPE transaction_status_enum AS ENUM (
            'pending',
            'successful',
            'failed',
            'refunded',
            'partially_refunded',
            'cancelled',
            'disputed'
        );
    END IF;
END $$;

-- Create transaction_type_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'transaction_type_enum') THEN
        CREATE TYPE transaction_type_enum AS ENUM (
            'payment',
            'refund',
            'chargeback',
            'payout',
            'settlement'
        );
    END IF;
END $$;

-- Unified Payment Gateway Configuration
CREATE TABLE IF NOT EXISTS public.payment_gateway_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_name payment_gateway_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL,
    secret_key_encrypted TEXT,
    webhook_secret_encrypted TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Gateway-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Transactions
CREATE TABLE IF NOT EXISTS public.payment_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    gateway_transaction_id TEXT, -- ID from the payment gateway
    transaction_type transaction_type_enum NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    status transaction_status_enum NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Gateway-specific details, QR codes, NFC data, credit/risk info
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Webhooks
CREATE TABLE IF NOT EXISTS public.payment_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    event_type TEXT NOT NULL, -- e.g., 'payment_succeeded', 'payment_failed', 'refund_created'
    payload JSONB NOT NULL, -- Raw webhook payload
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Refunds
CREATE TABLE IF NOT EXISTS public.payment_refunds (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES public.payment_transactions(id) ON DELETE CASCADE,
    gateway_refund_id TEXT,
    amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    reason TEXT,
    status transaction_status_enum NOT NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Payment Settlements
CREATE TABLE IF NOT EXISTS public.payment_settlements (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    gateway_id UUID REFERENCES public.payment_gateway_config(id) ON DELETE SET NULL,
    settlement_date DATE NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    currency TEXT NOT NULL,
    fees DECIMAL(10,2) DEFAULT 0.00,
    net_amount DECIMAL(10,2) NOT NULL,
    transaction_count INTEGER DEFAULT 0,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.payment_gateway_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment gateway config" ON public.payment_gateway_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment transactions" ON public.payment_transactions FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow admins to view all payment transactions" ON public.payment_transactions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage payment webhooks" ON public.payment_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_refunds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to view their own payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.payment_transactions pt WHERE pt.id = transaction_id AND pt.user_id = auth.uid()));
CREATE POLICY "Allow admins to view all payment refunds" ON public.payment_refunds FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.payment_settlements ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view payment settlements" ON public.payment_settlements FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/005_create_unified_payment_gateways.sql --\n
-- Unified Notification System Tables
-- This file establishes a comprehensive system for handling notifications (email, SMS, push).

-- Notification Type Enum
CREATE TYPE notification_type AS ENUM (
    'email',
    'sms',
    'push',
    'in_app'
);

-- Notification Status Enum
CREATE TYPE notification_status AS ENUM (
    'queued',
    'sent',
    'delivered',
    'failed',
    'opened',
    'clicked'
);

-- Notification Templates Table
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    type notification_type NOT NULL,
    subject TEXT,
    body TEXT NOT NULL,
    variables JSONB, -- For template variables
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Notification Queue Table
CREATE TABLE notification_queue (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    template_id UUID NOT NULL REFERENCES notification_templates(id),
    type notification_type NOT NULL,
    status notification_status NOT NULL DEFAULT 'queued',
    recipient TEXT NOT NULL, -- Email address, phone number, or device token
    payload JSONB, -- For template variable values
    send_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sent_at TIMESTAMP WITH TIME ZONE,
    error_message TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Notification Preferences (already created in 00_unified_core_tables.sql, but shown here for context)
-- CREATE TABLE user_preferences (
--     user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
--     email_notifications BOOLEAN DEFAULT TRUE,
--     sms_notifications BOOLEAN DEFAULT FALSE,
--     push_notifications BOOLEAN DEFAULT TRUE,
--     updated_at TIMESTAMP WITH TIME ZONE
-- );

-- Notification Analytics Table
CREATE TABLE notification_analytics (
    notification_id BIGINT PRIMARY KEY REFERENCES notification_queue(id) ON DELETE CASCADE,
    opened_at TIMESTAMP WITH TIME ZONE,
    clicked_at TIMESTAMP WITH TIME ZONE,
    ip_address INET,
    user_agent TEXT
);

-- Add Triggers for updated_at
CREATE TRIGGER update_notification_templates_updated_at
BEFORE UPDATE ON notification_templates
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_notification_queue_updated_at
BEFORE UPDATE ON notification_queue
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_notification_queue_status ON notification_queue(status);
CREATE INDEX idx_notification_queue_send_at ON notification_queue(send_at);
CREATE INDEX idx_notification_queue_user_id ON notification_queue(user_id);
\n-- End of buffrlend-starter/sql/03_unified_notifications.sql --\n
-- Enable pgvector extension if not already enabled
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector_search_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'vector_search_type_enum') THEN
        CREATE TYPE vector_search_type_enum AS ENUM (
            'document_content',
            'image_features',
            'audio_features',
            'user_query',
            'product_description',
            'other'
        );
    END IF;
END $$;

-- Unified Vector Embeddings table
CREATE TABLE IF NOT EXISTS public.vector_embeddings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL, -- e.g., 'documents', 'products', 'users'
    source_id TEXT NOT NULL, -- ID of the record in the source table
    embedding VECTOR(1536) NOT NULL, -- Assuming OpenAI's text-embedding-ada-002 dimension
    search_type vector_search_type_enum DEFAULT 'document_content'::vector_search_type_enum,
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional context or filters for search
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for efficient vector search (using HNSW or IVFFlat)
-- Note: Index creation can be time-consuming for large tables.
-- Consider creating it after initial data load or in a separate migration.
-- Example for HNSW:
-- CREATE INDEX ON public.vector_embeddings USING hnsw (embedding vector_l2_ops);
-- Example for IVFFlat:
-- CREATE INDEX ON public.vector_embeddings USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- Unified Full-Text Search Index (for traditional keyword search)
-- This table will store pre-processed text for full-text search
CREATE TABLE IF NOT EXISTS public.full_text_search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_table TEXT NOT NULL,
    source_id TEXT NOT NULL,
    document_tsv TSVECTOR NOT NULL, -- Text Search Vector
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create a GIN index for full-text search
CREATE INDEX IF NOT EXISTS idx_full_text_search_document_tsv ON public.full_text_search_index USING GIN (document_tsv);

-- Function to update the full_text_search_index table
CREATE OR REPLACE FUNCTION public.update_full_text_search_index()
RETURNS TRIGGER AS $$
BEGIN
    -- Example: Assuming 'documents' table has a 'content' column
    -- This function needs to be adapted for each source table and its relevant text columns
    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
        INSERT INTO public.full_text_search_index (source_table, source_id, document_tsv)
        VALUES (
            TG_TABLE_NAME,
            NEW.id,
            to_tsvector('english', NEW.content) -- Replace 'content' with the actual text column
        )
        ON CONFLICT (source_id) DO UPDATE SET
            document_tsv = to_tsvector('english', NEW.content),
            updated_at = NOW();
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        DELETE FROM public.full_text_search_index WHERE source_table = TG_TABLE_NAME AND source_id = OLD.id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Example trigger for the 'documents' table (this would be created in the documents migration or separately)
-- CREATE TRIGGER documents_full_text_search_trigger
-- AFTER INSERT OR UPDATE OR DELETE ON public.documents
-- FOR EACH ROW EXECUTE FUNCTION public.update_full_text_search_index();


-- Set up RLS for all new tables
ALTER TABLE public.vector_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read vector embeddings" ON public.vector_embeddings FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage vector embeddings" ON public.vector_embeddings FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.full_text_search_index ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read full text search index" ON public.full_text_search_index FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage full text search index" ON public.full_text_search_index FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/012_create_unified_vector_search.sql --\n
-- Create document_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_status_enum') THEN
        CREATE TYPE document_status_enum AS ENUM (
            'uploaded',
            'processing',
            'processed',
            'failed',
            'archived',
            'deleted'
        );
    END IF;
END $$;

-- Create document_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'document_type_enum') THEN
        CREATE TYPE document_type_enum AS ENUM (
            'kyc',
            'loan_agreement',
            'contract',
            'invoice',
            'report',
            'other'
        );
    END IF;
END $$;

-- Unified Documents table
CREATE TABLE IF NOT EXISTS public.documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    file_path TEXT NOT NULL, -- Path in cloud storage (e.g., S3 URL, Google Drive ID)
    file_size_bytes BIGINT,
    mime_type TEXT,
    document_type document_type_enum DEFAULT 'other'::document_type_enum,
    status document_status_enum DEFAULT 'uploaded'::document_status_enum,
    upload_source TEXT, -- e.g., 'web_app', 'google_drive', 'api'
    metadata JSONB DEFAULT '{}'::jsonb, -- Additional metadata (e.g., Google Drive specific fields)
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Document Versions table (for tracking changes to documents)
CREATE TABLE IF NOT EXISTS public.document_versions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    metadata JSONB DEFAULT '{}'::jsonb,
    UNIQUE (document_id, version_number)
);

-- Unified Document Access Control List (ACL)
CREATE TABLE IF NOT EXISTS public.document_acl (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    permission_level TEXT NOT NULL, -- e.g., 'read', 'write', 'owner'
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (document_id, user_id)
);

-- Set up RLS for all new tables
ALTER TABLE public.documents ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage their documents" ON public.documents FOR ALL USING (auth.uid() = owner_id);
CREATE POLICY "Allow users with ACL access to read documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all documents" ON public.documents FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_versions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document versions" ON public.document_versions FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow users with ACL access to read document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.document_acl WHERE document_id = document_id AND user_id = auth.uid() AND permission_level IN ('read', 'write', 'owner')));
CREATE POLICY "Allow admins to view all document versions" ON public.document_versions FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.document_acl ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow owners to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.documents WHERE id = document_id AND owner_id = auth.uid()));
CREATE POLICY "Allow admins to manage document ACL" ON public.document_acl FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/011_create_unified_file_management.sql --\n
-- Unified Evaluation System Tables
-- This file establishes a generic framework for running and tracking evaluations.

-- Evaluation Type Enum
CREATE TYPE evaluation_type AS ENUM (
    'a_b_test',
    'feature_flag',
    'model_performance',
    'user_experience'
);

-- Evaluation Status Enum
CREATE TYPE evaluation_status AS ENUM (
    'draft',
    'running',
    'paused',
    'completed',
    'archived'
);

-- Evaluation Runs Table
CREATE TABLE evaluation_runs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    evaluation_type evaluation_type NOT NULL,
    status evaluation_status NOT NULL DEFAULT 'draft',
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Evaluation Variants Table
CREATE TABLE evaluation_variants (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    name VARCHAR(100) NOT NULL, -- e.g., 'control', 'variant_a'
    description TEXT,
    traffic_percentage FLOAT NOT NULL,
    is_control BOOLEAN DEFAULT FALSE,
    UNIQUE(run_id, name)
);

-- Evaluation Metrics Table
CREATE TABLE evaluation_metrics (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,
    metric_type VARCHAR(50), -- e.g., 'conversion_rate', 'avg_session_duration'
    goal_direction VARCHAR(10), -- e.g., 'increase', 'decrease'
    UNIQUE(run_id, metric_name)
);

-- Evaluation Results Table
CREATE TABLE evaluation_results (
    id BIGSERIAL PRIMARY KEY,
    run_id UUID NOT NULL REFERENCES evaluation_runs(id) ON DELETE CASCADE,
    variant_id UUID NOT NULL REFERENCES evaluation_variants(id) ON DELETE CASCADE,
    metric_id BIGINT NOT NULL REFERENCES evaluation_metrics(id) ON DELETE CASCADE,
    value FLOAT NOT NULL,
    sample_size INTEGER NOT NULL,
    confidence_interval JSONB,
    is_significant BOOLEAN,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(run_id, variant_id, metric_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_evaluation_runs_updated_at
BEFORE UPDATE ON evaluation_runs
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_evaluation_runs_type_status ON evaluation_runs(evaluation_type, status);
CREATE INDEX idx_evaluation_variants_run_id ON evaluation_variants(run_id);
CREATE INDEX idx_evaluation_metrics_run_id ON evaluation_metrics(run_id);
CREATE INDEX idx_evaluation_results_run_variant_metric ON evaluation_results(run_id, variant_id, metric_id);
\n-- End of buffrlend-starter/sql/07_unified_evaluations.sql --\n
-- Create metric_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'metric_type_enum') THEN
        CREATE TYPE metric_type_enum AS ENUM (
            'cpu_usage',
            'memory_usage',
            'disk_usage',
            'network_io',
            'api_response_time',
            'error_rate',
            'latency',
            'throughput',
            'database_connections',
            'queue_depth',
            'custom'
        );
    END IF;
END $$;

-- Create health_check_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'health_check_status_enum') THEN
        CREATE TYPE health_check_status_enum AS ENUM (
            'healthy',
            'unhealthy',
            'degraded',
            'unknown'
        );
    END IF;
END $$;

-- Unified System Metrics table
CREATE TABLE IF NOT EXISTS public.system_metrics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    host_id TEXT, -- Identifier for the host/instance
    metric_type metric_type_enum NOT NULL,
    metric_value DECIMAL(10,4) NOT NULL,
    unit TEXT, -- e.g., '%', 'MB', 'ms', 'req/s'
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Performance Logs table
CREATE TABLE IF NOT EXISTS public.performance_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    endpoint TEXT, -- e.g., '/api/v1/users'
    method TEXT, -- e.g., 'GET', 'POST'
    response_time_ms INTEGER,
    status_code INTEGER,
    error_message TEXT,
    user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Unified Health Checks table
CREATE TABLE IF NOT EXISTS public.health_checks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    service_name TEXT NOT NULL,
    check_name TEXT NOT NULL, -- e.g., 'database_connection', 'redis_status', 'api_liveness'
    status health_check_status_enum NOT NULL,
    message TEXT,
    last_checked_at TIMESTAMPTZ DEFAULT NOW(),
    next_check_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (only admins can view)
ALTER TABLE public.system_metrics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view system metrics" ON public.system_metrics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.performance_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view performance logs" ON public.performance_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.health_checks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view health checks" ON public.health_checks FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/007_create_unified_monitoring_analytics.sql --\n
-- Unified Compliance Framework Tables
-- This file establishes a system for managing compliance with various regulations.

-- Compliance Check Status Enum
CREATE TYPE compliance_check_status AS ENUM (
    'compliant',
    'non_compliant',
    'in_review',
    'not_applicable'
);

-- Compliance Checks Table
CREATE TABLE compliance_checks (
    id BIGSERIAL PRIMARY KEY,
    regulation VARCHAR(100) NOT NULL, -- e.g., 'GDPR', 'PCI_DSS', 'NAMFISA'
    control_id VARCHAR(100) NOT NULL,
    description TEXT,
    status compliance_check_status NOT NULL,
    last_checked_at TIMESTAMP WITH TIME ZONE,
    checked_by UUID REFERENCES users(id),
    details JSONB, -- For evidence, notes, etc.
    UNIQUE(regulation, control_id)
);

-- Regulatory Reports Table
CREATE TABLE regulatory_reports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    regulation VARCHAR(100) NOT NULL,
    report_type VARCHAR(100) NOT NULL,
    generated_by UUID REFERENCES users(id),
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    report_data JSONB,
    file_url TEXT
);

-- Data Processing Records (for GDPR, etc.)
CREATE TABLE data_processing_records (
    id BIGSERIAL PRIMARY KEY,
    activity_description TEXT NOT NULL,
    data_categories TEXT[] NOT NULL,
    data_subjects TEXT[] NOT NULL,
    legal_basis VARCHAR(100) NOT NULL,
    retention_period INTERVAL,
    security_measures TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Add Triggers for updated_at
CREATE TRIGGER update_data_processing_records_updated_at
BEFORE UPDATE ON data_processing_records
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_compliance_checks_regulation ON compliance_checks(regulation);
CREATE INDEX idx_regulatory_reports_regulation ON regulatory_reports(regulation);
\n-- End of buffrlend-starter/sql/10_unified_compliance.sql --\n
-- Unified Row-Level Security (RLS) Policies
-- This file defines a comprehensive set of RLS policies for the unified schema.

-- Enable RLS on all relevant tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE organization_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE kyc_workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Helper function to get current user's ID
CREATE OR REPLACE FUNCTION auth.current_user_id()
RETURNS UUID AS $$
BEGIN
    RETURN (SELECT auth.uid());
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Helper function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_org_member(org_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM organization_members
        WHERE organization_id = org_id AND organization_members.user_id = user_id
    );
END;
$$ LANGUAGE plpgsql;

-- RLS Policies for 'users' table
CREATE POLICY "Users can view their own data" ON users
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own data" ON users
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'profiles' table
CREATE POLICY "Users can view their own profile" ON profiles
    FOR SELECT USING (id = auth.current_user_id());
CREATE POLICY "Users can update their own profile" ON profiles
    FOR UPDATE USING (id = auth.current_user_id());

-- RLS Policies for 'user_preferences' table
CREATE POLICY "Users can manage their own preferences" ON user_preferences
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'organizations' table
CREATE POLICY "Organization members can view their organization" ON organizations
    FOR SELECT USING (is_org_member(id, auth.current_user_id()));
CREATE POLICY "Organization owners can update their organization" ON organizations
    FOR UPDATE USING (owner_id = auth.current_user_id());

-- RLS Policies for 'organization_members' table
CREATE POLICY "Organization members can view other members" ON organization_members
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));
CREATE POLICY "Organization owners can manage members" ON organization_members
    FOR ALL USING (
        (SELECT owner_id FROM organizations WHERE id = organization_id) = auth.current_user_id()
    );

-- RLS Policies for 'subscriptions' table
CREATE POLICY "Users can view their own subscriptions" ON subscriptions
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's subscription" ON subscriptions
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'audit_logs' table
CREATE POLICY "Users can view their own audit logs" ON audit_logs
    FOR SELECT USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's audit logs" ON audit_logs
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- RLS Policies for 'kyc_workflows' table
CREATE POLICY "Users can manage their own KYC workflows" ON kyc_workflows
    FOR ALL USING (user_id = auth.current_user_id());

-- RLS Policies for 'documents' table
CREATE POLICY "Users can manage their own documents" ON documents
    FOR ALL USING (user_id = auth.current_user_id());
CREATE POLICY "Organization members can view their organization's documents" ON documents
    FOR SELECT USING (is_org_member(organization_id, auth.current_user_id()));

-- Grant usage on helper functions
GRANT EXECUTE ON FUNCTION auth.current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_org_member(UUID, UUID) TO authenticated;
\n-- End of buffrlend-starter/sql/11_unified_rls_policies.sql --\n
-- Create workflow_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_status_enum') THEN
        CREATE TYPE workflow_status_enum AS ENUM (
            'draft',
            'active',
            'paused',
            'completed',
            'cancelled',
            'failed'
        );
    END IF;
END $$;

-- Create workflow_step_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_type_enum') THEN
        CREATE TYPE workflow_step_type_enum AS ENUM (
            'manual_action',
            'api_call',
            'email_send',
            'sms_send',
            'document_sign',
            'data_entry',
            'approval',
            'conditional',
            'parallel',
            'sequential',
            'ai_task',
            'integration_task',
            'custom'
        );
    END IF;
END $$;

-- Create workflow_step_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'workflow_step_status_enum') THEN
        CREATE TYPE workflow_step_status_enum AS ENUM (
            'pending',
            'in_progress',
            'completed',
            'skipped',
            'failed',
            'paused'
        );
    END IF;
END $$;

-- Unified Workflow Templates table
CREATE TABLE IF NOT EXISTS public.workflow_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    template_definition JSONB NOT NULL, -- JSON schema for the workflow structure
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflows table (instances of templates or custom workflows)
CREATE TABLE IF NOT EXISTS public.workflows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.workflow_templates(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    description TEXT,
    status workflow_status_enum DEFAULT 'draft'::workflow_status_enum,
    current_step_id UUID, -- Reference to the currently active workflow_step_executions
    context JSONB DEFAULT '{}'::jsonb, -- Dynamic data relevant to the workflow instance
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Steps table (defines the steps within a workflow template)
CREATE TABLE IF NOT EXISTS public.workflow_steps (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_template_id UUID REFERENCES public.workflow_templates(id) ON DELETE CASCADE,
    step_order INTEGER NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    step_type workflow_step_type_enum NOT NULL,
    configuration JSONB DEFAULT '{}'::jsonb, -- Step-specific configuration (e.g., API endpoint, email template ID)
    next_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- For sequential workflows
    failure_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE SET NULL, -- Step to go to on failure
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (workflow_template_id, step_order)
);

-- Unified Workflow Instances table (for tracking individual runs of a workflow)
CREATE TABLE IF NOT EXISTS public.workflow_instances (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID REFERENCES public.workflows(id) ON DELETE CASCADE,
    initiated_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    status workflow_status_enum DEFAULT 'active'::workflow_status_enum,
    current_step_execution_id UUID, -- Reference to the currently active workflow_step_executions
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_message TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Workflow Step Executions table (for tracking individual step runs within an instance)
CREATE TABLE IF NOT EXISTS public.workflow_step_executions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_instance_id UUID REFERENCES public.workflow_instances(id) ON DELETE CASCADE,
    workflow_step_id UUID REFERENCES public.workflow_steps(id) ON DELETE CASCADE,
    status workflow_step_status_enum DEFAULT 'pending'::workflow_step_status_enum,
    assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- For manual actions/approvals
    start_time TIMESTAMPTZ DEFAULT NOW(),
    end_time TIMESTAMPTZ,
    input_data JSONB DEFAULT '{}'::jsonb,
    output_data JSONB DEFAULT '{}'::jsonb,
    error_details TEXT,
    retry_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for all new tables
ALTER TABLE public.workflow_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow templates" ON public.workflow_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow templates" ON public.workflow_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflows ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflows" ON public.workflows FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage all workflows" ON public.workflows FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_steps ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read workflow steps" ON public.workflow_steps FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage workflow steps" ON public.workflow_steps FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_instances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow instances" ON public.workflow_instances FOR SELECT USING (auth.uid() = initiated_by);
CREATE POLICY "Allow admins to manage all workflow instances" ON public.workflow_instances FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.workflow_step_executions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own workflow step executions" ON public.workflow_step_executions FOR SELECT USING (auth.uid() = assigned_to OR EXISTS (SELECT 1 FROM public.workflow_instances wi WHERE wi.id = workflow_instance_id AND wi.initiated_by = auth.uid()));
CREATE POLICY "Allow admins to manage all workflow step executions" ON public.workflow_step_executions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/009_create_unified_workflow_management.sql --\n
-- Unified Audit Log Tables
-- This file establishes a comprehensive, tamper-evident audit trail system.

-- Audit Event Type Enum
CREATE TYPE audit_event_type AS ENUM (
    'user_registration',
    'user_login',
    'user_logout',
    'password_change',
    'profile_update',
    'kyc_verification',
    'document_upload',
    'document_view',
    'document_delete',
    'signature_created',
    'signature_verified',
    'workflow_created',
    'workflow_completed',
    'workflow_canceled',
    'security_event',
    'compliance_check',
    'api_key_created',
    'api_key_deleted',
    'system_config_change',
    'data_export',
    'report_generated'
);

-- Audit Event Severity Enum
CREATE TYPE audit_severity AS ENUM (
    'info',
    'warning',
    'error',
    'critical',
    'security'
);

-- BFR-SIGN-ID Table (for unique, jurisdiction-linked user identification)
CREATE TABLE bfr_sign_ids (
    id TEXT PRIMARY KEY, -- Format: BFS-{COUNTRY_CODE}-{UUID}-{TIMESTAMP}
    user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    country_code VARCHAR(2) NOT NULL,
    national_id_hash TEXT NOT NULL,
    kyc_status VARCHAR(50) NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    verified_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Audit Log Table
CREATE TABLE audit_logs (
    id BIGSERIAL PRIMARY KEY,
    bfr_sign_id TEXT REFERENCES bfr_sign_ids(id),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    event_type audit_event_type NOT NULL,
    severity audit_severity NOT NULL DEFAULT 'info',
    event_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET,
    user_agent TEXT,
    device_fingerprint TEXT,
    correlation_id TEXT,
    event_description TEXT,
    details JSONB, -- For storing event-specific data
    previous_hash TEXT, -- For chaining audit entries
    current_hash TEXT NOT NULL
);

-- Indexes for performance
CREATE INDEX idx_audit_logs_bfr_sign_id ON audit_logs(bfr_sign_id);
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_event_type ON audit_logs(event_type);
CREATE INDEX idx_audit_logs_event_time ON audit_logs(event_time);

-- Function to create a chained hash for an audit log entry
CREATE OR REPLACE FUNCTION create_audit_log_hash() RETURNS TRIGGER AS $$
DECLARE
    last_hash TEXT;
BEGIN
    -- Get the hash of the most recent audit log entry
    SELECT current_hash INTO last_hash FROM audit_logs ORDER BY event_time DESC, id DESC LIMIT 1;

    -- Set the previous_hash for the new entry
    NEW.previous_hash := last_hash;

    -- Create the current_hash for the new entry
    NEW.current_hash := encode(digest(
        CONCAT(
            NEW.id::text,
            NEW.bfr_sign_id,
            NEW.user_id::text,
            NEW.event_type::text,
            NEW.event_time::text,
            COALESCE(NEW.details::text, ''),
            COALESCE(last_hash, '')
        ),
        'sha256'
    ), 'hex');

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically hash audit log entries
CREATE TRIGGER trigger_create_audit_log_hash
BEFORE INSERT ON audit_logs
FOR EACH ROW EXECUTE FUNCTION create_audit_log_hash();
\n-- End of buffrlend-starter/sql/01_unified_audit_logs.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create notification_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type_enum') THEN
        CREATE TYPE notification_type_enum AS ENUM (
            'email',
            'sms',
            'in_app',
            'push',
            'webhook'
        );
    END IF;
END $$;

-- Create notification_status enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_status_enum') THEN
        CREATE TYPE notification_status_enum AS ENUM (
            'pending',
            'sent',
            'delivered',
            'failed',
            'read',
            'clicked',
            'cancelled'
        );
    END IF;
END $$;

-- Create email_provider_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'email_provider_enum') THEN
        CREATE TYPE email_provider_enum AS ENUM (
            'sendgrid',
            'ses',
            'mailgun',
            'other'
        );
    END IF;
END $$;

-- Unified Notification Templates
CREATE TABLE IF NOT EXISTS public.notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL,
    type notification_type_enum NOT NULL,
    subject TEXT, -- For email/sms
    body TEXT NOT NULL, -- Template content (HTML for email, plain text for SMS/in-app)
    variables JSONB DEFAULT '{}'::jsonb, -- Expected variables for the template
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Queue
CREATE TABLE IF NOT EXISTS public.notification_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    recipient_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    recipient_address TEXT NOT NULL, -- Email, phone number, or user ID for in-app
    type notification_type_enum NOT NULL,
    status notification_status_enum DEFAULT 'pending'::notification_status_enum,
    scheduled_at TIMESTAMPTZ DEFAULT NOW(),
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    error_message TEXT,
    metadata JSONB DEFAULT '{}'::jsonb, -- Dynamic data for template rendering
    priority INTEGER DEFAULT 0, -- Higher number means higher priority
    retries INTEGER DEFAULT 0,
    last_retry_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Notification Preferences
CREATE TABLE IF NOT EXISTS public.notification_preferences (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    email_enabled BOOLEAN DEFAULT TRUE,
    sms_enabled BOOLEAN DEFAULT FALSE,
    in_app_enabled BOOLEAN DEFAULT TRUE,
    push_enabled BOOLEAN DEFAULT FALSE,
    preferences JSONB DEFAULT '{}'::jsonb, -- Granular preferences for specific notification types
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Delivery Logs
CREATE TABLE IF NOT EXISTS public.email_delivery_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    notification_id UUID REFERENCES public.notification_queue(id) ON DELETE SET NULL,
    recipient_email TEXT NOT NULL,
    provider email_provider_enum,
    provider_message_id TEXT,
    event_type TEXT, -- e.g., 'processed', 'deferred', 'delivered', 'bounce', 'open', 'click'
    event_data JSONB DEFAULT '{}'::jsonb, -- Raw webhook data from provider
    timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Campaigns
CREATE TABLE IF NOT EXISTS public.email_campaigns (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'draft', -- 'draft', 'scheduled', 'sending', 'sent', 'cancelled'
    scheduled_for TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    created_by UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Provider Configuration (e.g., SendGrid API keys)
CREATE TABLE IF NOT EXISTS public.email_provider_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider_name email_provider_enum UNIQUE NOT NULL,
    api_key_encrypted TEXT NOT NULL, -- Encrypted API key
    sender_email TEXT NOT NULL,
    sender_name TEXT,
    settings JSONB DEFAULT '{}'::jsonb, -- Provider-specific settings
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Webhook Management for Email Providers
CREATE TABLE IF NOT EXISTS public.email_webhooks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    webhook_url TEXT NOT NULL,
    secret_key_encrypted TEXT, -- For webhook signature verification
    events TEXT[] DEFAULT '{}'::TEXT[], -- Events to listen for (e.g., 'delivered', 'opened', 'clicked')
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Analytics
CREATE TABLE IF NOT EXISTS public.email_analytics (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    campaign_id UUID REFERENCES public.email_campaigns(id) ON DELETE SET NULL,
    template_id UUID REFERENCES public.notification_templates(id) ON DELETE SET NULL,
    total_sent INTEGER DEFAULT 0,
    total_delivered INTEGER DEFAULT 0,
    total_opened INTEGER DEFAULT 0,
    total_clicked INTEGER DEFAULT 0,
    total_bounced INTEGER DEFAULT 0,
    total_failed INTEGER DEFAULT 0,
    unique_opens INTEGER DEFAULT 0,
    unique_clicks INTEGER DEFAULT 0,
    report_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Suppression List
CREATE TABLE IF NOT EXISTS public.email_suppression_list (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    reason TEXT, -- e.g., 'bounced', 'complaint', 'unsubscribed'
    suppressed_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ, -- For temporary suppressions
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Unified Email Reputation Monitoring
CREATE TABLE IF NOT EXISTS public.email_reputation_monitoring (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    provider email_provider_enum NOT NULL,
    metric_name TEXT NOT NULL, -- e.g., 'bounce_rate', 'spam_complaint_rate', 'delivery_rate'
    metric_value DECIMAL(5,2),
    timestamp TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up RLS for all new tables (example for notification_templates, others similar)
ALTER TABLE public.notification_templates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read notification templates" ON public.notification_templates FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage notification templates" ON public.notification_templates FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_queue ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own notification queue" ON public.notification_queue FOR SELECT USING (auth.uid() = recipient_id);
CREATE POLICY "Allow admins to manage notification queue" ON public.notification_queue FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.notification_preferences ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow users to read their own notification preferences" ON public.notification_preferences FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Allow users to update their own notification preferences" ON public.notification_preferences FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Allow users to insert their own notification preferences" ON public.notification_preferences FOR INSERT WITH CHECK (auth.uid() = user_id);

ALTER TABLE public.email_delivery_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email delivery logs" ON public.email_delivery_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_campaigns ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read their own email campaigns" ON public.email_campaigns FOR SELECT USING (auth.uid() = created_by);
CREATE POLICY "Allow admins to manage email campaigns" ON public.email_campaigns FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_provider_config ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email provider config" ON public.email_provider_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_webhooks ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email webhooks" ON public.email_webhooks FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_analytics ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email analytics" ON public.email_analytics FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_suppression_list ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to manage email suppression list" ON public.email_suppression_list FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.email_reputation_monitoring ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow admins to view email reputation monitoring" ON public.email_reputation_monitoring FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/003_create_unified_notifications_email.sql --\n
-- Unified Core Tables
-- This file establishes a consistent, unified schema for core entities across all Buffr projects.

-- User Roles Enum
CREATE TYPE user_role AS ENUM (
    'individual',
    'sme_user',
    'enterprise_user',
    'admin',
    'system_user'
);

-- User Status Enum
CREATE TYPE user_status AS ENUM (
    'active',
    'inactive',
    'suspended',
    'pending_verification',
    'archived'
);

-- User Plan Enum
CREATE TYPE subscription_plan AS ENUM (
    'free',
    'basic',
    'premium',
    'enterprise',
    'custom'
);

-- Users Table (integrates with Supabase Auth)
CREATE TABLE users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50) UNIQUE,
    role user_role NOT NULL DEFAULT 'individual',
    status user_status NOT NULL DEFAULT 'pending_verification',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Profiles Table
CREATE TABLE profiles (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name VARCHAR(255),
    avatar_url TEXT,
    company_name VARCHAR(255),
    job_title VARCHAR(100),
    website TEXT,
    address JSONB,
    timezone VARCHAR(100) DEFAULT 'UTC',
    language VARCHAR(10) DEFAULT 'en',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- User Preferences Table
CREATE TABLE user_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email_notifications BOOLEAN DEFAULT TRUE,
    sms_notifications BOOLEAN DEFAULT FALSE,
    push_notifications BOOLEAN DEFAULT TRUE,
    two_factor_enabled BOOLEAN DEFAULT FALSE,
    privacy_level VARCHAR(50) DEFAULT 'standard',
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organizations Table
CREATE TABLE organizations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    owner_id UUID NOT NULL REFERENCES users(id),
    email VARCHAR(255),
    phone VARCHAR(50),
    address JSONB,
    website TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Organization Members Table
CREATE TABLE organization_members (
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(50) NOT NULL DEFAULT 'member', -- e.g., admin, member, billing
    joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (organization_id, user_id)
);

-- Subscriptions Table
CREATE TABLE subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
    plan subscription_plan NOT NULL DEFAULT 'free',
    status VARCHAR(50) NOT NULL DEFAULT 'active', -- e.g., active, past_due, canceled
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE,
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_subscription CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- Add Triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_preferences_updated_at
BEFORE UPDATE ON user_preferences
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_organizations_updated_at
BEFORE UPDATE ON organizations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_subscriptions_updated_at
BEFORE UPDATE ON subscriptions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_profiles_full_name ON profiles(full_name);
CREATE INDEX idx_organizations_owner_id ON organizations(owner_id);
CREATE INDEX idx_organization_members_user_id ON organization_members(user_id);
CREATE INDEX idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
\n-- End of buffrlend-starter/sql/00_unified_core_tables.sql --\n
-- Unified File Management System Tables
-- This file establishes a generic framework for managing documents and files.

-- Document Status Enum
CREATE TYPE document_status AS ENUM (
    'draft',
    'active',
    'archived',
    'deleted'
);

-- Documents Table
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    organization_id UUID REFERENCES organizations(id),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status document_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    CONSTRAINT user_or_org_document CHECK (
        (user_id IS NOT NULL AND organization_id IS NULL) OR
        (user_id IS NULL AND organization_id IS NOT NULL)
    )
);

-- File Storage Providers Table
CREATE TABLE file_storage_providers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL, -- e.g., 'supabase_storage', 'google_drive', 's3'
    config JSONB
);

-- File Versions Table
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL,
    file_path TEXT NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    storage_provider_id INTEGER NOT NULL REFERENCES file_storage_providers(id),
    storage_metadata JSONB, -- e.g., bucket, region, file_id
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(document_id, version_number)
);

-- Document Access Table
CREATE TABLE document_access (
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    permission VARCHAR(50) NOT NULL, -- e.g., 'view', 'edit', 'owner'
    PRIMARY KEY (document_id, user_id)
);

-- Add Triggers for updated_at
CREATE TRIGGER update_documents_updated_at
BEFORE UPDATE ON documents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_documents_user_id ON documents(user_id);
CREATE INDEX idx_documents_organization_id ON documents(organization_id);
CREATE INDEX idx_file_versions_document_id ON file_versions(document_id);
\n-- End of buffrlend-starter/sql/09_unified_file_management.sql --\n
-- Unified Workflow Management System Tables
-- This file establishes a generic framework for defining and executing automated workflows.

-- Workflow Status Enum
CREATE TYPE workflow_status AS ENUM (
    'draft',
    'active',
    'inactive',
    'archived'
);

-- Workflow Execution Status Enum
CREATE TYPE workflow_execution_status AS ENUM (
    'running',
    'completed',
    'failed',
    'paused',
    'canceled'
);

-- Workflow Step Type Enum
CREATE TYPE workflow_step_type AS ENUM (
    'trigger',
    'action',
    'delay',
    'condition'
);

-- Workflow Definitions Table
CREATE TABLE workflow_definitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    status workflow_status NOT NULL DEFAULT 'draft',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Workflow Steps Table
CREATE TABLE workflow_steps (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    step_type workflow_step_type NOT NULL,
    step_order INTEGER NOT NULL,
    configuration JSONB NOT NULL, -- e.g., for trigger conditions, action parameters
    next_step_id UUID REFERENCES workflow_steps(id),
    failure_step_id UUID REFERENCES workflow_steps(id)
);

-- Workflow Executions Table
CREATE TABLE workflow_executions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workflow_id UUID NOT NULL REFERENCES workflow_definitions(id) ON DELETE CASCADE,
    status workflow_execution_status NOT NULL DEFAULT 'running',
    triggered_by TEXT, -- e.g., user_id, system_event, webhook
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    context JSONB -- For passing data between steps
);

-- Workflow Execution Logs Table
CREATE TABLE workflow_execution_logs (
    id BIGSERIAL PRIMARY KEY,
    execution_id UUID NOT NULL REFERENCES workflow_executions(id) ON DELETE CASCADE,
    step_id UUID NOT NULL REFERENCES workflow_steps(id),
    status VARCHAR(50) NOT NULL, -- e.g., success, failure
    log_message TEXT,
    output_data JSONB,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add Triggers for updated_at
CREATE TRIGGER update_workflow_definitions_updated_at
BEFORE UPDATE ON workflow_definitions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Indexes for performance
CREATE INDEX idx_workflow_steps_workflow_id ON workflow_steps(workflow_id);
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);
CREATE INDEX idx_workflow_execution_logs_execution_id ON workflow_execution_logs(execution_id);
\n-- End of buffrlend-starter/sql/08_unified_workflows.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Adumo Online Payment Gateway Integrations
-- Tables for managing Adumo Online configurations, transactions, and tokenized cards.

-- Adumo Configuration Table
CREATE TABLE adumo_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    merchant_id VARCHAR(255) NOT NULL,
    application_id VARCHAR(255) NOT NULL,
    jwt_secret TEXT NOT NULL,
    test_mode BOOLEAN DEFAULT TRUE,
    live_url TEXT,
    test_url TEXT,
    webhook_secret TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Transactions Table
CREATE TABLE adumo_transactions (
    transaction_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    merchant_reference VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'NAD',
    transaction_index UUID, -- Adumo's unique transaction identifier
    status VARCHAR(50) NOT NULL, -- e.g., 'APPROVED', 'DECLINED', 'PENDING'
    result INTEGER, -- Adumo's _RESULT code (0=success, -1=failed, 1=warning)
    error_code VARCHAR(10),
    error_message TEXT,
    bank_error_code VARCHAR(10),
    bank_error_message TEXT,
    payment_method VARCHAR(50),
    acquirer_datetime TIMESTAMP WITH TIME ZONE,
    redirect_successful_url TEXT,
    redirect_failed_url TEXT,
    request_payload JSONB,
    response_payload JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Tokenized Cards (for 1Click payments)
CREATE TABLE adumo_tokenized_cards (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    puid UUID NOT NULL UNIQUE, -- Adumo's Profile Unique Identifier
    card_type VARCHAR(50),
    pan_hashed VARCHAR(16), -- First six and last four digits
    card_country VARCHAR(50),
    expiry_date DATE, -- Stored as month/year, but can be parsed to date
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Webhook Logs
CREATE TABLE adumo_webhook_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    transaction_id UUID REFERENCES adumo_transactions(transaction_id),
    event_type VARCHAR(100) NOT NULL,
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- Indexes for performance
CREATE INDEX idx_adumo_transactions_user ON adumo_transactions(user_id);
CREATE INDEX idx_adumo_transactions_merchant_ref ON adumo_transactions(merchant_reference);
CREATE INDEX idx_adumo_transactions_status ON adumo_transactions(status);
CREATE INDEX idx_adumo_tokenized_cards_user ON adumo_tokenized_cards(user_id);
CREATE INDEX idx_adumo_webhook_logs_transaction ON adumo_webhook_logs(transaction_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_adumo_configs_updated_at
BEFORE UPDATE ON adumo_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_transactions_updated_at
BEFORE UPDATE ON adumo_transactions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_tokenized_cards_updated_at
BEFORE UPDATE ON adumo_tokenized_cards
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/18_adumo_integrations.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- RealPay Payment Gateway Integrations
-- Tables for managing RealPay configurations, mandates, instalments, and callbacks.

-- RealPay Configuration Table
CREATE TABLE realpay_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    api_key TEXT NOT NULL,
    hmac_secret TEXT NOT NULL,
    beneficiary_user VARCHAR(255),
    test_mode BOOLEAN DEFAULT TRUE,
    live_callback_url TEXT,
    test_callback_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Mandates Table (for Debicheck products)
CREATE TABLE realpay_mandates (
    mandate_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    customer_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    mandate_reference VARCHAR(255) UNIQUE NOT NULL,
    bank_account_id UUID REFERENCES banking_details(id), -- Link to unified banking_details
    mandate_status VARCHAR(50) NOT NULL, -- e.g., 'ACTIVE', 'CANCELLED', 'PENDING'
    mandate_type VARCHAR(50), -- e.g., 'DEBICHECK', 'EFT'
    start_date DATE,
    end_date DATE,
    amount DECIMAL(10,2), -- Max amount for variable mandates
    frequency VARCHAR(50), -- e.g., 'MONTHLY', 'WEEKLY'
    realpay_mandate_id VARCHAR(255), -- RealPay's internal mandate ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Instalments Table
CREATE TABLE realpay_instalments (
    instalment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_reference VARCHAR(255) UNIQUE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    collection_date DATE NOT NULL,
    instalment_status VARCHAR(50) NOT NULL, -- e.g., 'SUCCESS', 'FAILED', 'PENDING'
    realpay_instalment_id VARCHAR(255), -- RealPay's internal instalment ID
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Callback Logs (Webhooks)
CREATE TABLE realpay_callbacks (
    callback_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_id UUID REFERENCES realpay_instalments(instalment_id),
    x_callback_header VARCHAR(100) NOT NULL, -- e.g., 'MANDATE', 'INSTALMENT'
    x_hmac_header TEXT NOT NULL,
    x_beneficiary_user_header VARCHAR(255),
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- RealPay Pricing Configuration Table
CREATE TABLE realpay_pricing_configs (
    pricing_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    service_type VARCHAR(100) NOT NULL, -- e.g., 'EnDO', 'Payouts', 'VAS'
    fee_type VARCHAR(100) NOT NULL, -- e.g., 'monthly_fee', 'transaction_fee', 'once_off_fee'
    min_transactions INTEGER,
    max_transactions INTEGER,
    amount DECIMAL(10,2),
    percentage DECIMAL(5,4),
    unit_cost DECIMAL(10,2),
    description TEXT,
    effective_date DATE NOT NULL,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_realpay_mandates_customer ON realpay_mandates(customer_id);
CREATE INDEX idx_realpay_mandates_reference ON realpay_mandates(mandate_reference);
CREATE INDEX idx_realpay_instalments_mandate ON realpay_instalments(mandate_id);
CREATE INDEX idx_realpay_instalments_reference ON realpay_instalments(instalment_reference);
CREATE INDEX idx_realpay_callbacks_mandate ON realpay_callbacks(mandate_id);
CREATE INDEX idx_realpay_callbacks_instalment ON realpay_callbacks(instalment_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_realpay_configs_updated_at
BEFORE UPDATE ON realpay_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_mandates_updated_at
BEFORE UPDATE ON realpay_mandates
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_instalments_updated_at
BEFORE UPDATE ON realpay_instalments
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_pricing_configs_updated_at
BEFORE UPDATE ON realpay_pricing_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/19_realpay_integrations.sql --\n
-- Buffr API Integrations
-- Tables for managing cross-project API integrations and configurations.

-- Buffr API Integration Configurations
CREATE TABLE buffr_api_integrations (
    integration_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    target_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    integration_name VARCHAR(255) NOT NULL, -- e.g., 'BuffrLend_to_BuffrSign_LoanSigning'
    api_base_url TEXT NOT NULL,
    api_key_encrypted TEXT, -- Encrypted API key for authentication
    api_key_hash TEXT, -- Hash of the API key for verification
    is_active BOOLEAN DEFAULT TRUE,
    configuration JSONB, -- JSONB field for flexible configuration parameters
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(source_project, target_project, integration_name)
);

-- Buffr API Integration Logs (for auditing cross-project calls)
CREATE TABLE buffr_api_integration_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    integration_id UUID REFERENCES buffr_api_integrations(integration_id),
    request_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    request_method VARCHAR(10) NOT NULL, -- e.g., 'GET', 'POST'
    request_endpoint TEXT NOT NULL,
    request_payload JSONB,
    response_timestamp TIMESTAMP WITH TIME ZONE,
    response_status_code INTEGER,
    response_payload JSONB,
    error_message TEXT,
    user_id UUID REFERENCES profiles(id), -- User who initiated the action, if applicable
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_buffr_api_integrations_source_target ON buffr_api_integrations(source_project, target_project);
CREATE INDEX idx_buffr_api_integration_logs_integration ON buffr_api_integration_logs(integration_id);
CREATE INDEX idx_buffr_api_integration_logs_user ON buffr_api_integration_logs(user_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_buffr_api_integrations_updated_at
BEFORE UPDATE ON buffr_api_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/20_buffr_api_integrations.sql --\n
-- Create rate_limit_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'rate_limit_type_enum') THEN
        CREATE TYPE rate_limit_type_enum AS ENUM (
            'ip_address',
            'user_id',
            'api_key',
            'endpoint',
            'global'
        );
    END IF;
END $$;

-- Create the unified rate_limits table
CREATE TABLE IF NOT EXISTS public.rate_limits (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT UNIQUE NOT NULL, -- e.g., 'login_attempts', 'api_requests_per_minute'
    limit_value INTEGER NOT NULL, -- Max requests allowed
    time_window_seconds INTEGER NOT NULL, -- Time window in seconds
    type rate_limit_type_enum NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create the unified rate_limit_status table to track current usage
CREATE TABLE IF NOT EXISTS public.rate_limit_status (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    identifier TEXT NOT NULL, -- IP address, user_id, API key, or endpoint path
    current_requests INTEGER DEFAULT 0,
    last_reset_at TIMESTAMPTZ DEFAULT NOW(),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, identifier)
);

-- Create the unified rate_limiting_exemptions table
CREATE TABLE IF NOT EXISTS public.rate_limiting_exemptions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    rate_limit_id UUID REFERENCES public.rate_limits(id) ON DELETE CASCADE,
    exempt_identifier TEXT NOT NULL, -- IP address, user_id, API key, etc.
    exemption_reason TEXT,
    expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE (rate_limit_id, exempt_identifier)
);

-- Set up RLS for all new tables
ALTER TABLE public.rate_limits ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limits" ON public.rate_limits FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limits" ON public.rate_limits FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limit_status ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limit status" ON public.rate_limit_status FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limit status" ON public.rate_limit_status FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

ALTER TABLE public.rate_limiting_exemptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to read rate limiting exemptions" ON public.rate_limiting_exemptions FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Allow admins to manage rate limiting exemptions" ON public.rate_limiting_exemptions FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/004_create_unified_rate_limiting.sql --\n
-- Adumo Online Payment Gateway Integrations
-- Tables for managing Adumo Online configurations, transactions, and tokenized cards.

-- Adumo Configuration Table
CREATE TABLE adumo_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    merchant_id VARCHAR(255) NOT NULL,
    application_id VARCHAR(255) NOT NULL,
    jwt_secret TEXT NOT NULL,
    test_mode BOOLEAN DEFAULT TRUE,
    live_url TEXT,
    test_url TEXT,
    webhook_secret TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Transactions Table
CREATE TABLE adumo_transactions (
    transaction_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    merchant_reference VARCHAR(255) NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'NAD',
    transaction_index UUID, -- Adumo's unique transaction identifier
    status VARCHAR(50) NOT NULL, -- e.g., 'APPROVED', 'DECLINED', 'PENDING'
    result INTEGER, -- Adumo's _RESULT code (0=success, -1=failed, 1=warning)
    error_code VARCHAR(10),
    error_message TEXT,
    bank_error_code VARCHAR(10),
    bank_error_message TEXT,
    payment_method VARCHAR(50),
    acquirer_datetime TIMESTAMP WITH TIME ZONE,
    redirect_successful_url TEXT,
    redirect_failed_url TEXT,
    request_payload JSONB,
    response_payload JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Tokenized Cards (for 1Click payments)
CREATE TABLE adumo_tokenized_cards (
    token_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    user_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    puid UUID NOT NULL UNIQUE, -- Adumo's Profile Unique Identifier
    card_type VARCHAR(50),
    pan_hashed VARCHAR(16), -- First six and last four digits
    card_country VARCHAR(50),
    expiry_date DATE, -- Stored as month/year, but can be parsed to date
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Adumo Webhook Logs
CREATE TABLE adumo_webhook_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES adumo_configs(config_id),
    transaction_id UUID REFERENCES adumo_transactions(transaction_id),
    event_type VARCHAR(100) NOT NULL,
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- Indexes for performance
CREATE INDEX idx_adumo_transactions_user ON adumo_transactions(user_id);
CREATE INDEX idx_adumo_transactions_merchant_ref ON adumo_transactions(merchant_reference);
CREATE INDEX idx_adumo_transactions_status ON adumo_transactions(status);
CREATE INDEX idx_adumo_tokenized_cards_user ON adumo_tokenized_cards(user_id);
CREATE INDEX idx_adumo_webhook_logs_transaction ON adumo_webhook_logs(transaction_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_adumo_configs_updated_at
BEFORE UPDATE ON adumo_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_transactions_updated_at
BEFORE UPDATE ON adumo_transactions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_adumo_tokenized_cards_updated_at
BEFORE UPDATE ON adumo_tokenized_cards
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/18_adumo_integrations.sql --\n
-- Create a unified user_roles enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role_enum') THEN
        CREATE TYPE user_role_enum AS ENUM (
            'individual',
            'sme_user',
            'enterprise_user',
            'admin',
            'hospitality_staff',
            'customer',
            'corporate_customer'
        );
    END IF;
END $$;

-- Create the profiles table, linked to Supabase auth.users
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT UNIQUE NOT NULL,
    full_name TEXT,
    phone_number TEXT,
    company_name TEXT,
    user_role user_role_enum DEFAULT 'individual'::user_role_enum,
    plan_type TEXT DEFAULT 'free', -- e.g., 'free', 'basic', 'premium', 'enterprise'
    status TEXT DEFAULT 'active', -- e.g., 'active', 'suspended', 'inactive', 'pending_verification'
    is_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    -- Additional fields from BuffrSign's User model
    preferences JSONB DEFAULT '{}'::jsonb,
    biometric_data JSONB DEFAULT '[]'::jsonb,
    behavioral_metrics JSONB DEFAULT '{}'::jsonb,
    subscription_expires_at TIMESTAMPTZ,
    -- Additional fields from BuffrLend's profiles
    first_name TEXT,
    last_name TEXT,
    -- Additional fields from The Shandi's BuffrHostUser (if applicable, linked via profiles)
    property_id INTEGER, -- Link to hospitality_property if applicable
    user_type_id INTEGER, -- Link to user_type if applicable
    permissions TEXT[] DEFAULT '{}'::TEXT[],
    -- KYC Information (from BuffrSign's UserRegistrationWithKYC)
    country_code TEXT,
    national_id_number TEXT,
    national_id_type TEXT,
    id_document_url TEXT,
    kyc_status TEXT DEFAULT 'pending', -- e.g., 'pending', 'verified', 'rejected'
    consent_given BOOLEAN DEFAULT FALSE,
    legal_basis TEXT,
    retention_period INTEGER -- in days
);

-- Set up Row Level Security (RLS) for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Policies for profiles table
DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON public.profiles;
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (TRUE);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Create functions to keep profiles table in sync with auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, full_name, created_at, last_login_at)
  VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'name', NEW.created_at, NEW.last_sign_in_at);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create trigger to call handle_new_user function on new auth.users inserts
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Create function to update profiles table when auth.users is updated
CREATE OR REPLACE FUNCTION public.handle_user_update()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.profiles
  SET
    email = NEW.email,
    full_name = NEW.raw_user_meta_data->>'name',
    last_login_at = NEW.last_sign_in_at,
    updated_at = NOW()
  WHERE id = NEW.id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_updated ON auth.users;

-- Create trigger to call handle_user_update function on auth.users updates
CREATE TRIGGER on_auth_user_updated
AFTER UPDATE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_update();

-- Create function to delete profiles table when auth.users is deleted
CREATE OR REPLACE FUNCTION public.handle_user_delete()
RETURNS TRIGGER AS $$
BEGIN
  DELETE FROM public.profiles WHERE id = OLD.id;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS on_auth_user_deleted ON auth.users;

-- Create trigger to call handle_user_delete function on auth.users deletes
CREATE TRIGGER on_auth_user_deleted
AFTER DELETE ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete();

-- Create the customer table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.customers (
    customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    customer_type TEXT NOT NULL DEFAULT 'individual', -- 'individual', 'corporate'
    loyalty_score INTEGER DEFAULT 0,
    registration_date TIMESTAMPTZ DEFAULT NOW(),
    last_activity TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Set up Row Level Security (RLS) for customers table
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;

-- Policies for customers table
DROP POLICY IF EXISTS "Customers are viewable by authenticated users." ON public.customers;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own customer record." ON public.customers;
CREATE POLICY "Users can insert their own customer record." ON public.customers FOR INSERT WITH CHECK (auth.uid() = customer_id);

DROP POLICY IF EXISTS "Users can update own customer record." ON public.customers;
CREATE POLICY "Users can update own customer record." ON public.customers FOR UPDATE USING (auth.uid() = customer_id);

-- Create the corporate_customers table, linking to the unified profiles table
CREATE TABLE IF NOT EXISTS public.corporate_customers (
    corporate_customer_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    company_registration_number TEXT UNIQUE NOT NULL,
    industry TEXT,
    contact_person_id UUID REFERENCES public.profiles(id), -- Link to a profile that is the main contact
    billing_address JSONB,
    tax_information JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up Row Level Security (RLS) for corporate_customers table
ALTER TABLE public.corporate_customers ENABLE ROW LEVEL SECURITY;

-- Policies for corporate_customers table
DROP POLICY IF EXISTS "Corporate customers are viewable by authenticated users." ON public.corporate_customers;
CREATE POLICY "Corporate customers are viewable by authenticated users." ON public.corporate_customers FOR SELECT USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can insert their own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can insert their own corporate customer record." ON public.corporate_customers FOR INSERT WITH CHECK (auth.uid() = corporate_customer_id);

DROP POLICY IF EXISTS "Users can update own corporate customer record." ON public.corporate_customers;
CREATE POLICY "Users can update own corporate customer record." ON public.corporate_customers FOR UPDATE USING (auth.uid() = corporate_customer_id);
\n-- End of buffrlend-starter/sql/001_create_unified_users_and_profiles.sql --\n
-- Create audit_event_type enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_event_type_enum') THEN
        CREATE TYPE audit_event_type_enum AS ENUM (
            'user_login',
            'user_logout',
            'user_registration',
            'user_profile_update',
            'document_upload',
            'document_view',
            'document_sign',
            'document_workflow_start',
            'document_workflow_update',
            'document_workflow_complete',
            'kyc_workflow_start',
            'kyc_workflow_update',
            'kyc_workflow_complete',
            'payment_transaction',
            'system_config_update',
            'security_alert',
            'data_export',
            'data_import',
            'api_call',
            'error',
            'other'
        );
    END IF;
END $$;

-- Create audit_severity_enum
DO $$ BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'audit_severity_enum') THEN
        CREATE TYPE audit_severity_enum AS ENUM (
            'info',
            'low',
            'medium',
            'high',
            'critical'
        );
    END IF;
END $$;

-- Create the unified audit_logs table
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum NOT NULL,
    actor_id UUID REFERENCES auth.users(id) ON DELETE SET NULL, -- User who performed the action
    target_id TEXT, -- ID of the resource affected (e.g., document_id, user_id, workflow_id)
    target_table TEXT, -- Table name of the resource affected
    event_description TEXT NOT NULL,
    event_data JSONB DEFAULT '{}'::jsonb, -- Flexible JSONB for specific event details
    severity audit_severity_enum DEFAULT 'info'::audit_severity_enum,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Compliance-related fields
    legal_basis TEXT,
    consent_given BOOLEAN,
    retention_period INTEGER -- in days
);

-- Add index for faster querying
CREATE INDEX IF NOT EXISTS idx_audit_logs_event_type ON public.audit_logs (event_type);
CREATE INDEX IF NOT EXISTS idx_audit_logs_actor_id ON public.audit_logs (actor_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_target_id ON public.audit_logs (target_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at DESC);

-- Set up Row Level Security (RLS) for audit_logs table
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policies for audit_logs table (only admins can view all, users can view their own)
DROP POLICY IF EXISTS "Admins can view all audit logs." ON public.audit_logs;
CREATE POLICY "Admins can view all audit logs." ON public.audit_logs FOR SELECT USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));

DROP POLICY IF EXISTS "Users can view their own audit logs." ON public.audit_logs;
CREATE POLICY "Users can view their own audit logs." ON public.audit_logs FOR SELECT USING (auth.uid() = actor_id);

-- Create audit_config table for standardized audit configuration
CREATE TABLE IF NOT EXISTS public.audit_config (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_type audit_event_type_enum UNIQUE NOT NULL,
    is_enabled BOOLEAN DEFAULT TRUE,
    retention_policy_days INTEGER DEFAULT 365, -- Default retention for this event type
    alert_on_severity audit_severity_enum[] DEFAULT '{high,critical}'::audit_severity_enum[],
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Set up RLS for audit_config (only admins can manage)
ALTER TABLE public.audit_config ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins can manage audit config." ON public.audit_config;
CREATE POLICY "Admins can manage audit config." ON public.audit_config FOR ALL USING (EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND user_role = 'admin'));
\n-- End of buffrlend-starter/sql/002_create_unified_audit_logging.sql --\n
-- RealPay Payment Gateway Integrations
-- Tables for managing RealPay configurations, mandates, instalments, and callbacks.

-- RealPay Configuration Table
CREATE TABLE realpay_configs (
    config_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    property_id INTEGER REFERENCES HospitalityProperty(property_id) ON DELETE CASCADE, -- Optional, for Buffr Host
    project_name VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    api_key TEXT NOT NULL,
    hmac_secret TEXT NOT NULL,
    beneficiary_user VARCHAR(255),
    test_mode BOOLEAN DEFAULT TRUE,
    live_callback_url TEXT,
    test_callback_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Mandates Table (for Debicheck products)
CREATE TABLE realpay_mandates (
    mandate_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    customer_id UUID REFERENCES profiles(id), -- Link to unified profiles table
    mandate_reference VARCHAR(255) UNIQUE NOT NULL,
    bank_account_id UUID REFERENCES banking_details(id), -- Link to unified banking_details
    mandate_status VARCHAR(50) NOT NULL, -- e.g., 'ACTIVE', 'CANCELLED', 'PENDING'
    mandate_type VARCHAR(50), -- e.g., 'DEBICHECK', 'EFT'
    start_date DATE,
    end_date DATE,
    amount DECIMAL(10,2), -- Max amount for variable mandates
    frequency VARCHAR(50), -- e.g., 'MONTHLY', 'WEEKLY'
    realpay_mandate_id VARCHAR(255), -- RealPay's internal mandate ID
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Instalments Table
CREATE TABLE realpay_instalments (
    instalment_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_reference VARCHAR(255) UNIQUE NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    collection_date DATE NOT NULL,
    instalment_status VARCHAR(50) NOT NULL, -- e.g., 'SUCCESS', 'FAILED', 'PENDING'
    realpay_instalment_id VARCHAR(255), -- RealPay's internal instalment ID
    failure_reason TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- RealPay Callback Logs (Webhooks)
CREATE TABLE realpay_callbacks (
    callback_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    mandate_id UUID REFERENCES realpay_mandates(mandate_id),
    instalment_id UUID REFERENCES realpay_instalments(instalment_id),
    x_callback_header VARCHAR(100) NOT NULL, -- e.g., 'MANDATE', 'INSTALMENT'
    x_hmac_header TEXT NOT NULL,
    x_beneficiary_user_header VARCHAR(255),
    payload JSONB NOT NULL,
    received_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE,
    status VARCHAR(50) -- e.g., 'processed', 'failed', 'pending'
);

-- RealPay Pricing Configuration Table
CREATE TABLE realpay_pricing_configs (
    pricing_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    config_id UUID REFERENCES realpay_configs(config_id),
    service_type VARCHAR(100) NOT NULL, -- e.g., 'EnDO', 'Payouts', 'VAS'
    fee_type VARCHAR(100) NOT NULL, -- e.g., 'monthly_fee', 'transaction_fee', 'once_off_fee'
    min_transactions INTEGER,
    max_transactions INTEGER,
    amount DECIMAL(10,2),
    percentage DECIMAL(5,4),
    unit_cost DECIMAL(10,2),
    description TEXT,
    effective_date DATE NOT NULL,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_realpay_mandates_customer ON realpay_mandates(customer_id);
CREATE INDEX idx_realpay_mandates_reference ON realpay_mandates(mandate_reference);
CREATE INDEX idx_realpay_instalments_mandate ON realpay_instalments(mandate_id);
CREATE INDEX idx_realpay_instalments_reference ON realpay_instalments(instalment_reference);
CREATE INDEX idx_realpay_callbacks_mandate ON realpay_callbacks(mandate_id);
CREATE INDEX idx_realpay_callbacks_instalment ON realpay_callbacks(instalment_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_realpay_configs_updated_at
BEFORE UPDATE ON realpay_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_mandates_updated_at
BEFORE UPDATE ON realpay_mandates
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_instalments_updated_at
BEFORE UPDATE ON realpay_instalments
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_realpay_pricing_configs_updated_at
BEFORE UPDATE ON realpay_pricing_configs
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/19_realpay_integrations.sql --\n
-- Buffr API Integrations
-- Tables for managing cross-project API integrations and configurations.

-- Buffr API Integration Configurations
CREATE TABLE buffr_api_integrations (
    integration_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    target_project VARCHAR(100) NOT NULL, -- e.g., 'buffrlend', 'buffrsign', 'buffrhost'
    integration_name VARCHAR(255) NOT NULL, -- e.g., 'BuffrLend_to_BuffrSign_LoanSigning'
    api_base_url TEXT NOT NULL,
    api_key_encrypted TEXT, -- Encrypted API key for authentication
    api_key_hash TEXT, -- Hash of the API key for verification
    is_active BOOLEAN DEFAULT TRUE,
    configuration JSONB, -- JSONB field for flexible configuration parameters
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE,
    UNIQUE(source_project, target_project, integration_name)
);

-- Buffr API Integration Logs (for auditing cross-project calls)
CREATE TABLE buffr_api_integration_logs (
    log_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    integration_id UUID REFERENCES buffr_api_integrations(integration_id),
    request_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    request_method VARCHAR(10) NOT NULL, -- e.g., 'GET', 'POST'
    request_endpoint TEXT NOT NULL,
    request_payload JSONB,
    response_timestamp TIMESTAMP WITH TIME ZONE,
    response_status_code INTEGER,
    response_payload JSONB,
    error_message TEXT,
    user_id UUID REFERENCES profiles(id), -- User who initiated the action, if applicable
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX idx_buffr_api_integrations_source_target ON buffr_api_integrations(source_project, target_project);
CREATE INDEX idx_buffr_api_integration_logs_integration ON buffr_api_integration_logs(integration_id);
CREATE INDEX idx_buffr_api_integration_logs_user ON buffr_api_integration_logs(user_id);

-- Add updated_at triggers (assuming update_updated_at_column() function exists)
CREATE TRIGGER update_buffr_api_integrations_updated_at
BEFORE UPDATE ON buffr_api_integrations
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
\n-- End of buffrlend-starter/sql/20_buffr_api_integrations.sql --\n
